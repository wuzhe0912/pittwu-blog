---
title: 面試問題：ES6
date: 2019-6-5 20:54:10
tags:
  - Interview
  - ES6
---
ES6 的面試問題，更多會是原生 JS 問題延伸過來，所以在回答問題上，可以更靈活結合兩者來答覆，譬如說，當問到 this 的指向問題時，先回答 ES5 的情境，再延伸論述 ES6 加上的 arrow function 的狀況，可以讓答案更為完整。但目前 ES6 的問題整理較少，有空我就會盡量補充。
<!--more-->
### 定義 var、let、const 
在 ES6 中，新增了兩種變數宣告方式 let、const，傳統的 var 容易污染到全域變數，因此在 ES6 調整了變數應用在作用域的範圍，通常是以 function 為分界，使用 let 在 function 內宣告變數後，可以避免離開 function 仍被污染，另一方面也可以再次賦值。const 定義為常數，不能重複賦值，而且也要求一定要賦值。

### 僅宣告 const a 會出現什麼狀況？
const 作為一種常數宣告，不允許未賦值的情況，會跳出以下錯誤：
```
Uncaught SyntaxError: Missing initializer in const declaration
```
但是 var、let 可以接受未賦值時，預設值為 undefined

### 請簡單說明 arrow function？
最簡單的說法，更簡短的函式宣告方式，省略了 function 改用 => 取代，但除了這點外，語法特性上，若參數僅有一個的情況下可以省略()，另外若 return 只有一行的狀況下可以省略 {}，但這邊是看團隊的 coding style，我個人不習慣太省略的寫法。

另外需要注意，在 ES6 中使用 arrow function 的狀況下，this 會被全部指向全域變數(window)。

### ES5 和 ES6 的差異？
- 作用域的區分更為嚴謹，新增了兩種宣告變量的方式，避免污染問題。

- arrow function：讓函式的寫法變得更為簡短，雖然極短可以在只有一行回傳時，可以縮減大括號({})，但我不考慮這樣寫，維護和閱讀都很不容易。另外也讓 this 的指向問題變得更為單純，全部指向全域變數(window)。

- 字符串模板，讓程式碼更為簡潔，避免過往的頻繁 '' + ''。

- 非同步操作：提供 Promise 方法來改善過往的 callback 的問題，但會建議和 async/await 一起搭配，否則也是會容易出現 .then() 串下去的窘境。

- 解構賦值讓變數交換簡化，同時書寫起來更為方便。

- class 會是比較重要的概念，雖然嚴格來說還不能稱為物件導向，但應該算是近似了。透過 class 的方式搭配 constructor 建立物件(這個物件就是原型)。當我 new 一個新的物件時，同時會傳屬性進去，再透過 constructor 內進行賦值，接著就可以執行我想要執行的函式。而且當原型建立後，我可以在外面宣告數個 new 物件，分別傳不同屬性進去。

- 模組化規劃寫法，import 導入，export 導出。