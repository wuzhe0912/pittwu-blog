---
title: 常見面試問題：通用
date: 2019-12-03 01:47:21
tags: Interview
---
通用性面試問題彙整。
<!--more-->
###  近期學習了什麼？
主要在摸索 Nuxt 開發，以及一些架站與 CICD 相關的知識，考慮到未來工作，必須認真看待(前職沒有這個需求) SEO 的需求，SSR 這一塊無可避免會碰觸到，因此抽出一些時間來加以了解。

### 如果今年你能精通一項技術，那會是什麼？(2020) 
主要希望能將 Nuxt 掌握到熟稔程度，能順利上手開發，但因爲 Nuxt 又是以 Node 為基底，所以 Node 的基礎知識與運用也必須補上。

### 喜好的開發環境 (作業系統, 編輯器或 IDE, 瀏覽器, 開發工具 … 之類)。
前端開發目前主要使用 mac os 系統，一方面是生態系完整，如果遇到問題，相對容易透過網路資訊排除。早期有使用過一陣子 sublime 和 ATOM，後來因為 vscode 急起直追和插件生態日益豐富完整，最後投入 vscode 懷抱。瀏覽器就是以 Chrome 為開發，畢竟習慣了 Chrome 的開發者工作，偶爾還是會回去摸摸 Firefox，但除錯方面，除了是特定瀏覽器破版問題，否則仍以 Chrome 為主。

### 最熟悉哪一套版本控制系統？ 
git，前職的團隊，主要使用 GUI 工具(SourceTree)，方便查看節點，但目前也持續筆記 git 指令，方便未來自己在終端機直接操作。

### 可以描述前一份工作在開發一個網站時的流程是？
依循 4 階段規劃進行開發：分析 => 規劃 => 實作 => 驗證
  - 分析：需求營運方+UI/UX+前後端+QA進行開會，明確釐清專案訴求為何？
  - 規劃：專案可能會面臨時程問題，或是技術上目前是否可行，先列出優先度最重要的功能，確保功能面且權重最重者，可以優先上線，後續再針對次要功能與樣式進行優化。
  - 實作：依據現有技術進行實作開發，倘若開發面臨困難，則提前反饋給主管。反之，若實際開發可行，但程式碼不如預期優雅，則以先不報錯為原則，試寫出第一版，後續再進行重構。
  - 驗證：因為目前還未掌握自動化測試，目前驗證手法仍以手動驗證為主，大多採用由其他組員進行手動測試，並撰寫測試文件，當測試通過才發PR給主管。另外，若是QA驗證出現錯誤或是上線後發現錯誤，則統一發佈到issues，再依優先度解決。

### 如果加入了一個專案，但是他們的程式碼用 tabs，但是你習慣用spaces (空白鍵)，你會怎麼做？
通常若是維護舊專案，會配合既有專案的風格進行開發，但若是新專案，則會討論 coding style 如何處理，不過我個人也是採用 tab。

### 描述漸進增強 (progressive enhancement) 和優美退化 (graceful degradation) 間的差異？
漸進漸強：從基本功能開始開發，保證系統在各種瀏覽器環境都可以執行，再逐步增加功能及提升使用者體驗。
優美退化：開發系統時，就針對最新最完善的環境來設計，而對於較舊的平台僅提供基本功能，而非完整功能。
但目前實務上，專案只碰過漸進增強的理念，因為通常專案時程規劃，大都蠻不友善的XD，在有限的時間內，通常是優先讓功能面先上線，後續再逐步優化。

### 前端效能優化可以怎麼做？
受限於現代網站載入的資源體積越來越大，因此若要著手優化網站的效能，大概要先從載入資源大小、畫面渲染兩方面來著手。
1. 載入資源
  - 壓縮並醜化檔案，無論是 css 的 minify，或是 JS 的 uglify，都可以大幅縮減檔案體積，不過目前處理這些工作，大都丟給 webpack 一並處理。
  - 壓縮圖片檔案大小，此前是使用 tinypng 工具。

2. 畫面渲染
  - 盡可能將 css 抽離出來，不要和 JS 混在一起。在 webpack 中使用 extract-text-webpack-plugin。這麼做的目的，當然是為了利用瀏覽器本身的緩存的特性，因此能用 css 處理的地方就不使用 JS，這樣可以節省開啟頁面的時間。

### 什麼是 Deadlock(死鎖)？
這邊是指進程死鎖，後端語言具有多線程特性，可以同時執行多個任務，通常會出現某個進程正在等待其中一個資源，結果好死不死，那個資源正在被其他進程使用。當這種狀況出現好幾組時，就很有可能會互相卡住，結果導致無限期僵持，最終陷入死鎖。

造成這種原因的可能因素有兩種，要嘛是資源有限，要不嘛就是進程推進順序不正確。但對 JS 這種單線程語言來說，應該只會出現無限循環而不會出現死鎖。

### webpack 中 babel 如何設定？
#### 環境搭建 & 基本設定
- plugins install --dev
```
@babel/cli
@babel/core
@babel/preset-env
```
基本設定寫在 .babelrc 的檔案中：
```
{
  "presets": [
    [
      "@babel/preset-env"
    ]
  ],
  "plugins": []
}
```
@babel/preset-env，通常會用來放一些常用的語法解析，預設 babel 官方已經有提供 ES6 語法解析。babel 本身主要專注在解析語法，但新的 API 會被忽略，因此需要 polyfill 來輔助。

- babel-polyfill
  ```
  @babel/polyfill
  ```
  babel-polyfill 就是延伸早期的 polyfill 方案，再結合 core-js 和 regenerator 形成強大的集合，幫助開發者將所有的新的語法打上補丁，讓他們可以在低版本的瀏覽器正常運作。但 babel 官方 7.4 版本後，建議直接使用 core-js 和 regenerator。但因為 babel-polyfill 本身體積蠻大的，畢竟是集合解析所有語法，所以需要在 .babelrc 調整設定：
  ```
  {
    "presets": [
      [
        "@babel/preset-env",
        {
          "useBuiltIns": "usage",
          "corejs": 3
        }
      ]
    ],
    "plugins": []
  }
  ```
  usage 即可以只引入專案中有用到的語法，3 則是當前 core-js 版本號。

- babel-runtime
  ```
  @babel/runtime

  // dev
  @babel/plugin-transform-runtime
  ```
  babel-polyfill 本身會有污染全域的問題，所以需要透過 babel-runtime 來處理，安裝完插件後，設定如下(直接照官方預設設定)：
  ```
  {
    "presets": [
      [
        "@babel/preset-env",
        {
          "useBuiltIns": "usage",
          "corejs": 3
        }
      ]
    ],
    "plugins": [
      [
        "@babel/plugin-transform-runtime",
        {
          "absoluteRuntime: false,
          "corejs": 3,
          "helpers": true,
          "regenerator": true,
          "useESModules": false
        }
      ]
    ]
  }
  ```

### 優化網頁讀取速度的方法 (感覺上的速度或是真正的讀取時間)。

