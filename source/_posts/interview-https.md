---
title: 常見面試問題：網路相關
date: 2019-12-07 00:34:53
tags: Interview
---
網路相關面試題目彙整。
<!--more-->
### 從輸入網址列到渲染畫面，過程經歷了什麼事？
- 第一階段：確認 IP 地址是否存在
我們透過瀏覽器輸入一段網址，瀏覽器會根據這一串網址去呼叫 DNS Server，讓 DNS 去確認這串網址對應的 IP 位置，如果沒找到就 gg，但為了後面的內容，所以這邊是一定要找到的。DNS 找到 IP 後會回傳給瀏覽器，瀏覽器開始連線到這個網址，接著進入第二階段

- 第二階段：網路請求資料
這個階段基本可以理解為前端(Client)向後端(Server)拿資料。這個流程挺複雜的，我的理解拆為以下三階段：
  - 打招呼：俗稱三次握手，Client 向 Server 詢問是否存在，Server 回應我在，接著 Client 宣告我準備要執行傳資料的動作囉。
  - 傳送資料(req & res)：前端透過某個 method 向後端拿資料，這邊用 get，後端送封包過去後，再傳一組成功的狀態碼(200)給前端。
  - 結束關閉：Client 向 Server 通知準備關閉，Server 向 Client 說 ok 我也要關閉了，並進行關閉，接著 Client 也進行關閉，這階段俗稱四次揮手。

- 第三階段：取得資料，開始進行頁面渲染
首先 HTML 和 CSS 會優先執行，前者開始搭建整個頁面 DOM Tree，後者則是提前準備好所有樣式，接著來到 style 階段，將樣式指到對應的元素，Layout 開始排列頁面位置，最終完成頁面渲染。至於 JS，為了確保使用者最低限度要能看到靜態頁面，所以依慣例我們會將 JS 的執行順序放至 body 底部，確保它最後執行。

- [詳細圖解](https://w3c.hexschool.com/blog/8d691e4f)

### 什麼是瀏覽器的同源策略？另外跨域問題，如何解決？
當 ajax 發出請求時，瀏覽器會要求當前網頁與 server，基於安全性必須同源，也就是協議(http、https)、域名(abc.com)、端口(8080)，三者皆必須一致，只要任一者不同，就是不同源，倘若三者相同則為同源(符合同源策略)，同源策略僅限瀏覽器，後端(server)無此限制。當然，如果是 cdn 引入 js 的框架，或是 css 引入圖片網址，可以無視這個規則。
當非同源時，前端發出請求時，需要進行跨域，而任何跨域行為，理當經過 server 端允許，若未經允許即可實現跨域，代表網站本身已存在重大漏洞。解決方案，主要有三種，JSONP 和 CORS 以及代理，JSONP 透過 script 導入目前比較少使用，CORS 則是由後端處理，前端直接使用，代理則需要特定設置(vue => vue.config.js)。
當然，如果是 cdn 引入 js 的框架，或是 css 引入圖片網址，可以無視這個規則。任何跨域行為，都應該經過 server 端允許，若未經允許即可實現跨域，代表網站本身已存在重大漏洞。

### CORS 是什麼，它解決了什麼問題？
前端的一種跨域方式，由 server 端設置(通常是由後端設置在 http header)，前端可以直接使用，也可以只允許特定網址使用。

### Proxy 代理
得通過 nginx server 的設定來達成，以 Vue 為例，在 vue.config.js 進行設定：
```
module.exports = {
  devServer: {
    host: 'localhost',
    port: 8080,
    // 當網址攔截到 /api
    proxy: {
      '/api': {
        // 目標要指向哪個網址
        target: 'https://www.xxx.com',
        changeOrigin: true,
        /*
          實務上，會遇到n個api，每一隻api路徑皆有所差別
          為了統一攔截，因此虛擬化了一個路徑 /api
          但當轉發路徑時，才將這個虛擬化的路徑轉為空
        */
        pathRewrite: {
          'api/': ''
        }
      }
    }
  }
}
```
代理的安全性較高，可以隱藏後端 server 的來源，同時前後端需要設定的東西也較少。

### 描述 cookies/localStorage/sessionStorage 的差別？
這三者都是前端在瀏覽器儲存的方式，cookie 是比較早期的做法，儲存的容量有限，只有 4KB，預設保存時效是瀏覽器關閉時就失效。一方面是本身儲存的容量小，另一方面因為會攜帶在 http 中，所以太多數據又會影響效能，所以大多不使用 cookie。

但我個人此前有一個使用場景，業務推廣產品網址會帶有一組推廣碼，營運方希望在客戶成功註冊前，保存這組推廣碼24小時，我的解法是：
```
當客戶透過推廣網址進入時註冊頁面時，立刻觸發保存當前時間(new Date())
接下來利用 getTime() 來取從紀元時間到當前時間的毫秒數，再往後加上 24 小時的毫秒數
等於建立了一個時間戳記，再把它存到 document.cookie 的 expires，達到希望失效時間的目的。
```

localStorage 和 sessionStorage 都是從 HTML5 開始提供的 API，儲存的容量大 5MB，也不會對效能產生問題，所以目前已用來取代 cookie，但因為兩者使用 API 相同，前者永久保存除非手動清除，後者則一樣是關閉瀏覽器即失效，因此多用前者居多。除了常見於用來保存 login 的 token，我個人還有用過一個情境在於，當網站透過 i18n 建立多語系功能時，客戶第一次進入網站時，前台會使用後台預設的語系，但當客戶切換語系後，會透過 localStorage 來保存客戶切換的語系，避免下次進入時失效，畢竟我們無法判斷客戶下次登入網站時間，所以這邊採用永久保存會是比較好的做法。


- [詳細圖解](https://medium.com/@bebebobohaha/cookie-localstorage-sessionstorage-%E5%B7%AE%E7%95%B0-9e1d5df3dd7f)

### 請簡單解釋 RESTful API
表現層狀態轉移...嗯，這種不是人話的東西，基本上是看不懂的。當然撰寫 RESTful API 是有固定的風格設計，譬如使用名詞而不盡量不使用動詞之類的。但對前端來說，應該可以拆成三部分來理解，查看後端提供的 API 文件：
1. url => 告訴前端你請求的是什麼，全部的產品列表或是單一商品的細節
2. method => 使用哪一種方法，get(獲取)，post(送出增加)，delete(刪除)，put(更改)
3. status code => 拿到的 api 結果為何？成功或失敗，細部原因是什麼

### 請解釋一下 TCP 和 UDP
本質上都是網路通訊協議，也都是通過封包來傳送資料。
- UDP：雖然本質雷同，但 UDP 可以理解為最低程度的傳送資料方式，它只管送資料，不在意接收方是否有接受到，所以也是一種不可靠傳輸，同時接收方也可能出現資料到達時間不一致的問題。如果是做直播類產品，可能會考慮採用 UDP，因為 UDP 傳送資料速度快，不需要和 TCP 一樣進行反覆確認的握手揮手機制，在低速弱網環境下，使用體驗更好，而且丟失的封包是可以承受的。另外就是，因為傳送快加上不需要握手，所以漏洞反而較少，DDOS 很難攻擊(但仍有攻擊手段 flood)。

- TCP：最大宗的通用協議，他的運作機制嚴謹可靠且穩定，所以又被稱為可靠性傳輸，需要拆解成三階段來理解連線、傳輸、斷線。
  - 一、打招呼階段(三次握手)：
    1. 前端先向 server 端 say hello，確定 server 端是否存在
    2. server 端回應存在
    3. 前端接著會通知說準備傳送資料
  
  - 二、傳送資料階段：前端會透過某個 method 來送出請求，例如 get。server 端接收到請求後，不管成功與否，會回傳一段資料和狀態碼(status code)給前端，這時前端就能判斷請求有沒有成功。

  - 三、說再見階段(四次分手)：
    1. 前端會先通知 server 端準備分手
    2. server 端收到通知後，會先回傳可以理解的訊息
    3. 接著 server 端會再通知一個執行分手動作的訊息
    4. 前端回傳 ok(此處 server 正式分手斷線)，而前端大約 4 分鐘後才會釋出資源正式斷線

  這麼嚴謹的機制帶來的就是速度慢，效率不佳，消耗的資源也多，尤其三次握手階段，容易出現漏洞被攻擊。

### 簡單說幾個常見的 http 狀態碼？
- 1XX => server 端已收到請求，需要請求者繼續執行操作
```
100 // 臨時性的狀態碼，client 仍在繼續發送請求
101 // server 端依據 client 端的請求切換協議(只能向上切換)
```

- 2XX => 請求已成功，server 端成功接收並執行處理
```
200 // server 端回傳成功 status code
```

- 3XX => 請求重定向網址，需要進一步的操作來完成請求
```
301 // 請求的網頁或資源已被移到新的 URL，之後的請求都必須使用新的 URL
```


- 4XX => client 端出現錯誤
```
400 // 前端直接送錯請求，server 端無法解析處理
401 // 缺少 Token 或是認證失敗，需要登入的頁面，常會進行這個狀態阻擋
403 // 認證已完成，但權限不足被擋住
404 // server 端找不到請求的網頁，或者是找不到資源
```

- 5XX => server 端出現錯誤
```
500 // server 端遇到錯誤(通常是掛了)
502 // 網關或代理錯誤，通常是某個服務或功能爆了
503 // server 暫時無法使用(常用於停機維修)
504 // 一直沒收到請求，也就是所謂的 api 請求超時
```

### http 狀態碼 401 和 403 兩者有什麼區別？
- 401：
  代表認證錯誤，可能缺少 Token 或是認證失敗，如果確定程式碼正確，那有時候可能是偶發性的臨時狀況，通常這時候會請用戶直接重整頁面。

- 403：
  則是認證本身已經成功，只是目前這個用戶沒有權限去訪問想進入的頁面，所以通常會看到頁面通知說，請聯繫管理員或客服之類的訊息。