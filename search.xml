<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Nuxt.js II - 開發準備</title>
    <url>/2020/03/22/nuxt-basic-II/</url>
    <content><![CDATA[<p>記錄 Nuxt 專案開發與起步的流程。</p>
<a id="more"></a>
<h2 id="Nuxt-js-的注意事項"><a href="#Nuxt-js-的注意事項" class="headerlink" title="Nuxt.js 的注意事項"></a>Nuxt.js 的注意事項</h2><p>Nuxt =&gt; 基底語法以 node.js 為主，因此 node 不支援的語法，即便是 Vue 的語法也不可行。</p>
<ol>
<li>Nuxt 的 <code>created()</code> =&gt; 不可使用 window、alert、document 等原生屬性。<ul>
<li>node.js 本身是在 server 端環境運行，而非瀏覽器，自然吃不到瀏覽器的屬性</li>
</ul>
</li>
<li>Nuxt =&gt; 基底語法以 node.js 為主，因此 node 不支援的語法，即便是 Vue 的語法也不可行。</li>
<li>需優先考慮 node 的執行環境。</li>
</ol>
<h3 id="路徑"><a href="#路徑" class="headerlink" title="路徑"></a>路徑</h3><p>Nuxt 本身已經封裝了許多 Vue-cli 功能，譬如 router 本身在 Vue 需要設置，但在 Nuxt 只要建立好頁面，router 就會自動匹配。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>同 Vue 相同，Nuxt 也是採用 shorthand：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  formatter () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="install-scss"><a href="#install-scss" class="headerlink" title="install scss"></a>install scss</h2><p>在 Nuxt 環境中，<code>~</code>、<code>@</code>兩者皆通用，都被指向根目錄。但非 nuxt 結構的 js 檔與 nuxt.config.js 則不吃這個規則，必須使用過往的<code>./</code>尋找。</p>
<ul>
<li>install plugin<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; pug</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn add pug pug-plain-loader</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; scss</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn add node-sass sass-loader</span></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>Nuxt.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Nuxt.js I - 架站與手動部署</title>
    <url>/2020/03/21/nuxt-basic-I/</url>
    <content><![CDATA[<p>記錄 Nuxt 前期架站準備工作。</p>
<a id="more"></a>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ol>
<li>node =&gt; 已使用 nvm 管理安裝版本。</li>
<li>git =&gt; homebrew 已安裝。</li>
<li>GitLab 帳號已申請。</li>
</ol>
<h2 id="關於-Nuxt-js"><a href="#關於-Nuxt-js" class="headerlink" title="關於 Nuxt.js"></a>關於 Nuxt.js</h2><ul>
<li>優點<ul>
<li>核心要解決 SPA 網站的 SEO 問題</li>
<li>對於個人開發者來說，如果熟悉 Node.js 可以將前後端整合在同一專案</li>
<li>促使前端可以處理一部分後端功能，例如緩存資料之類的，使 API 負擔減輕</li>
<li>Nuxt.js 可以多做一層轉發關於安全性的資訊，對網站安全較佳</li>
</ul>
</li>
<li>缺點<ul>
<li>沒有 SEO 需求的網站，基本不需要使用 Nuxt.js(例如後台)</li>
<li>學習 Nuxt.js 需要理解部分後端原理知識，學習成本高</li>
<li>開發難度增加，Server 的負擔也會變重</li>
</ul>
</li>
</ul>
<h2 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h2><ul>
<li>GitLab create new project</li>
<li>install(這邊嘗試使用 npx)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx create-nuxt-app project-name</span></pre></td></tr></table></figure></li>
<li>連接上遠端 repository<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init &#x3D;&gt; 通常現在腳手架工具都會處理好，可省略</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 按照 GitLab 步驟執行</span></pre></td></tr><tr><td class="code"><pre><span class="line">1. git remote add origin https:&#x2F;&#x2F;gitlab.com&#x2F;xxx</span></pre></td></tr><tr><td class="code"><pre><span class="line">2. git add.</span></pre></td></tr><tr><td class="code"><pre><span class="line">3. git commit -m &#39;initial commit&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">4. git branch develop</span></pre></td></tr><tr><td class="code"><pre><span class="line">5. git push -u origin develop</span></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Push-Error"><a href="#Push-Error" class="headerlink" title="Push Error"></a>Push Error</h3><p>這邊在 push branch 到 GitLab 時遇到一個問題，狀況如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GitLab: The project you were looking for could not be found.</span></pre></td></tr><tr><td class="code"><pre><span class="line">fatal: Could not read from remote repository.</span></pre></td></tr></table></figure>
<p>遠端的 GitLab 找不到我的 repository 位置，這邊會出現兩種可能，第一是還沒加入 SSH Key，第二是 SSH Key 正確，但需要重新更換遠端的名稱，首先輸入下面的指令，檢查本機公鑰有沒有正常加入 GitLab：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@gitlab.com</span></pre></td></tr></table></figure>
<p>如果出現 <code>Permission Denied (publickey)</code> 那就需要執行生成 SSH Key，並將公鑰加入 GitLab。</p>
<ol>
<li>生成 SSH Key：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;YOUR EMAIL&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">cd ~&#x2F;.ssh&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意生成過程中，會要求設定私人密碼，需要自己記住</span></pre></td></tr></table></figure></li>
<li>進入 ssh 底下，會看到兩個新的檔案：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id_rsa &#x3D;&gt; 私鑰</span></pre></td></tr><tr><td class="code"><pre><span class="line">id_rsa.pub &#x3D;&gt; 公鑰 &#x2F;&#x2F; 使用 vscode 將公鑰的檔案打開，複製裡面的內容</span></pre></td></tr></table></figure></li>
<li>回到 GitLab，操作路徑：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">點選右上角圖像&#x2F;setting&#x2F;左側 SSH Keys</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 將剛剛複製的內容貼到中間的輸入框，並點擊下方的 add key</span></pre></td></tr></table></figure></li>
<li>回到終端機，再次輸入<code>ssh -T git@gitlab.com</code>，這時會要求你輸入剛剛設定的私人密碼，成功後應該會看下面的文字：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome to GitLab, @Your_name!</span></pre></td></tr></table></figure>
到這邊第一步設定 SSH Keys 完成，但我嘗試重新 push 一次依然失敗：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">remote: The project you were looking for could not be found.</span></pre></td></tr><tr><td class="code"><pre><span class="line">fatal: repository &#39;https:&#x2F;&#x2F;gitlab.com&#x2F;Your_name&#x2F;Your_project.git&#x2F;&#39; not found</span></pre></td></tr></table></figure></li>
<li>重新更新並配對一次遠端名稱：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote rename origin old-origin</span></pre></td></tr><tr><td class="code"><pre><span class="line">git remote add origin git@gitlab.com:Your_name&#x2F;Your_project.git</span></pre></td></tr></table></figure>
到此，檔案就能正常推送到遠端了。</li>
</ol>
<h2 id="架站與部署"><a href="#架站與部署" class="headerlink" title="架站與部署"></a>架站與部署</h2><ol>
<li>建立 GCP 帳號</li>
<li>操作路徑：左側 menu/Computer Engine/VM 執行個體/建立</li>
<li>機器類型 =&gt; g1-small(小型專案)</li>
<li>開機磁碟 =&gt; Ubuntu 18.04 LTS</li>
<li>防火牆 =&gt; 允許 HTTP 流量、允許 HTTPS 流量</li>
</ol>
<h2 id="登入-Linux-主機"><a href="#登入-Linux-主機" class="headerlink" title="登入 Linux 主機"></a>登入 Linux 主機</h2><ul>
<li>google gcp 瀏覽器介面登入<br>打開 gcp 專案，專案右側有一個 dropdown 連接 ssh，點擊打開下拉選單，選擇在瀏覽視窗中開啟。</li>
<li>操作指令<br>大多和 mac 的操作相同，記錄比較少用的指令：<br>下載 url 上的檔案<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget (網址路徑)</span></pre></td></tr></table></figure>
刪除資料<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm (檔案名稱)</span></pre></td></tr></table></figure>
刪除資料夾<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -r (資料名稱)</span></pre></td></tr></table></figure>
複製文件到指定路徑<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp 檔案名稱 欲加入的檔案名稱</span></pre></td></tr></table></figure>
複製資料夾<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp -r a b</span></pre></td></tr></table></figure>
建立檔案<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch 檔案名稱</span></pre></td></tr></table></figure>
查看系統記憶體<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free -h</span></pre></td></tr></table></figure>
登出 Linux<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit</span></pre></td></tr></table></figure>
重開機 Linux<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo reboot</span></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="PM2"><a href="#PM2" class="headerlink" title="PM2"></a>PM2</h2><p>一個開源的 Node.js 流程管理器，重開機可以自動重啟 Node，另外也能針對 cpu 進行負載均衡設定。Nuxt 需安裝 nuxt-start 套件來搭配使用 pm2。</p>
<ul>
<li>install pm2<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install pm2 -g</span></pre></td></tr><tr><td class="code"><pre><span class="line">or</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn global add pm2</span></pre></td></tr></table></figure></li>
<li>install nuxt-start<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install nuxt-start</span></pre></td></tr><tr><td class="code"><pre><span class="line">or</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn add nuxt-start</span></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="使用-PM2-架設-Nuxt-站台-本地"><a href="#使用-PM2-架設-Nuxt-站台-本地" class="headerlink" title="使用 PM2 架設 Nuxt 站台(本地)"></a>使用 PM2 架設 Nuxt 站台(本地)</h2><ul>
<li>生產環境</li>
</ul>
<ol>
<li>pm2 init =&gt; 初始化，產生 ecosystem.config.js<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  apps:[&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: &#39;project_name&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    script: &#39;.&#x2F;node_modules&#x2F;nuxt-start&#x2F;bin&#x2F;nuxt-start.js&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    instances: &#39;max&#39;, &#x2F;&#x2F; 負載平衡模式下的 cpu 數量</span></pre></td></tr><tr><td class="code"><pre><span class="line">    exec_mode: &#39;cluster&#39;, &#x2F;&#x2F; 負載平衡模式</span></pre></td></tr><tr><td class="code"><pre><span class="line">    max_memory_restart: &#39;1G&#39;, &#x2F;&#x2F; 緩存了多少記憶體重新整理</span></pre></td></tr><tr><td class="code"><pre><span class="line">    port: 3001 &#x2F;&#x2F; 指定伺服器上的 port </span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li>
<li>yarn run build</li>
<li>pm2 start =&gt; 啟用 ecosystem.config.js 的內容</li>
</ol>
<h2 id="pm2-指令"><a href="#pm2-指令" class="headerlink" title="pm2 指令"></a>pm2 指令</h2><p>啟動 pm2 =&gt; ecosystem.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 start</span></pre></td></tr></table></figure>
<p>查看目前的 server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 list</span></pre></td></tr></table></figure>
<p>停用全部 server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 stop all</span></pre></td></tr></table></figure>
<p>刪除指定 ID 的 server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 delete 4</span></pre></td></tr></table></figure>
<p>刪除全部 server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 delete all</span></pre></td></tr></table></figure>
<p>重新整理所有 server =&gt; 使用情境，git pull 後需重新整理 server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 reload all</span></pre></td></tr></table></figure>
<p>儲存目前的 pm2 server，重開機後會還原</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 save</span></pre></td></tr></table></figure>
<p>檢查 pm2 錯誤(使用 log 排查)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 log</span></pre></td></tr></table></figure>

<ul>
<li>pm2 容易被快取卡住，這時候必須砍掉重新安裝 pm2<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall pm2 -g</span></pre></td></tr><tr><td class="code"><pre><span class="line">~&#x2F;.pm2   &#x3D;&gt; 這個要整個砍掉(不然會被快取)</span></pre></td></tr><tr><td class="code"><pre><span class="line">npm install pm2 -g</span></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="GCP-Linux-主機安裝環境-server"><a href="#GCP-Linux-主機安裝環境-server" class="headerlink" title="GCP Linux 主機安裝環境(server)"></a>GCP Linux 主機安裝環境(server)</h2><ol>
<li>install node.js<ul>
<li>install nvm<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -qO- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;nvm-sh&#x2F;nvm&#x2F;v0.35.3&#x2F;install.sh | bash</span></pre></td></tr></table></figure></li>
<li>安裝後，為了要生效 nvm，需要重新啟動終端機</li>
<li>nvm ls-remote =&gt; nvm install last-version</li>
</ul>
</li>
<li>install pm2<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install pm2 -g</span></pre></td></tr></table></figure>
pm2 目前會安裝在當前的node版本資料夾下，未來如果使用nvm切換node版本，會導致pm2失效。</li>
<li>install git<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo apt install git</span></pre></td></tr></table></figure></li>
<li>install nginx<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo apt install nginx</span></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="git-手動部署-遠端-Linux-操作"><a href="#git-手動部署-遠端-Linux-操作" class="headerlink" title="git 手動部署 + 遠端 Linux 操作"></a>git 手動部署 + 遠端 Linux 操作</h2><ul>
<li>先將 develop 分支進行 commit<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span></pre></td></tr><tr><td class="code"><pre><span class="line">git commit -m &#39;commit content&#39;</span></pre></td></tr></table></figure></li>
<li>切回 master 分支，再將 develop merge<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span></pre></td></tr><tr><td class="code"><pre><span class="line">git merge develop</span></pre></td></tr></table></figure></li>
<li>master 推送到 Gitlab<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span></pre></td></tr></table></figure></li>
<li>回到 gcp</li>
</ul>
<ol>
<li>瀏覽器打開 Linux 介面</li>
<li>git clone 專案(注意 gitlab 是否已先切回 master 分支)<ul>
<li>日後遠端 gitlab 專案若有更新(git pull 進行同步) =&gt; pm2 reload id</li>
</ul>
</li>
<li>cd 專案</li>
<li>npm install</li>
<li>npm run build</li>
<li>啟用 pm2 站台</li>
</ol>
<h2 id="網域設定-DNS"><a href="#網域設定-DNS" class="headerlink" title="網域設定 DNS"></a>網域設定 DNS</h2><ul>
<li>設定 A 記錄</li>
</ul>
<ol>
<li>前往任何網址商購買網址 =&gt; 這邊使用 godady</li>
<li>購買完成後，打開右上角的 My Products =&gt; 進入自己購買的網址</li>
<li>選擇要綁定的 Domain，點擊右方的 DNS 進入</li>
<li>選擇第一列的 A 記錄，右邊可以進行編輯</li>
<li>複製 gcp 專案的外部 IP，貼到指向欄位(Points to)</li>
<li>將 gcp 外部 IP 轉為靜態 =&gt; 左側選單/VPC網路/外部IP位址/調整類型</li>
</ol>
<h2 id="Nginx-反向代理設定"><a href="#Nginx-反向代理設定" class="headerlink" title="Nginx 反向代理設定"></a>Nginx 反向代理設定</h2><ul>
<li>nginx =&gt; 一種網頁伺服器，就是架設網頁的軟體，其他還有 IIS、Apache</li>
</ul>
<p>一般而言，node.js 為求提高效能，多會採用 nginx 來架站。</p>
<ol>
<li>node 使用 pm2 建立後，port 的設定不可低於1024，避免安全性問題。</li>
<li>架設 nginx server(nginx 監聽 80 port)</li>
<li>nginx 透過反向代理機制，將來源網址代理到 node 站台</li>
</ol>
<ul>
<li>nginx 指令</li>
</ul>
<ol>
<li>啟動 nginx server<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nginx</span></pre></td></tr></table></figure></li>
<li>重新整理 nginx server<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nginx -s reload</span></pre></td></tr></table></figure></li>
<li>快速停用 server<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nginx -s stop</span></pre></td></tr></table></figure></li>
<li>nginx 位置：/etc/nginx =&gt; 預設</li>
<li>檢查 nginx log<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx log</span></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="nginx-config-設定"><a href="#nginx-config-設定" class="headerlink" title="nginx config 設定"></a>nginx config 設定</h2><ul>
<li>第一個入口點 =&gt; nginx.conf</li>
<li>vi 編輯器 =&gt; 常見的是 vim，這邊使用 nano</li>
</ul>
<ol>
<li>sudo nano /etc/nginx/conf.d/pittwu.fun.conf</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  server_name pittwu.fun www.pittwu.fun;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  location &#x2F; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    proxy_pass http:&#x2F;&#x2F;localhost:3001;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="SSL-憑證"><a href="#SSL-憑證" class="headerlink" title="SSL 憑證"></a>SSL 憑證</h2><p>SSL For Free =&gt; 取得免費憑證(憑證機構：Let’s Encypt)，缺點每三個月會過期，為此 Linux 可以透過 certbot 來自動更新憑證。</p>
<ul>
<li>install certbot</li>
</ul>
<ol>
<li>指令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. sudo apt-get update</span></pre></td></tr><tr><td class="code"><pre><span class="line">2. sudo apt-get install software-properties-common &#x2F;&#x2F; 載入 certbot 的 ppa</span></pre></td></tr><tr><td class="code"><pre><span class="line">3. sudo add-apt-repository ppa:certbot&#x2F;certbot</span></pre></td></tr><tr><td class="code"><pre><span class="line">4. sudo apt-get update</span></pre></td></tr><tr><td class="code"><pre><span class="line">5. sudo apt-get install python-certbot-nginx # install python&#39;s certbot for nginx</span></pre></td></tr></table></figure></li>
<li>產生憑證：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo certbot --nginx</span></pre></td></tr></table></figure></li>
<li>重新整理 nginx：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nginx -s reload</span></pre></td></tr></table></figure></li>
<li>檢查憑證續約狀況<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo certbot renew --dry-run</span></pre></td></tr></table></figure></li>
<li>執行憑證續約動作<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo certbot renew</span></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>Nuxt.js</tag>
      </tags>
  </entry>
  <entry>
    <title>關於 SEO 簡述</title>
    <url>/2020/03/18/vue-seo/</url>
    <content><![CDATA[<p>關於 SEO 方面的一些簡述。</p>
<a id="more"></a>
<h2 id="過往的觀點"><a href="#過往的觀點" class="headerlink" title="過往的觀點"></a>過往的觀點</h2><p>雖然以往刻板認知，搜尋引擎無法爬到現代 SPA 網頁的內容，但其實現代瀏覽器已經有能力抓到 JS Render 出來的內容，但還是以靜態為主，ajax 呼叫的內容依然無法。其中又以 Chrome 能更近一步抓到 Render 出來的連結。</p>
<h2 id="作者的觀點"><a href="#作者的觀點" class="headerlink" title="作者的觀點"></a>作者的觀點</h2><p>尤大大在面對SEO這個問題時，有提出自己的論點，SPA依然側重於實現後台類系統頁面，諸如會員、帳務相關，這些後台頁面，本質上就完全不仰賴SEO，畢竟他們是 for 內部人員使用。</p>
<p>至於 landing page，此類較無動態資料的網頁，他建議直接寫成靜態頁面，或是將 Vue 專案透過 Prerender 進行轉換。而高度交互或是大量動態資料的網站，則改使用 SSR(Server Side Rendering)。</p>
<h2 id="如何處理-SEO"><a href="#如何處理-SEO" class="headerlink" title="如何處理 SEO"></a>如何處理 SEO</h2><p>比較早期的做法是使用 Prerender 的插件，但我個人的主觀觀點是，中大型網站隨著 Nuxt 框架越發成熟，大多改用 Nuxt，而小型網站坦白說依賴網站SEO效益，不如經營社群媒體成效更佳。</p>
<p>另外，這幾年，有另一種針對這種靜態網站的解決方案也被提出來：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">React &#x3D;&gt; Gatsby</span></pre></td></tr><tr><td class="code"><pre><span class="line">Vue &#x3D;&gt; Gridsome</span></pre></td></tr></table></figure>
<p>這一類的靜態網站解決方案，除了以其封裝的框架為基底，同時也對SEO友好，更支援PWA。部署方面則和近年很夯的 Netlify 相結合，同時將後端服務分散各類雲端sass，形成自有的生態圈，或許會是未來的一個技術方向。</p>
]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title>前端自動化測試基礎知識</title>
    <url>/2020/03/18/test-basic/</url>
    <content><![CDATA[<p>之前工作的團隊是完全不碰這塊的，所以本身沒有摸過，但考慮到目前整體趨勢上，不少公司的前端正在導入測試，還是記錄一些筆記，方便未來能夠上手。</p>
<a id="more"></a>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>e.g.<br>許多舊專案的維護，改動不易，且重構成本高昂，且在重構的過程中，可能面臨需求改動，或是重構過中忽略一些歷史因素，導致功能不足前功盡棄。為了降低重構成本，在重構前預先準備測試，這樣在階段性重構的過程，這些測試皆會被調用，若測試沒過，代表重構的程式碼存在問題，第一時間先進行修復，避免出現重構完才發現重構程式存在瑕疵。</p>
<h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><p>結構</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- index.html</span></pre></td></tr><tr><td class="code"><pre><span class="line">- math.js</span></pre></td></tr><tr><td class="code"><pre><span class="line">- math.test.js</span></pre></td></tr></table></figure>
<p>我將 math.js 寫好兩個計算函數並引入 index.html，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add (a, b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return a + b</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">function minus (a, b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; 這邊我故意寫錯，將減法寫成除法</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return a &#x2F; b</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>同時準備測試代碼在 <code>math.test.js</code>，當然這邊的結構是無法直接執行測試，所以我們將測試程式丟到瀏覽器上的<code>console</code>測試時，在 run 的過程中因為函數本身有錯誤，這時就會進入 throw，提醒我哪邊發生錯誤了，可以回頭去檢視。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 預先將結果寫出來</span></pre></td></tr><tr><td class="code"><pre><span class="line">var result &#x3D; add(2, 4)</span></pre></td></tr><tr><td class="code"><pre><span class="line">var expected &#x3D; 6</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">if (result !&#x3D;&#x3D; 6) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; throw 拋出例外狀況</span></pre></td></tr><tr><td class="code"><pre><span class="line">  throw Error(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#96;2 + 6 應該等於 $&#123;expected&#125;，但結果卻是 $&#123;result&#125;，請檢查add()&#96;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">var result &#x3D; minus(10, 5)</span></pre></td></tr><tr><td class="code"><pre><span class="line">var expected &#x3D; 5</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">if (result !&#x3D;&#x3D; 5) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  throw Error(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#96;10 - 5 應該等於 $&#123;expected&#125;，但結果卻是 $&#123;result&#125;，請檢查minus()&#96;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>如此一來，未來如果進行擴充新函數時，而我不小心手殘改到舊的函數時，在 run 測試的時候，我也可以獲得提醒，避免發生不必要的 bug。</p>
<h3 id="封裝"><a href="#封裝" class="headerlink" title="封裝"></a>封裝</h3><p>除了上述寫法，也可以將測試的函數合併在一起。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function expect (result) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(result)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    toBe: function(actual) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      console.log(actual)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      if (result !&#x3D;&#x3D; actual) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw new Error(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#96;程式碼執行結果和預期結果不同，預期是$&#123;actual&#125;，結果卻是$&#123;result&#125;&#96;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        )</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 測試描述，方便測試後，更好理解哪一部分出現錯誤</span></pre></td></tr><tr><td class="code"><pre><span class="line">function testDescription(desc, params) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  try &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    params()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(&#96;$&#123;desc&#125; 已通過測試&#96;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  catch(err) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(&#96;$&#123;desc&#125; 未通過測試 $&#123;err&#125;&#96;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">testDescription(&#39;測試加法函數&#39;, () &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  expect(add(2, 4)).toBe(6)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">testDescription(&#39;測試減法函數&#39;, () &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  expect(minus(10, 5)).toBe(5)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<p>假設我故意將<code>minus()</code>寫成+法，那拿到的 result(函數計算的結果)和 actual(預期的結果)將不會相等，則會拋出 throw。</p>
<h2 id="Jest"><a href="#Jest" class="headerlink" title="Jest"></a>Jest</h2><ul>
<li>速度快<ul>
<li>a、b兩者互不關聯的函數，若僅改a，但b未改動，則b不做測試，節省測試時間。</li>
</ul>
</li>
<li>多項目並行<ul>
<li>若前後台專案，使用不同框架或是一方使用Vue，另一方使用Node，依然可以並行測試。</li>
</ul>
</li>
</ul>
<h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd project</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn init</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 測試僅需要運行在開發環境</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn add jest --dev</span></pre></td></tr></table></figure>
<h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p>在<code>Jest</code>中，已經提供了<code>test()</code>和<code>expect()</code>，直接使用即可。</p>
<ul>
<li>導出，在<code>math.js</code>中使用<code>module.exports</code>將函數導出。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add (a, b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return a + b</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">function minus (a, b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return a - b</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  add,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  minus</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li>
<li>引入，在<code>math.test.js</code>中將導出的函數引入測試。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const math &#x3D; require(&#39;.&#x2F;math.js&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">const &#123; add, minus &#125; &#x3D; math</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">test(&#39;測試加法函數&#39;, () &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  expect(add(2, 4)).toBe(6)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">test(&#39;測試減法函數&#39;, () &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  expect(minus(10, 5)).toBe(5)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure></li>
<li><code>package.json</code>腳本加入運行<code>Jest</code>指令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 這個指令執行後，會去尋找目錄下，以 test.js 結尾的文件，並加以運行</span></pre></td></tr><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &quot;test&quot;: &quot;jest&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
接著在終端機運行<code>yarn run test</code>，就可以看到測試的過程。<br><code>Jest</code>的主要功能在於單元測試與集成測試，但這兩者本質上就是單一模組測試和多模組測試。所以為了配合<code>Jest</code>，必須將既有的函數透過<code>module.exports</code>的方式轉為模組化後，才能讓<code>Jest</code>調用測試。</li>
<li>測試環境和瀏覽器環境<br>一般來說，在沒有<code>cli</code>之類的工具下，瀏覽器無法自動編譯<code>module</code>，但對測試環境來說需要<code>module</code>，所以需要透過<code>try catch</code>包裹，避免出現紅字錯誤。不過實務上，我們目前開發大多已在腳手架工具內，自動會協助處理編譯，所以其實是不需要<code>try catch</code>包裹。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(&#39;test&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  module.exports &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    add,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    minus</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">catch (err) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="設定"><a href="#設定" class="headerlink" title="設定"></a>設定</h3><ul>
<li>指令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn jest --init</span></pre></td></tr></table></figure>
這道指令的目的，在於啟用<code>node_modules</code>下的<code>Jest</code>進行初始化。執行指令後，接下來會詢問測試環境是<code>Node</code>還是瀏覽器，是否生成覆蓋率報告，測試結束後是否自動清除模擬。這邊選瀏覽器環境，其他則都選y，最後目錄下會生成<code>jest.config.js</code>的檔案。</li>
<li>jest.config.js<br>在設定檔中，可以看到下面這一行，意思是生成覆蓋率報告時，會自動存放於<code>coverage</code>的資料夾內。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">coverageDirectory: &quot;coverage&quot;</span></pre></td></tr></table></figure>
同時因為剛剛選擇的是瀏覽器環境，所以預設會註釋<code>browser</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; browser: false</span></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>自動化測試</tag>
        <tag>Jest</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 基礎知識補充</title>
    <url>/2020/03/15/js-basic/</url>
    <content><![CDATA[<p>補強 JS 基礎知識，方便自己隨時複習。</p>
<a id="more"></a>
<h2 id="JS-變數類型"><a href="#JS-變數類型" class="headerlink" title="JS 變數類型"></a>JS 變數類型</h2><h3 id="value-type"><a href="#value-type" class="headerlink" title="value type"></a>value type</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 單純的賦值</span></pre></td></tr><tr><td class="code"><pre><span class="line">let a &#x3D; 10</span></pre></td></tr><tr><td class="code"><pre><span class="line">let b &#x3D; 20</span></pre></td></tr><tr><td class="code"><pre><span class="line">a &#x3D; 30</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(b) &#x3D;&gt; ? &#x2F;&#x2F; 20</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#39;test&#39; &#x2F;&#x2F; string</span></pre></td></tr><tr><td class="code"><pre><span class="line">let b &#x3D; 100 &#x2F;&#x2F; number</span></pre></td></tr><tr><td class="code"><pre><span class="line">let c &#x3D; true &#x2F;&#x2F; boolean</span></pre></td></tr><tr><td class="code"><pre><span class="line">let d &#x3D; Symbol(&#39;d&#39;) &#x2F;&#x2F; ES6 新增</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 另外還有 null、undefined、BigInt</span></pre></td></tr></table></figure>
<h3 id="reference-type"><a href="#reference-type" class="headerlink" title="reference type"></a>reference type</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#123; num: 10 &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">let b &#x3D; a</span></pre></td></tr><tr><td class="code"><pre><span class="line">b.num &#x3D; 15</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(a.age) &#x3D;&gt; ? &#x2F;&#x2F; 15</span></pre></td></tr></table></figure>
<p>不同於前者存放於 Stack(棧)，後者存放於 Heap(堆)，存放於堆的變數，看似賦值，但其實是存在電腦中一個位址，即便賦值兩個變數，但其實都是指向同一個位址，也因此就會造成覆蓋。</p>
<h4 id="pass-by-sharing"><a href="#pass-by-sharing" class="headerlink" title="pass by sharing"></a>pass by sharing</h4><p>JS 的屬性，當有<code>function</code>時，賦值不影響外部變數，但更新可以改變變數。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 賦值無法影響</span></pre></td></tr><tr><td class="code"><pre><span class="line">let a &#x3D; &#123; num: 10 &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">function changeVal(obj) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  obj &#x3D; &#123; num: 50 &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">changeVal(a)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(a) &#x3D;&gt; ? &#x2F;&#x2F; &#123; num: 10 &#125;</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 更新會改變</span></pre></td></tr><tr><td class="code"><pre><span class="line">let a &#x3D; &#123; num: 10 &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">function changeVal(obj) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  obj.num &#x3D; 50</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">changeVal(a)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(a) &#x3D;&gt; ? &#x2F;&#x2F; &#123; num: 50 &#125;</span></pre></td></tr></table></figure>
<ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10191057" target="_blank" rel="noopener">重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？</a></li>
<li><a href="https://pjchender.blogspot.com/2016/03/javascriptby-referenceby-value.html" target="_blank" rel="noopener">[筆記] 談談 JavaScript 中 by reference 和 by value 的重要觀念</a></li>
</ul>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>檢查 value</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#39;test&#39;      typeof(a)   &#x2F;&#x2F; string</span></pre></td></tr><tr><td class="code"><pre><span class="line">let b &#x3D; 100         typeof(b)   &#x2F;&#x2F; number</span></pre></td></tr><tr><td class="code"><pre><span class="line">let c &#x3D; true        typeof(c)   &#x2F;&#x2F; boolean</span></pre></td></tr><tr><td class="code"><pre><span class="line">let d &#x3D; Symbol(&#39;d&#39;) typeof(d)   &#x2F;&#x2F; Symbol</span></pre></td></tr><tr><td class="code"><pre><span class="line">let e               typeof(e)   &#x2F;&#x2F; undefined</span></pre></td></tr></table></figure>
<p>檢查 function</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof console.log   &#x2F;&#x2F; &#39;function&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">typeof function()&#123;&#125;  &#x2F;&#x2F; &#39;function&#39;</span></pre></td></tr></table></figure>
<p>陣列、物件、null 都會被判斷為 object</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof null        &#x2F;&#x2F; object</span></pre></td></tr><tr><td class="code"><pre><span class="line">typeof [1, 2]      &#x2F;&#x2F; object</span></pre></td></tr><tr><td class="code"><pre><span class="line">typeof &#123; num: 2 &#125;  &#x2F;&#x2F; object</span></pre></td></tr></table></figure>
<!-- ### Deep Clone (深拷貝) -->
<h3 id="變數計算"><a href="#變數計算" class="headerlink" title="變數計算"></a>變數計算</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; 10 + 2      &#x2F;&#x2F; 12</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果其中有 string 會變成組合 string</span></pre></td></tr><tr><td class="code"><pre><span class="line">let b &#x3D; 10 + &#39;1&#39;    &#x2F;&#x2F; &#39;101&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">let c &#x3D; false + &#39;2&#39; &#x2F;&#x2F; &#39;false2&#39;</span></pre></td></tr></table></figure>
<h3 id="判斷檢查"><a href="#判斷檢查" class="headerlink" title="判斷檢查"></a>判斷檢查</h3><p><code>==</code>在運算上，會盡可能讓兩側相等，容易出現許多錯誤。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 &#x3D;&#x3D; &#39;10&#39;         &#x2F;&#x2F; true</span></pre></td></tr><tr><td class="code"><pre><span class="line">0 &#x3D;&#x3D; &#39;&#39;            &#x2F;&#x2F; true</span></pre></td></tr><tr><td class="code"><pre><span class="line">0 &#x3D;&#x3D; false         &#x2F;&#x2F; true</span></pre></td></tr><tr><td class="code"><pre><span class="line">false &#x3D;&#x3D; &#39;&#39;        &#x2F;&#x2F; true</span></pre></td></tr><tr><td class="code"><pre><span class="line">null &#x3D;&#x3D; undefined  &#x2F;&#x2F; true</span></pre></td></tr></table></figure>
<p>目前基本都是一律使用<code>===</code>做判斷，不會使用<code>==</code>，但如果為了判斷<code>null</code>，可以使用，但我個人是不使用<code>==</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (a &#x3D;&#x3D; null) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 等同於</span></pre></td></tr><tr><td class="code"><pre><span class="line">if (a &#x3D;&#x3D;&#x3D; null || a &#x3D;&#x3D;&#x3D; undefined) &#123;&#125;</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Interview</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js + Firebase 實作即時聊天室</title>
    <url>/2020/02/26/vue-firebase-chat/</url>
    <content><![CDATA[<p>使用<code>Vue.js</code>構建前端聊天室頁面，再介接<code>Firebase</code>作為儲存聊天訊息的資料庫。記錄自己的實作流程。</p>
<a id="more"></a>
<h2 id="介接-OpenWeather-API"><a href="#介接-OpenWeather-API" class="headerlink" title="介接 OpenWeather API"></a>介接 OpenWeather API</h2><p>由於首頁過於單調，所以接一隻天氣API來豐富一下頁面。<br><a href="https://home.openweathermap.org/" target="_blank" rel="noopener">OpenWeather 官網</a><br>登入後，點選<code>API keys</code>，右側輸入<code>name</code>=&gt;生成金鑰</p>
]]></content>
      <tags>
        <tag>Firebase</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js(建立後端API接口)</title>
    <url>/2020/02/22/node-interface/</url>
    <content><![CDATA[<p>嘗試理解 <code>Node.js</code> 如何建立後端API接口，簡略記下自己的建立流程。</p>
<a id="more"></a>
<h2 id="Install-plugin"><a href="#Install-plugin" class="headerlink" title="Install plugin"></a>Install plugin</h2><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>建立如註冊類的API時，需使用 <code>POST</code>，這邊安裝一個插件來應用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add body-parser</span></pre></td></tr></table></figure>
<h3 id="密碼加密"><a href="#密碼加密" class="headerlink" title="密碼加密"></a>密碼加密</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add bcrypt</span></pre></td></tr></table></figure>
<h3 id="avatar-大頭貼"><a href="#avatar-大頭貼" class="headerlink" title="avatar 大頭貼"></a>avatar 大頭貼</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add gravatar</span></pre></td></tr></table></figure>
<h3 id="jwt-token"><a href="#jwt-token" class="headerlink" title="jwt token"></a>jwt token</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add jsonwebtoken</span></pre></td></tr></table></figure>
<h3 id="驗證"><a href="#驗證" class="headerlink" title="驗證"></a>驗證</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add passport passport-jwt</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 指令記錄</title>
    <url>/2020/02/21/git-command/</url>
    <content><![CDATA[<p>前工作的前端團隊都使用 SourceTree 進行版控，相對較少使用指令操作 git，為了方便日後終端機操作，記錄一下指令功能。</p>
<a id="more"></a>
<ul>
<li>初始化git專案<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span></pre></td></tr></table></figure></li>
<li>將檔案加入版本控制<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span></pre></td></tr></table></figure></li>
<li>建立 develop 分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch develop</span></pre></td></tr></table></figure></li>
<li>切換分支到 develop<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout develop</span></pre></td></tr></table></figure></li>
<li>推送分支到遠端<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin develop</span></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Quasar(Vue.js UI Framework)</title>
    <url>/2020/02/18/quasar/</url>
    <content><![CDATA[<p>Quasar Framework 是支援 Vue.js 的 UI 框架，作者設計出發的概念還蠻宏偉的，兼容全平台，實用性與否還有待評估，這邊先按照作者的教學實作看看。</p>
<a id="more"></a>
<h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p><a href="https://quasar.dev/" target="_blank" rel="noopener">官網連結</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn global add @quasar&#x2F;cli</span></pre></td></tr><tr><td class="code"><pre><span class="line"># or</span></pre></td></tr><tr><td class="code"><pre><span class="line">npm install -g @quasar&#x2F;cli</span></pre></td></tr></table></figure>
<h3 id="Quasar-Cli"><a href="#Quasar-Cli" class="headerlink" title="Quasar Cli"></a>Quasar Cli</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">quasar create project-name</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">cd project</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">quasar dev</span></pre></td></tr></table></figure>
<h2 id="Install-Pug"><a href="#Install-Pug" class="headerlink" title="Install Pug"></a>Install Pug</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add --dev pug pug-plain-loader</span></pre></td></tr></table></figure>
<h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; quasar.conf.js</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">build: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  extendWebpack (cfg) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cfg.module.rules.push(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      test: &#x2F;\.pug$&#x2F;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      loader: &#39;pug-plain-loader&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="Install-Firebase"><a href="#Install-Firebase" class="headerlink" title="Install Firebase"></a>Install Firebase</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add firebase</span></pre></td></tr></table></figure>
<p><code>quasar</code> 導入 <code>firebase</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">quasar new boot firebase</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 新生成檔案在 src&#x2F;boot&#x2F;firebase.js</span></pre></td></tr></table></figure>
<p>設定 <code>quasar.config.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  boot: [</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#39;firebase&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="firebase-js"><a href="#firebase-js" class="headerlink" title="firebase.js"></a>firebase.js</h3><p>設定內容寫法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Firebase App (the core Firebase SDK) is always required and must be listed first</span></pre></td></tr><tr><td class="code"><pre><span class="line">import * as firebase from &#39;firebase&#x2F;app&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; If you enabled Analytics in your project, add the Firebase SDK for Analytics</span></pre></td></tr><tr><td class="code"><pre><span class="line">import &#39;firebase&#x2F;analytics&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Add the Firebase products that you want to use</span></pre></td></tr><tr><td class="code"><pre><span class="line">import &#39;firebase&#x2F;auth&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import &#39;firebase&#x2F;database&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 下方貼上 SDK 一大串 script</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化需做調整 Initialize Firebase</span></pre></td></tr><tr><td class="code"><pre><span class="line">const firebaseApp &#x3D; firebase.initializeApp(firebaseConfig)</span></pre></td></tr><tr><td class="code"><pre><span class="line">const firebaseAuth &#x3D; firebaseApp.auth()</span></pre></td></tr><tr><td class="code"><pre><span class="line">const firebaseDB &#x3D; firebaseApp.database()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">export &#123; firebaseAuth, firebaseDB &#125;</span></pre></td></tr></table></figure>
<p>回到 <code>Vuex</code> 載入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; firebaseAuth, firebaseDB &#125; from &#39;boot&#x2F;firebase&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(1, firebaseAuth)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(2, firebaseDB)</span></pre></td></tr></table></figure>
<h2 id="quasar-conf-js"><a href="#quasar-conf-js" class="headerlink" title="quasar.conf.js"></a>quasar.conf.js</h2><p>設定 router =&gt; History Mode</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vueRouterMode: &#39;history&#39;</span></pre></td></tr></table></figure>
<h2 id="Error-Fixed"><a href="#Error-Fixed" class="headerlink" title="Error Fixed"></a>Error Fixed</h2><p>資料無法正常送出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">q-btn 若僅加上 type&#x3D;&quot;submit&quot; 無法正常送出 q-form 內的資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">需在 q-btn 本身再補上一個 @click 事件，才能執行 methods</span></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Quasar</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Express 框架運用與理解</title>
    <url>/2020/02/16/node-Express/</url>
    <content><![CDATA[<p>Express 算是比較老牌的輕量級 Node.js Web 框架，透過學習使用 Express 來加深自己對 Node 的理解，同時提高對後端的認知。</p>
<a id="more"></a>
<h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始專案</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn init</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn add express</span></pre></td></tr></table></figure>
<h2 id="Open-Web-Server"><a href="#Open-Web-Server" class="headerlink" title="Open Web Server"></a>Open Web Server</h2><p>載入並調用 <code>Express</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">const app &#x3D; express()</span></pre></td></tr></table></figure>
<p>使用 <code>get()</code> 方法，來檢查資料有無傳送到對應頁面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.send(&#39;Hello Express!&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; watch port</span></pre></td></tr><tr><td class="code"><pre><span class="line">let port &#x3D; 3000</span></pre></td></tr><tr><td class="code"><pre><span class="line">app.listen(port)</span></pre></td></tr></table></figure>
<h3 id="監聽端口的正式站環境寫法"><a href="#監聽端口的正式站環境寫法" class="headerlink" title="監聽端口的正式站環境寫法"></a>監聽端口的正式站環境寫法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; process.env &#x3D;&gt; 意指環境變數，當完成部署後，端口由 server 提供</span></pre></td></tr><tr><td class="code"><pre><span class="line">const port &#x3D; process.env.PORT || 3000</span></pre></td></tr><tr><td class="code"><pre><span class="line">app.listen(port)</span></pre></td></tr></table></figure>
<h2 id="params-amp-query"><a href="#params-amp-query" class="headerlink" title="params &amp; query"></a>params &amp; query</h2><p>這兩者概略來說，就是向後端發出請求時所帶的參數，差別在於，url 上所呈現格式不同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 按照之前的開發合作的經驗</span></pre></td></tr><tr><td class="code"><pre><span class="line">params &#x3D;&gt; 通常為必填值</span></pre></td></tr><tr><td class="code"><pre><span class="line">query &#x3D;&gt; 選填值</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">app.get(&#39;&#x2F;user&#x2F;:name&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let userName &#x3D; req.params.name</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let limit &#x3D; req.query.limit</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.send(&#39;&lt;html&gt;&lt;head&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;&#39;+userName+&#39;&lt;&#x2F;h1&gt;&lt;h2&gt;&#39;+limit+&#39;&lt;&#x2F;h2&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h2 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h2><p>意指中介層，等於替資料庫做一層防護，當用戶發出請求進入對應頁面，檢查對方是否符合請求邏輯，譬如登入頁可能會檢查一些帳號資訊等等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 調用 use() 方法做檢查</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">app.use((req, res, next) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(&#39;login&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  next()  &#x2F;&#x2F; next() 方法是為了當邏輯驗證正確後，能繼續執行下一步驟</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h3 id="驗證檢查"><a href="#驗證檢查" class="headerlink" title="驗證檢查"></a>驗證檢查</h3><p>為了避免用戶刻意透過 router 進入頁面，前後端都會進行驗證檢查。此外不存在的資料或是 server 掛了，為了用戶體驗也必須給予對應的狀態提示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 當用戶隨意亂打參數，使用 use() 方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使其進入我們希望他進入的頁面提示，避免直接回傳 cannot get 訊息</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">app.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.send(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#39;&lt;html&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;head&gt;&lt;&#x2F;head&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;body&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;h1&gt;123&lt;&#x2F;h1&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;&#x2F;body&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;html&gt;&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">app.use((req, res, next) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.status(404).send(&#39;404 is not found&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<p><code>use()</code> 方法，除了提示找不到頁面，若是程式碼本身有錯，也可以提醒，通常狀態碼為 500。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 這邊使用了一個未定義的函數，除了出現 not defined 的 error</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 也會回傳 500 的狀態碼</span></pre></td></tr><tr><td class="code"><pre><span class="line">app.use((req, res, next) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  test()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  next()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">app.use((err, req, res, next) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.status(500).send(&#39;sorry try again&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h3 id="增加靜態檔案路徑"><a href="#增加靜態檔案路徑" class="headerlink" title="增加靜態檔案路徑"></a>增加靜態檔案路徑</h3><p>使用 express 提供的原生方法 <code>static()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 建立名為 public 的資料夾作為靜態檔案存放</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 順序上必須放在最前面，方便後面的 router 能正常引用</span></pre></td></tr><tr><td class="code"><pre><span class="line">app.use(express.static(&#39;public&#39;))</span></pre></td></tr></table></figure>
<h2 id="Template-EJS"><a href="#Template-EJS" class="headerlink" title="Template - EJS"></a>Template - EJS</h2><h3 id="Install-1"><a href="#Install-1" class="headerlink" title="Install"></a>Install</h3>]]></content>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 生命週期簡單理解</title>
    <url>/2020/02/13/vue-life-cycle/</url>
    <content><![CDATA[<p>整理 Vue 的生命週期和用法理解。</p>
<a id="more"></a>
<h2 id="數據變化與更新"><a href="#數據變化與更新" class="headerlink" title="數據變化與更新"></a>數據變化與更新</h2><h3 id="beforeUpdate-amp-updated"><a href="#beforeUpdate-amp-updated" class="headerlink" title="beforeUpdate &amp; updated"></a>beforeUpdate &amp; updated</h3><p>透過 @click 事件來達到數據更新的功能。<br>一開始頁面渲染 data 的初始資料，當點擊時觸發函數執行資料更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; template</span></pre></td></tr><tr><td class="code"><pre><span class="line">p &#123;&#123; msg &#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">button(@click&#x3D;&quot;update()&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; data 存放資料的初始值</span></pre></td></tr><tr><td class="code"><pre><span class="line">data () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    msg: &#39;Hello Vue!&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; methods 存放執行的函數，透過點擊執行函數來更新資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">methods: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  update () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    this.msg &#x3D; &#39;Hello Pitt!&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="銷毀"><a href="#銷毀" class="headerlink" title="銷毀"></a>銷毀</h2><h3 id="beforeDestroy-amp-destroyed"><a href="#beforeDestroy-amp-destroyed" class="headerlink" title="beforeDestroy &amp; destroyed"></a>beforeDestroy &amp; destroyed</h3><p>理解銷毀的概念，可以透過 v-if 來理解。當判斷為 false 時，本質上就等於銷毀該 Dom 節點。若預設 data 為 true，一開始頁面渲染時會出現，此時不會觸發 beforeDestroy &amp; destroyed。但當點擊動作觸發轉為 false 時，則會觸發 beforeDestroy &amp; destroyed，這時頁面上被綁定的對象也會消失，即可是為銷毀。</p>
<h2 id="掛載順序"><a href="#掛載順序" class="headerlink" title="掛載順序"></a>掛載順序</h2><p>在 Vue.js 的生命週期中，當頁面渲染時，透過 console.log，可以看到依序為：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. beforeCreate &#x2F;&#x2F; 在這個階段 $el 和 $data 都尚未掛載 &#x3D;&gt; undefined</span></pre></td></tr><tr><td class="code"><pre><span class="line">2. created &#x2F;&#x2F; $data 初始資料已載入，$el 尚未 &#x3D;&gt; undefined</span></pre></td></tr><tr><td class="code"><pre><span class="line">3. beforeMount &#x2F;&#x2F; $el 依然為空 &#x3D;&gt; undefined</span></pre></td></tr><tr><td class="code"><pre><span class="line">4. mounted &#x2F;&#x2F; $el 完成渲染出現資料</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Firebase 操作記錄筆記</title>
    <url>/2020/02/12/firebase-note/</url>
    <content><![CDATA[<p>記錄自己操作 Firebase 的流程，以及問題解法。</p>
<a id="more"></a>
<h2 id="新版-SDK-異動"><a href="#新版-SDK-異動" class="headerlink" title="新版 SDK 異動"></a>新版 SDK 異動</h2><p>除了引入的 firebase-app.js 是主要核心，其他功能則被拆分到各子項目。<br>若要調用 <code>firebase.database()</code> 需再引入以下 script：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;www.gstatic.com&#x2F;firebasejs&#x2F;7.8.2&#x2F;firebase-database.js&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;script&gt;</span></pre></td></tr></table></figure>
<h3 id="檢查是否載入-Firebase-成功"><a href="#檢查是否載入-Firebase-成功" class="headerlink" title="檢查是否載入 Firebase 成功"></a>檢查是否載入 Firebase 成功</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const database &#x3D; firebase.database()</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(database)</span></pre></td></tr></table></figure>
<h2 id="操作資料庫"><a href="#操作資料庫" class="headerlink" title="操作資料庫"></a>操作資料庫</h2><p><code>ref()</code> =&gt; 尋找資料庫路徑<br><code>set()</code> =&gt; 新增資料</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 目前練習使用 Realtime Database</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 若沒有目錄的狀況，預設會寫入到根目錄</span></pre></td></tr><tr><td class="code"><pre><span class="line">firebase.database().ref().set(&#39;Hello Firebase!&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 除了字串，也可以寫入物件</span></pre></td></tr><tr><td class="code"><pre><span class="line">firebase.database().ref().set(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  name: &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h3 id="修改資料"><a href="#修改資料" class="headerlink" title="修改資料"></a>修改資料</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 原始資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">firebase.database().ref(&#39;firstArray&#39;).set([</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: &#39;Pitt&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hasMac: true</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: &#39;NiNi&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hasMac: true</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">])</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 尋找對應路徑後修改資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">firebase.database().ref(&#39;firstArray&#x2F;0&#x2F;hasMac&#39;).set(false)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 陣列中的第一組變數 hasMac 即會修改為 false</span></pre></td></tr></table></figure>
<h3 id="顯示資料至頁面"><a href="#顯示資料至頁面" class="headerlink" title="顯示資料至頁面"></a>顯示資料至頁面</h3><p><code>once()</code> =&gt; 讀取一次資料庫的資料<br>snapshot =&gt; 意指快照，其中 <code>snapshot.val()</code> 是 Firebase 的讀取語法，snapshot 本身是變數命名，可用其他名稱取代。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firebase.database().ref(&#39;userName&#39;).set(&#39;PittWu&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">let userName &#x3D; firebase.database().ref(&#39;userName&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">userName.once(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let item &#x3D; snapshot.val()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(item)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  document.getElementById(&#39;title&#39;).textContent &#x3D; item</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h3 id="隨時監聽資料"><a href="#隨時監聽資料" class="headerlink" title="隨時監聽資料"></a>隨時監聽資料</h3><p><code>on()</code> =&gt; 監聽</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用 on 語法時，當資料變更時，頁面也隨之渲染變化</span></pre></td></tr><tr><td class="code"><pre><span class="line">firebase.database().ref(&#39;userName&#39;).set(&#39;Pitt&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">let userName &#x3D; firebase.database().ref(&#39;userName&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">userName.on(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let item &#x3D; snapshot.val()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  document.getElementById(&#39;title&#39;).textContent &#x3D; item</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h2 id="Firebase-非同步"><a href="#Firebase-非同步" class="headerlink" title="Firebase 非同步"></a>Firebase 非同步</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firebase.database().ref(&#39;userName&#39;).set(&#39;Pitt&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">let userName &#x3D; firebase.database().ref(&#39;userName&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">userName.on(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let item &#x3D; snapshot.val()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(&#39;test1&#39;, item)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  document.getElementById(&#39;title&#39;).textContent &#x3D; item</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(&#39;test2&#39;)</span></pre></td></tr></table></figure>
<p>在前述程式碼中，正常資料庫回傳應該會需要等待時間，所以應該是先執行 <code>test2</code>，但在本地測試時，可能資料量太小，導致即使使用 Slow 3G，<code>test1</code> 依然先跑完，後續資料多的時候要再觀察非同步狀況。 </p>
<h2 id="新增資料"><a href="#新增資料" class="headerlink" title="新增資料"></a>新增資料</h2><p>透過 push 語法，添加資料至 Firebase，同時因為資料庫本身有協助建立 key 值，不需擔心資料衝突的問題。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const todoList &#x3D; firebase.database().ref(&#39;todoList&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">todoList.push(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  content: &#39;shopping&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 會拿到如下格式的資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">-M00rdx2RilLDFK9lmSg &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  content: &quot;shopping&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="刪除資料"><a href="#刪除資料" class="headerlink" title="刪除資料"></a>刪除資料</h2><p>child =&gt; 子路徑<br>可以透過 <code>ref()</code> 找到根目錄，也可以透過 <code>child()</code> 找到子目錄，下面兩種做法功能相同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let todoList &#x3D; firebase.database().ref(&#39;todoList&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">let todoList2 &#x3D; firebase.database().ref().child(&#39;todoList&#39;)</span></pre></td></tr></table></figure>
<p>remove =&gt; 刪除資料<br>最笨的刪除方法，直接根據 key 值進行刪除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">todoList.child(&#39;-M00rdx2RilLDFK9lmSg&#39;).remove()</span></pre></td></tr></table></figure>
<h2 id="網頁即時查看-Firebase-資料變動"><a href="#網頁即時查看-Firebase-資料變動" class="headerlink" title="網頁即時查看 Firebase 資料變動"></a>網頁即時查看 Firebase 資料變動</h2><p>先透過 <code>on()</code> 語法監聽資料庫，將快照取得的資料渲染到頁面，同時為了方便查看，再使用 <code>JSON.stringify</code> 格式化，<code>null, 2</code>則是縮排便於查看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const allData &#x3D; firebase.database().ref()</span></pre></td></tr><tr><td class="code"><pre><span class="line">allData.on(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let path &#x3D; document.getElementById(&#39;content&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  path.textContent &#x3D; JSON.stringify(snapshot.val(), null, 2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>透過 <code>orderByChild()</code> 選擇資料中排序的基準屬性，再透過 <code>forEach()</code> 依序撈出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firebase.database().ref(&#39;practice&#39;).set(people)</span></pre></td></tr><tr><td class="code"><pre><span class="line">let peopleRef &#x3D; firebase.database().ref(&#39;practice&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 先取得路徑 &#x3D;&gt; 是否需要排序(&#39;屬性&#39;) &#x3D;&gt; 讀取資料 &#x3D;&gt; 使用 forEach 依序撈出</span></pre></td></tr><tr><td class="code"><pre><span class="line">peopleRef.orderByChild(&#39;height&#39;).once(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  snapshot.forEach((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(node.val())</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h3 id="排序規則"><a href="#排序規則" class="headerlink" title="排序規則"></a>排序規則</h3><p>Firebase 的 <code>orderByChild()</code> 排序規則，需參考<a href="https://firebase.google.com/docs/database/admin/retrieve-data?hl=zh-cn#orderbychild" target="_blank" rel="noopener">官網文件</a></p>
<h2 id="搜尋區間"><a href="#搜尋區間" class="headerlink" title="搜尋區間"></a>搜尋區間</h2><p><code>startAt()</code> =&gt; 多少以上<br><code>endAt()</code> =&gt; 多少以下<br><code>equalTo()</code> =&gt; 等於</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e.g. 體重3000以上</span></pre></td></tr><tr><td class="code"><pre><span class="line">peopleRef.orderByChild(&#39;weight&#39;).startAt(3000).once(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  snapshot.forEach((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(node.val())</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 也可以透過 startAt() 和 endAt() 交叉運用來設定範圍</span></pre></td></tr><tr><td class="code"><pre><span class="line">peopleRef.orderByChild(&#39;weight&#39;).startAt(3000).endAt(5000).once(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  snapshot.forEach((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(node.val())</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 相等於</span></pre></td></tr><tr><td class="code"><pre><span class="line">peopleRef.orderByChild(&#39;weight&#39;).equalTo(3000).once(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  snapshot.forEach((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(node.val())</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h2 id="限制筆數"><a href="#限制筆數" class="headerlink" title="限制筆數"></a>限制筆數</h2><p><code>limitToFirst()</code> =&gt; 撈取從第一筆資料開始的資料，()內的條件設定預撈取的比數<br><code>limitToLast()</code> =&gt; 反之，從最後一筆開始撈資料</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">peopleRef.orderByChild(&#39;weight&#39;).startAt(2000).limitToLast(2).once(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  snapshot.forEach((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(node.val())</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h2 id="時間"><a href="#時間" class="headerlink" title="時間"></a>時間</h2><p>先透過 <code>JS</code> 原生語法檢查時間：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let time &#x3D; new Date()</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time.getFullYear())</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在 JS 中，0 &#x3D; 1月</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time.getMonth())</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 週日(禮拜7) &#x3D; 0、週一(禮拜一) &#x3D; 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time.getDay())</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time.getHours())</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time.getMinutes())</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time.getSeconds())</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1000毫秒 &#x3D; 1秒</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time.getMilliseconds())</span></pre></td></tr></table></figure>
<h3 id="UNIX-時間"><a href="#UNIX-時間" class="headerlink" title="UNIX 時間"></a>UNIX 時間</h3><p>從協調世界時1970年1月1日0時0分0秒起算至今</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let time &#x3D; new Date()</span></pre></td></tr><tr><td class="code"><pre><span class="line">time.getTime()  &#x2F;&#x2F; 拿到總秒數</span></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Firebase</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-Cli 初始化專案操作記錄</title>
    <url>/2020/02/12/vue-init-step/</url>
    <content><![CDATA[<p>前端框架版本迭代太快，更新過程中安裝的版本又容易出現錯誤，單靠記憶不可行，只好記錄自己的操作步驟，隨時更新方便檢查。</p>
<a id="more"></a>
<h2 id="全域環境調整-vue-cli-4-0-以上版本"><a href="#全域環境調整-vue-cli-4-0-以上版本" class="headerlink" title="全域環境調整(vue-cli 4.0 以上版本)"></a>全域環境調整(vue-cli 4.0 以上版本)</h2><h3 id="remove-old-version"><a href="#remove-old-version" class="headerlink" title="remove old version"></a>remove old version</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall vue-cli -g</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># or</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn global remove vue-cli</span></pre></td></tr></table></figure>
<h3 id="install-new-version"><a href="#install-new-version" class="headerlink" title="install new version"></a>install new version</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g @vue&#x2F;cli</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># or</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn global add @vue&#x2F;cli</span></pre></td></tr></table></figure>
<h3 id="check-version"><a href="#check-version" class="headerlink" title="check version"></a>check version</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue --version</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># or</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">vue -V</span></pre></td></tr></table></figure>
<h2 id="fixed-yarn"><a href="#fixed-yarn" class="headerlink" title="fixed yarn"></a>fixed yarn</h2><h3 id="clean-yarn-cache"><a href="#clean-yarn-cache" class="headerlink" title="clean yarn cache"></a>clean yarn cache</h3><p>yarn 更新至 v1.19.0 後，一度在終端機一直跳提醒，google 到的解法是清除 cache。<br>但目前已是 v1.22.0 已無目前問題。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn update v1.19.0 後，需清除一次 cache，指令如下：</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn cache clean</span></pre></td></tr></table></figure>
<h2 id="build-project"><a href="#build-project" class="headerlink" title="build project"></a>build project</h2><h3 id="version-not-match-error"><a href="#version-not-match-error" class="headerlink" title="version not match error"></a>version not match error</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">若出現vue的版本為 2.6.9，但套件採用 2.6.10 的 error</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">需升級vue的版本，指令如下：</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn global add vue@2.6.11</span></pre></td></tr></table></figure>
<h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue create project-name</span></pre></td></tr></table></figure>
<h3 id="選擇需要的項目"><a href="#選擇需要的項目" class="headerlink" title="選擇需要的項目"></a>選擇需要的項目</h3><p>官方預設提供的 css 預處理器，存在一些配置上的錯誤，這邊不做使用<br>僅選擇 Router &amp; Vuex(單元測試和 PWA 尚未掌握)<br>Router 採用 History Mode</p>
<h3 id="進入項目並啟動"><a href="#進入項目並啟動" class="headerlink" title="進入項目並啟動"></a>進入項目並啟動</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd project</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn server</span></pre></td></tr></table></figure>
<h2 id="install-Plugins"><a href="#install-Plugins" class="headerlink" title="install Plugins"></a>install Plugins</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add axios vue-axios</span></pre></td></tr></table></figure>
<h3 id="驗證"><a href="#驗證" class="headerlink" title="驗證"></a>驗證</h3><p><a href="https://github.com/vuelidate/vuelidate" target="_blank" rel="noopener">vuelidate</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add vuelidate</span></pre></td></tr></table></figure>
<h3 id="拖曳"><a href="#拖曳" class="headerlink" title="拖曳"></a>拖曳</h3><p><a href="https://github.com/SortableJS/Vue.Draggable" target="_blank" rel="noopener">vuedraggable</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add vuedraggable</span></pre></td></tr></table></figure>
<h3 id="預處理器"><a href="#預處理器" class="headerlink" title="預處理器"></a>預處理器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; pug</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn add vue-cli-plugin-pug --dev</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; scss</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn add vue-cli-plugin-pug sass sass-loader --dev</span></pre></td></tr></table></figure>
<h2 id="專案結構"><a href="#專案結構" class="headerlink" title="專案結構"></a>專案結構</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assets</span></pre></td></tr><tr><td class="code"><pre><span class="line">components</span></pre></td></tr><tr><td class="code"><pre><span class="line">views</span></pre></td></tr></table></figure>
<h3 id="scss"><a href="#scss" class="headerlink" title="scss"></a>scss</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assets</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - scss</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - color.scss &#x3D;&gt; 基礎共用色碼</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - mixin.scss &#x3D;&gt; 基礎共用函數</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - share.scss &#x3D;&gt; @import 上面兩個基礎共用scss，建立共用參數</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - style.scss &#x3D;&gt; @import share.scss &#x3D;&gt; 全域 scss，權重最重，在此處 reset css</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">main.js</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - import &#39;scss&#x2F;style.scss&#39;</span></pre></td></tr></table></figure>
<h4 id="scss-gt-vue-config-js"><a href="#scss-gt-vue-config-js" class="headerlink" title="scss =&gt; vue.config.js"></a>scss =&gt; vue.config.js</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 調整相對路徑，方便 component 引入樣式</span></pre></td></tr><tr><td class="code"><pre><span class="line">chainWebpack: config &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  config.resolve.alias</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .set(&#39;scss&#39;, resolve(&#39;src&#x2F;assets&#x2F;scss&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="router"><a href="#router" class="headerlink" title="router"></a>router</h3><p>拆分為 index.js 和 map.js<br>當頁面數過多時，將 routes 抽離至 map.js，再載入到 index.js</p>
<h3 id="webpack-設定"><a href="#webpack-設定" class="headerlink" title="webpack 設定"></a>webpack 設定</h3><p>建立 vue.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">function resolve (dir) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return path.join(__dirname, dir)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  publicPath: &#39;&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; 調整本地端口</span></pre></td></tr><tr><td class="code"><pre><span class="line">  devServer: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    host: &#39;localhost&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    port: 8081,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 設置代理 &#x3D;&gt; 解決跨域問題(調用後端API接口時通常不是同一個域名)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    proxy: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#39;&#x2F;api&#39;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        target: &#39;http:&#x2F;&#x2F;localhost:8081&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; websocket 縮寫 &#x3D;&gt; ws</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ws: false,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 避免在訪問網址時，自動將原點移除</span></pre></td></tr><tr><td class="code"><pre><span class="line">        changeOrigin: false</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  chainWebpack: (config) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    config.resolve.alias</span></pre></td></tr><tr><td class="code"><pre><span class="line">      .set(&#39;@&#39;, resolve(&#39;src&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6：解構賦值</title>
    <url>/2020/02/09/es6-destructuring/</url>
    <content><![CDATA[<p>解構賦值簡單來說，就是輕便且快速地取出元素。</p>
<a id="more"></a>
<h2 id="陣列解構"><a href="#陣列解構" class="headerlink" title="陣列解構"></a>陣列解構</h2><p>若有一個陣列如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numArray &#x3D; [2, 4, 6]</span></pre></td></tr></table></figure>
<p>可以透過下面兩種方法進行解構</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法一</span></pre></td></tr><tr><td class="code"><pre><span class="line">let [subNode, subItem] &#x3D; numArray</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法二</span></pre></td></tr><tr><td class="code"><pre><span class="line">let subNode</span></pre></td></tr><tr><td class="code"><pre><span class="line">let subItem</span></pre></td></tr><tr><td class="code"><pre><span class="line">[subNode, subItem] &#x3D; numArray</span></pre></td></tr></table></figure>
<p>這兩種方法，都會拿到相同結果。當陣列解構後，就可以進行一般運算或處理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let res &#x3D; subNode * subItem</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(res)  &#x2F;&#x2F; 印出8</span></pre></td></tr></table></figure>
<h2 id="預設值"><a href="#預設值" class="headerlink" title="預設值"></a>預設值</h2><p>如果無法預期拿到陣列內容為何？透過預設值，可以避免缺少值的問題。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numArray &#x3D; [2, 4]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">let [first, second, third] &#x3D; numArray</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">first + second + third  &#x2F;&#x2F; 這邊做計算的話，會產生 NaN</span></pre></td></tr></table></figure>
<p>但如果透過預設值為0，則能避免上面的問題</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let [first, second, third &#x3D; 0] &#x3D; numArray</span></pre></td></tr></table></figure>
<h2 id="忽略元素"><a href="#忽略元素" class="headerlink" title="忽略元素"></a>忽略元素</h2><p>意指，僅調用陣列中某一元素。可以透過前面的值為空，但逗號保留的方式來進行忽略元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numArray &#x3D; [2, 4, 8, 10]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">let [, , , item] &#x3D; numArray</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(item)</span></pre></td></tr></table></figure>
<h2 id="變數交換"><a href="#變數交換" class="headerlink" title="變數交換"></a>變數交換</h2><p>透過陣列的形式，進行陣列解構的變數交換</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; 2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">let b &#x3D; 4;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[a, b] &#x3D; [b, a]</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(a) &#x2F;&#x2F; 印出 4</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(b) &#x2F;&#x2F; 印出 2</span></pre></td></tr></table></figure>
<h2 id="剩餘部分重組"><a href="#剩餘部分重組" class="headerlink" title="剩餘部分重組"></a>剩餘部分重組</h2><p>去除原始陣列中部分元素，透過 <code>...</code> 的方式，將剩餘的元素重組成新陣列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numArray &#x3D; [1, 3, 5, 7, 9]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">let [first, ...node] &#x3D; numArray</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(node) &#x2F;&#x2F; 印出 [3, 5, 7, 9]</span></pre></td></tr></table></figure>
<h2 id="物件解構"><a href="#物件解構" class="headerlink" title="物件解構"></a>物件解構</h2><p>類似陣列解構，將變數快速賦值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let itemObj &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  a: 10,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  b: 20</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">let &#123;a, b&#125; &#x3D; itemObj</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(a) &#x2F;&#x2F; 印出 10</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(b) &#x2F;&#x2F; 印出 20</span></pre></td></tr></table></figure>
<p>物件解構，同樣可以給予預設值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123;a, b, c &#x3D; 0&#125; &#x3D; itemObj</span></pre></td></tr></table></figure>
<p>改變變數名稱，解構時，冒號左側的 <code>key</code> 值必須維持和物件中相同，但右側可以命名新的變數。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let itemObj &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  a: 10,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  b: 35</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">let &#123;a:x, b:y&#125; &#x3D; itemObj</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(y) &#x2F;&#x2F; 印出 35</span></pre></td></tr></table></figure>
<h2 id="解構函式"><a href="#解構函式" class="headerlink" title="解構函式"></a>解構函式</h2><p>透過解構傳進來的參數，精簡程式碼</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function distance(point) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let &#123;x, y&#125; &#x3D; point</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return Math.sqrt(x*x + y*y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>但是解構函式，更進階的用法是，在參數內直接解構</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function distance(&#123;x, y&#125;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return Math.sqrt(x*x + y*y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>因此既能給予預設值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function distance(&#123;x &#x3D; 0, y&#125;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return Math.sqrt(x*x + y*y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>也能重新命名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function distance(&#123;x:a, y&#125;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return Math.sqrt(a*a + y*y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6：筆記整理</title>
    <url>/2020/02/09/es6-note/</url>
    <content><![CDATA[<p>整理散落各方的 ES6 筆記，方便自己日後查詢。</p>
<a id="more"></a>
<h2 id="變數宣告"><a href="#變數宣告" class="headerlink" title="變數宣告"></a>變數宣告</h2><p>傳統變數宣告採用 <code>var</code> 的方式，但容易存在污染環境的問題。因此在 ES6 的語法中，新增兩個變數宣告方式 <code>let、const</code>。</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>使用 const 定義常數，意味著這個變數不作變動，且要求一定要賦值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a &#x3D; 1</span></pre></td></tr></table></figure>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>和傳統的<code>var</code>相似，側重解決過往的 scope(執行環境)問題。使用<code>let</code>宣告變數時，僅會作用在當前區域，且可以選擇賦值或不賦值，通常以 function 本身為分界。</p>
<ul>
<li>var<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (true) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    var b &#x3D; 10</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(b) &#x2F;&#x2F; 印出 10</span></pre></td></tr></table></figure></li>
<li>let<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (true) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    let c &#x3D; 20</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(c) &#x2F;&#x2F; error，c is not defined</span></pre></td></tr></table></figure>
<h2 id="樣板字面值-模板字符串-Template-literals"><a href="#樣板字面值-模板字符串-Template-literals" class="headerlink" title="樣板字面值(模板字符串) Template literals"></a>樣板字面值(模板字符串) Template literals</h2>過往<code>ES5</code>寫法如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(&quot;My name is &quot; + name)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 印出 My name is Pitt</span></pre></td></tr></table></figure>
修改為<code>ES6</code>時，則需調整寫法如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let name &#x3D; &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(&#96;My name is $&#123;name&#125;&#96;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 同樣印出 My name is Pitt</span></pre></td></tr></table></figure>
最外圍使用倒鉤符號包裹，先用$符號聲明，再用{}包覆變數。<h3 id="多行字串"><a href="#多行字串" class="headerlink" title="多行字串"></a>多行字串</h3><code>ES5</code>寫法中，多行字串使用<code>\n</code>，但在<code>ES6</code>中，若使用倒鉤符號包裹後，自動換行即可，寫法如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let msg &#x3D;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#96;&lt;span&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Hello World!</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;span&gt;&#96;</span></pre></td></tr></table></figure>
<h2 id="展開與其餘運算符"><a href="#展開與其餘運算符" class="headerlink" title="展開與其餘運算符"></a>展開與其餘運算符</h2>用法為<code>...</code>，常用於陣列合併或是複製陣列。<br>合併用法如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; [1, 2, 3]</span></pre></td></tr><tr><td class="code"><pre><span class="line">let b &#x3D; [4, 5, 6]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">let c &#x3D; [...a, ...b]</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(c)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 印出 [1, 2, 3, 4, 5, 6]</span></pre></td></tr></table></figure>
複製陣列後修改其中的值：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let d &#x3D; [...c]</span></pre></td></tr><tr><td class="code"><pre><span class="line">d[2] &#x3D; 7</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(d)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 印出 [1, 2, 7, 4, 5, 6]，而此時的c陣列是不受影響的</span></pre></td></tr></table></figure>
<h2 id="import-module"><a href="#import-module" class="headerlink" title="import module"></a>import module</h2>在<code>ES6</code>語法中，JS開始原生支援模組系統，用法如下：<br>先建立一個引用的<code>HTML</code>檔案，同時引用js檔案時，需注意<code>type = module</code>，寫法如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;.&#x2F;index.js&quot; type&#x3D;&quot;module&quot;&gt;&lt;&#x2F;script&gt;</span></pre></td></tr></table></figure>
準備一個<code>index.js</code>檔案來載入導出的資料，再準備一個<code>module.js</code>來導出資料<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; index.js</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import &#123; data, userData &#125; from &#39;.&#x2F;module.js&#39;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(data)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(userData)</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; module.js</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">export const data &#x3D; [1, 2, 3]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">export const userData &#x3D; [&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#39;id&#39;: &#39;first&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#39;name&#39;: &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;]</span></pre></td></tr></table></figure>
如此便完成最基礎的<code>import</code>和<code>export</code>。</li>
</ul>
]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Node 基礎知識</title>
    <url>/2020/01/27/node-basic-knowledge/</url>
    <content><![CDATA[<p>記錄自己學習 Node.js 基礎API用法。</p>
<a id="more"></a>
<h2 id="require、module-exports"><a href="#require、module-exports" class="headerlink" title="require、module exports"></a>require、module exports</h2><p><code>require</code>語法可以載入檔案，反之<code>module.exports</code>則能導出內容。寫法如下：<br>app.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let content &#x3D; require(&#39;.&#x2F;app2&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(content)</span></pre></td></tr></table></figure>
<p>app2.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let data &#x3D; &#39;node-test&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">module.exports &#x3D; data</span></pre></td></tr></table></figure>
<p>印出<code>&#39;node-test&#39;</code>字串。</p>
<p>除此之外也能放入物件格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  title: data,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  subTitle: &#39;title-test&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>印出對應的物件。</p>
<h3 id="相對冷門寫法"><a href="#相對冷門寫法" class="headerlink" title="相對冷門寫法"></a>相對冷門寫法</h3><p>一般導出寫法多採用<code>module.exports</code>，但單純使用<code>exports</code>也能導出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exports.subContent &#x3D; 123</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 這個寫法等於建立一個物件，如下：</span></pre></td></tr><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    subContent: 123</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;除了物件外，也能調用函數</span></pre></td></tr><tr><td class="code"><pre><span class="line">exports.call &#x3D; (() &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return &#39;call!&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h2 id="http-API"><a href="#http-API" class="headerlink" title="http API"></a>http API</h2><h3 id="createServer"><a href="#createServer" class="headerlink" title="createServer"></a>createServer</h3><p>Node 原生 http API 用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const http &#x3D; require(&#39;http&#39;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; request 使用者發出請求，常縮寫為 req</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; response 回傳結果，常縮寫為 res</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">http.createServer((req, res) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; 表頭內容</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text&#x2F;plain&quot; &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; 回傳結果內容</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.write(&#39;Hello Node!&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; 結束</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.end()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;).listen(8081) &#x2F;&#x2F; 監聽 port</span></pre></td></tr></table></figure>
<h2 id="查詢路徑或檔案名稱"><a href="#查詢路徑或檔案名稱" class="headerlink" title="查詢路徑或檔案名稱"></a>查詢路徑或檔案名稱</h2><p><code>__dirname</code>語法，可以查詢到當前檔案所在的路徑。<br><code>__filename</code>語法，則能檢查當前檔案名稱。</p>
<h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>Node 原生 path API 用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 抓目錄路徑，回傳 &#x2F;Path&#x2F;subNode</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(path.dirname(&#39;&#x2F;Path&#x2F;subNode&#x2F;index.js&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 路徑合併</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(path.join(__dirname, &#39;&#x2F;Path&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 抓取檔案名稱，回傳 index.js</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(path.basename(&#39;&#x2F;Path&#x2F;subNode&#x2F;index.js&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 抓副檔名，回傳 .js</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(path.extname(&#39;&#x2F;Path&#x2F;subNode&#x2F;index.js&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 分析路徑</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(path.parse(&#39;&#x2F;Path&#x2F;subNode&#x2F;index.js&#39;))</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>常見面試問題：JS</title>
    <url>/2020/01/16/interview-js/</url>
    <content><![CDATA[<p>整理 JS 面試問題。</p>
<a id="more"></a>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <tags>
        <tag>Interview</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 語法筆記</title>
    <url>/2020/01/14/vue-basic/</url>
    <content><![CDATA[<p>Vue 雖然是工作常用，一些熱門語法固然不會忘，但冷門的語法卻很難記住，乾脆大包小包統一整理成筆記。</p>
<a id="more"></a>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>常見面試問題：ES6</title>
    <url>/2020/01/05/interview-es6/</url>
    <content><![CDATA[<a id="more"></a>
]]></content>
      <tags>
        <tag>ES6</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>常見面試問題：CSS</title>
    <url>/2020/01/04/interview-css/</url>
    <content><![CDATA[<a id="more"></a>
]]></content>
      <tags>
        <tag>Interview</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>常見面試問題：HTML</title>
    <url>/2019/12/23/interview-html/</url>
    <content><![CDATA[<p>常見的 HTML 面試問題。</p>
<a id="more"></a>
<p>- </p>
]]></content>
      <tags>
        <tag>Interview</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>NVM 常用指令</title>
    <url>/2019/12/09/nvm-instruction/</url>
    <content><![CDATA[<p>記錄常用 NVM 指令。</p>
<a id="more"></a>
<h4 id="查詢遠端可安裝的-node-版本"><a href="#查詢遠端可安裝的-node-版本" class="headerlink" title="查詢遠端可安裝的 node 版本"></a>查詢遠端可安裝的 node 版本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm ls-remote</span></pre></td></tr></table></figure>
<h4 id="安裝所需的版本號"><a href="#安裝所需的版本號" class="headerlink" title="安裝所需的版本號"></a>安裝所需的版本號</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm install v12.14.1</span></pre></td></tr></table></figure>
<h4 id="切換所需使用的-node-版本"><a href="#切換所需使用的-node-版本" class="headerlink" title="切換所需使用的 node 版本"></a>切換所需使用的 node 版本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm use v12.14.1</span></pre></td></tr></table></figure>
<h4 id="設定預設使用的-node-版本"><a href="#設定預設使用的-node-版本" class="headerlink" title="設定預設使用的 node 版本"></a>設定預設使用的 node 版本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm alias default v12.14.1</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>NVM</tag>
      </tags>
  </entry>
  <entry>
    <title>常見面試問題</title>
    <url>/2019/12/03/interview-basic/</url>
    <content><![CDATA[<p>常見的面試問題。</p>
<a id="more"></a>
<h3 id="近期學習了什麼？"><a href="#近期學習了什麼？" class="headerlink" title="近期學習了什麼？"></a>近期學習了什麼？</h3><p>主要在摸索 Nuxt 開發，以及一些架站與 CICD 相關的知識，考慮到未來工作，多少會收到 SEO 的需求，SSR這一塊無可避免會碰觸到，因此抽出一些時間來加以了解。</p>
<h3 id="喜好的開發環境-作業系統-編輯器或-IDE-瀏覽器-開發工具-…-之類-。"><a href="#喜好的開發環境-作業系統-編輯器或-IDE-瀏覽器-開發工具-…-之類-。" class="headerlink" title="喜好的開發環境 (作業系統, 編輯器或 IDE, 瀏覽器, 開發工具 … 之類)。"></a>喜好的開發環境 (作業系統, 編輯器或 IDE, 瀏覽器, 開發工具 … 之類)。</h3><p>前端開發目前主要使用 mac os 系統，一方面是生態系完整，如果遇到問題，相對容易透過網路資訊排除。早期有使用過一陣子 sublime 和 ATOM，後來因為 vscode 急起直追和插件生態日益豐富完整，最後投入 vscode 懷抱。瀏覽器就是以 Chrome 為開發，畢竟習慣了 Chrome 的開發者工作，偶爾還是會回去摸摸 Firefox，但除錯方面，除了是特定瀏覽器破版問題，否則仍以 Chrome 為主。</p>
<h3 id="描述漸進增強-progressive-enhancement-和優美退化-graceful-degradation-間的差異？"><a href="#描述漸進增強-progressive-enhancement-和優美退化-graceful-degradation-間的差異？" class="headerlink" title="描述漸進增強 (progressive enhancement) 和優美退化 (graceful degradation) 間的差異？"></a>描述漸進增強 (progressive enhancement) 和優美退化 (graceful degradation) 間的差異？</h3><p>漸進漸強：從基本功能開始開發，保證系統在各種瀏覽器環境都可以執行，再逐步增加功能及提升使用者體驗。<br>優美退化：開發系統時，就針對最新最完善的環境來設計，而對於較舊的平台僅提供基本功能，而非完整功能。</p>
<h3 id="如果今年你能精通一項技術，那會是什麼？"><a href="#如果今年你能精通一項技術，那會是什麼？" class="headerlink" title="如果今年你能精通一項技術，那會是什麼？"></a>如果今年你能精通一項技術，那會是什麼？</h3><p>PWA，基於個人的主觀考慮，以及移動裝置幾乎佔據半壁江山的現狀，希望能透過PWA來實作project，進而達到仿app的操作體驗。</p>
<h3 id="最熟悉哪一套版本控制系統？"><a href="#最熟悉哪一套版本控制系統？" class="headerlink" title="最熟悉哪一套版本控制系統？"></a>最熟悉哪一套版本控制系統？</h3><p>git，前職的團隊，主要使用 GUI 工具(SourceTree)，方便查看節點，但目前也持續筆記 git 指令，方便未來自己在終端機直接操作。</p>
<h3 id="什麼是瀏覽器的同源策略？"><a href="#什麼是瀏覽器的同源策略？" class="headerlink" title="什麼是瀏覽器的同源策略？"></a>什麼是瀏覽器的同源策略？</h3><p>當 ajax 發出請求時，瀏覽器會要求當前網頁與 server，基於安全性必須同源。也就是協議(http、https)、域名(abc.com)、端口(8080)，三者皆必須一致，只要任一者不同，就是不同源。</p>
<p>當然，如果是 cdn 引入 js 的框架，或是 css 引入圖片網址，可以無視這個規則。任何跨域行為，都應該經過 server 端允許，若未經允許即可實現跨域，代表網站本身已存在重大漏洞。</p>
<h3 id="CORS-是什麼，它解決了什麼問題？"><a href="#CORS-是什麼，它解決了什麼問題？" class="headerlink" title="CORS 是什麼，它解決了什麼問題？"></a>CORS 是什麼，它解決了什麼問題？</h3><p>前端的一種跨域方式，由 server 端設置，前端可以直接使用，也可以只允許特定網址使用。</p>
<h3 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy 代理"></a>Proxy 代理</h3><p>得通過 nginx server 的設定來達成，以 Vue 為例，在 vue.config.js 進行設定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  devServer: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    host: &#39;localhost&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    port: 8080,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 當網址攔截到 &#x2F;api</span></pre></td></tr><tr><td class="code"><pre><span class="line">    proxy: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#39;&#x2F;api&#39;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 目標要指向哪個網址</span></pre></td></tr><tr><td class="code"><pre><span class="line">        target: &#39;https:&#x2F;&#x2F;www.xxx.com&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        changeOrigin: true,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;*</span></pre></td></tr><tr><td class="code"><pre><span class="line">          實務上，會遇到n個api，每一隻api路徑皆有所差別</span></pre></td></tr><tr><td class="code"><pre><span class="line">          為了統一攔截，因此虛擬化了一個路徑 &#x2F;api</span></pre></td></tr><tr><td class="code"><pre><span class="line">          但當轉發時，才將這個虛擬化的路徑轉為空</span></pre></td></tr><tr><td class="code"><pre><span class="line">        *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pathRewrite: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#39;api&#x2F;&#39;: &#39;&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>代理的安全性較高，可以隱藏後端 server 的來源，同時前後端需要設定的東西也較少。</p>
<h3 id="有不同的樣式表-stylesheets-，該如何整併到網站？"><a href="#有不同的樣式表-stylesheets-，該如何整併到網站？" class="headerlink" title="有不同的樣式表 (stylesheets)，該如何整併到網站？"></a>有不同的樣式表 (stylesheets)，該如何整併到網站？</h3><p>以 Vue 專案結構為例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- assets</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - scss</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - color.scss</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - mixin.scss</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - share.scss</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - style.scss</span></pre></td></tr></table></figure>
<p>將共用顏色和共用函數(breakpoint、position)進行拆分，兩者都 @import 到 share.scss，各 component 的 style.scss 直接 @import share.scss。同時再將 share.scss @import 到 style.scss，在 assets/scss/style.scss，被視為權重最高的樣式表，除了進行樣式初始化，也是用來處理特定需求(譬如覆蓋套件的樣式)，並將其註冊到 main.js。</p>
<h3 id="描述在開發一個網站時的工作流程"><a href="#描述在開發一個網站時的工作流程" class="headerlink" title="描述在開發一個網站時的工作流程"></a>描述在開發一個網站時的工作流程</h3><p>依循4階段規劃進行開發：<br>分析 =&gt; 規劃 =&gt; 實作 =&gt; 驗證</p>
<ul>
<li>分析：需求營運方+UI/UX+前後端+QA進行開會，明確釐清專案訴求為何？</li>
<li>規劃：專案可能會面臨時程問題，或是技術上目前是否可行，先列出優先度最重要的功能，確保功能面且權重最重者，可以優先上線，後續再針對次要功能與樣式進行優化。</li>
<li>實作：依據現有技術進行實作開發，倘若開發面臨困難，則提前反饋給主管。反之，若實際開發可行，但程式碼不如預期優雅，則以先不報錯為原則，試寫出第一版，後續再進行重構。</li>
<li>驗證：因為目前還未掌握自動化測試，目前驗證手法仍以手動驗證為主，大多採用由其他組員進行手動測試，並撰寫測試文件，當測試通過才發PR給主管。另外，若是QA驗證出現錯誤或是上線後發現錯誤，則統一發佈到issues，再依優先度解決。<h3 id="如果加入了一個專案，但是他們的程式碼用-tabs，但是你習慣用spaces-空白鍵-，你會怎麼做？"><a href="#如果加入了一個專案，但是他們的程式碼用-tabs，但是你習慣用spaces-空白鍵-，你會怎麼做？" class="headerlink" title="如果加入了一個專案，但是他們的程式碼用 tabs，但是你習慣用spaces (空白鍵)，你會怎麼做？"></a>如果加入了一個專案，但是他們的程式碼用 tabs，但是你習慣用spaces (空白鍵)，你會怎麼做？</h3>通常若是維護舊專案，會配合既有專案的風格進行開發，但若是新專案，則會討論 coding style 如何處理，不過我個人也是採用 tab。</li>
</ul>
]]></content>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6：類別與物件的基本觀念</title>
    <url>/2019/12/02/es6-object/</url>
    <content><![CDATA[<p>關於類別與物件的基本觀念。</p>
<a id="more"></a>
<h2 id="什麼是類別與物件"><a href="#什麼是類別與物件" class="headerlink" title="什麼是類別與物件"></a>什麼是類別與物件</h2><h3 id="舉例來說"><a href="#舉例來說" class="headerlink" title="舉例來說"></a>舉例來說</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">類別，可以理解為設計圖</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">物件，則是根據設計圖製造出來的實體</span></pre></td></tr></table></figure>
<h4 id="馬克杯"><a href="#馬克杯" class="headerlink" title="馬克杯"></a>馬克杯</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我們可以請設計師，繪出一個馬克杯的設計稿</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">接著，工廠可以根據設計圖，製造出無數的馬克杯</span></pre></td></tr></table></figure>
<h4 id="回到程式語言"><a href="#回到程式語言" class="headerlink" title="回到程式語言"></a>回到程式語言</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我們可以使用一個類別設計，產生無數個物件實體</span></pre></td></tr></table></figure>
<h4 id="關鍵字"><a href="#關鍵字" class="headerlink" title="關鍵字"></a>關鍵字</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在類別中，我們會使用到一些關鍵字</span></pre></td></tr><tr><td class="code"><pre><span class="line">class、constructor</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在物件中，則會使用到</span></pre></td></tr><tr><td class="code"><pre><span class="line">new</span></pre></td></tr></table></figure>
<h2 id="定義類別並產生物件"><a href="#定義類別並產生物件" class="headerlink" title="定義類別並產生物件"></a>定義類別並產生物件</h2><h3 id="寫法"><a href="#寫法" class="headerlink" title="寫法"></a>寫法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Car &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 利用已經定義好的類別，產生新的物件</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 再將 new Car() 產生的新物件，放入變數中</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car();</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car2 &#x3D; new Car();</span></pre></td></tr></table></figure>
<h3 id="定義建構式-constructor"><a href="#定義建構式-constructor" class="headerlink" title="定義建構式 (constructor)"></a>定義建構式 (constructor)</h3><ul>
<li>建構式：建立新物件時被呼叫的函式<h4 id="寫法-1"><a href="#寫法-1" class="headerlink" title="寫法"></a>寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Car &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 在類別中，定義建構式</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructor() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        console.log(&quot;呼叫建構式&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 利用已經定義好的類別，產生新的物件</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car();</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car2 &#x3D; new Car();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 上述流程</span></pre></td></tr><tr><td class="code"><pre><span class="line">定義類別 -&gt; 先呼叫建構式 -&gt; 執行完建構式內容 -&gt; 產生新物件 -&gt; 放入變數</span></pre></td></tr></table></figure>
<h3 id="定義與存取屬性-Attribute"><a href="#定義與存取屬性-Attribute" class="headerlink" title="定義與存取屬性 (Attribute)"></a>定義與存取屬性 (Attribute)</h3><h4 id="在建構式中建立屬性"><a href="#在建構式中建立屬性" class="headerlink" title="在建構式中建立屬性"></a>在建構式中建立屬性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor (參數) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    this.屬性名稱 &#x3D; 初始資料;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="寫法-2"><a href="#寫法-2" class="headerlink" title="寫法"></a>寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Car &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 在類別中，定義建構式</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructor() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.color &#x3D; &quot;blue&quot;; &#x2F;&#x2F; 建立新屬性 color，指定資料為&quot;blue&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 利用已經定義好的類別，產生新的物件</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car(); &#x2F;&#x2F; 新物件擁有 color 屬性，資料為&quot;blue&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car2 &#x3D; new Car(); &#x2F;&#x2F; 新物件擁有 color 屬性，資料為&quot;blue&quot;</span></pre></td></tr></table></figure>
<h4 id="透過參數，彈性建立新屬性，達到多個物件的差異"><a href="#透過參數，彈性建立新屬性，達到多個物件的差異" class="headerlink" title="透過參數，彈性建立新屬性，達到多個物件的差異"></a>透過參數，彈性建立新屬性，達到多個物件的差異</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Car &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 在類別中，定義建構式</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructor(color) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 透過新物件的參數，使屬性在賦值同時產生變化</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.color &#x3D; color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 利用已經定義好的類別，產生新的物件</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car(&quot;blue&quot;); &#x2F;&#x2F; 新物件擁有 color 屬性，資料為&quot;blue&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car2 &#x3D; new Car(&quot;red&quot;); &#x2F;&#x2F; 新物件擁有 color 屬性，資料為&quot;red&quot;</span></pre></td></tr></table></figure>
<h4 id="同一物件，更新屬性"><a href="#同一物件，更新屬性" class="headerlink" title="同一物件，更新屬性"></a>同一物件，更新屬性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Car &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 在類別中，定義建構式</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructor(color) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 透過新物件的參數，使屬性在賦值同時產生變化</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.color &#x3D; color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 利用已經定義好的類別，產生新的物件</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car(&quot;blue&quot;); &#x2F;&#x2F; 新物件擁有 color 屬性，資料為&quot;blue&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(car1.color); &#x2F;&#x2F; 取得屬性的資料，印出 blue</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">car1.color &#x3D; &quot;red&quot; &#x2F;&#x2F; 更新屬性資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(car1.color) &#x2F;&#x2F; 取得新的屬性資料，印出 red</span></pre></td></tr></table></figure>
<h3 id="定義、呼叫方法-Method"><a href="#定義、呼叫方法-Method" class="headerlink" title="定義、呼叫方法 (Method)"></a>定義、呼叫方法 (Method)</h3><h4 id="寫法-3"><a href="#寫法-3" class="headerlink" title="寫法"></a>寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Car &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 在類別中，定義建構式</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructor(color) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 透過新物件的參數，使屬性在賦值同時產生變化</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.color &#x3D; color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 定義一個 Run 方法，透過物件呼叫，並執行內部程式碼</span></pre></td></tr><tr><td class="code"><pre><span class="line">    run() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        console.log(&quot;Running&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 產生新物件，並且物件同時擁有 color 屬性和 run 方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car(&quot;blue&quot;);</span></pre></td></tr></table></figure>
<h4 id="call-method"><a href="#call-method" class="headerlink" title="call method"></a>call method</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Car &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 在類別中，定義建構式</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructor(color) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 透過新物件的參數，使屬性在賦值同時產生變化</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.color &#x3D; color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 定義一個 Run 方法，透過物件呼叫，並執行內部程式碼</span></pre></td></tr><tr><td class="code"><pre><span class="line">    run() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        console.log(&quot;Running&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car(&quot;blue&quot;); &#x2F;&#x2F; 產生新物件，並且物件同時擁有 color 屬性和 run 方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">car1.run(); &#x2F;&#x2F; call run method，並執行 run 內部的 code，印出 &quot;Running&quot;</span></pre></td></tr></table></figure>
<h4 id="綜合應用"><a href="#綜合應用" class="headerlink" title="綜合應用"></a>綜合應用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Car &#123; &#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructor(color) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.color &#x3D; color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.speed &#x3D; 0; &#x2F;&#x2F; 初始化車子速度為 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    run(val) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.speed &#x3D; val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        console.log(this.color + &quot;Car Running at&quot; + this.speed + &quot;km&#x2F;hr&quot; );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    stop() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.speed &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        console.log(this.color + &quot;Car is stopped&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 產生一個新物件，擁有 color、speed 屬性和 run、stop 方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car(&quot;red&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">car1.run(80);</span></pre></td></tr><tr><td class="code"><pre><span class="line">car1.stop();</span></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6：宣告變數與箭頭函數</title>
    <url>/2019/12/02/es6-const-arrow/</url>
    <content><![CDATA[<p>記錄自己學習 ES6 語法，對比 ES5 和 ES3 如何解決問題。</p>
<a id="more"></a>
<h2 id="var、let、const"><a href="#var、let、const" class="headerlink" title="var、let、const"></a>var、let、const</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">早期 javascript 只能用 var 宣告變數</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">在 ES6 版本後，添加 let、const 兩種方式</span></pre></td></tr></table></figure>
<h3 id="let、const"><a href="#let、const" class="headerlink" title="let、const"></a>let、const</h3><h4 id="let-用於宣告變數，可以選擇賦值或不賦值"><a href="#let-用於宣告變數，可以選擇賦值或不賦值" class="headerlink" title="let 用於宣告變數，可以選擇賦值或不賦值"></a>let 用於宣告變數，可以選擇賦值或不賦值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 賦值</span></pre></td></tr><tr><td class="code"><pre><span class="line">let a &#x3D; 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 不賦值</span></pre></td></tr><tr><td class="code"><pre><span class="line">let b;</span></pre></td></tr></table></figure>
<h4 id="const-用於宣告常數-不作變動-，一定要賦值"><a href="#const-用於宣告常數-不作變動-，一定要賦值" class="headerlink" title="const 用於宣告常數(不作變動)，一定要賦值"></a>const 用於宣告常數(不作變動)，一定要賦值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const c &#x3D; 10;</span></pre></td></tr></table></figure>
<h3 id="理解與應用"><a href="#理解與應用" class="headerlink" title="理解與應用"></a>理解與應用</h3><h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><p>傳統使用 var 宣告變數時，變數的 Scope(即影響範圍)，通常以 function 本身為分界</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (var i&#x3D;0;i&lt;3;i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	console.log(&quot;i:&quot;+i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(&quot;outside i:&quot;+i);</span></pre></td></tr></table></figure>
<h4 id="let-使用更嚴格的-Scope"><a href="#let-使用更嚴格的-Scope" class="headerlink" title="let (使用更嚴格的 Scope)"></a>let (使用更嚴格的 Scope)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (let i&#x3D;0;i&lt;3;i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	console.log(&quot;i:&quot;+i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(&quot;outside i:&quot;+i); &#x2F;&#x2F; error，i is not defined</span></pre></td></tr></table></figure>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a; &#x2F;&#x2F; 宣告變數，可以暫時不給資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">a &#x3D; 2; &#x2F;&#x2F; 變數中的資料可以變動</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">const b; &#x2F;&#x2F; error，常數宣告時，必須給定資料</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">const b &#x3D; 10; &#x2F;&#x2F; 正確，宣告常數同時給予資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">b &#x3D; 20; &#x2F;&#x2F; error，不能更動常數中的資料</span></pre></td></tr></table></figure>
<h3 id="比對-ES5-和-ES6-寫法"><a href="#比對-ES5-和-ES6-寫法" class="headerlink" title="比對 ES5 和 ES6 寫法"></a>比對 ES5 和 ES6 寫法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ES5</span></pre></td></tr><tr><td class="code"><pre><span class="line">Object.defineProperty(window, &quot;a&quot;, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    value: 1,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    writable: false,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(window.a)</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ES6</span></pre></td></tr><tr><td class="code"><pre><span class="line">const a &#x3D; 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(a)</span></pre></td></tr></table></figure>
<p>除了精簡程式碼，也讓寫法變得更輕鬆。</p>
<h2 id="Arrow-Function-箭頭函數"><a href="#Arrow-Function-箭頭函數" class="headerlink" title="Arrow Function (箭頭函數)"></a>Arrow Function (箭頭函數)</h2><h3 id="第一種：-參數列表-gt-回傳值"><a href="#第一種：-參數列表-gt-回傳值" class="headerlink" title="第一種：(參數列表) =&gt; (回傳值)"></a>第一種：(參數列表) =&gt; (回傳值)</h3><h4 id="傳統函數寫法"><a href="#傳統函數寫法" class="headerlink" title="傳統函數寫法"></a>傳統函數寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let add &#x3D; function (n1, n2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return n1+n2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h4 id="箭頭函數寫法"><a href="#箭頭函數寫法" class="headerlink" title="箭頭函數寫法"></a>箭頭函數寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let add &#x3D; (n1, n2) &#x3D;&gt; (n1+n2)</span></pre></td></tr></table></figure>
<h3 id="第二種：-參數列表-gt-函數內部程式"><a href="#第二種：-參數列表-gt-函數內部程式" class="headerlink" title="第二種：(參數列表) =&gt; {函數內部程式}"></a>第二種：(參數列表) =&gt; {函數內部程式}</h3><h4 id="傳統函數寫法-1"><a href="#傳統函數寫法-1" class="headerlink" title="傳統函數寫法"></a>傳統函數寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let add &#x3D; function (n1, n2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return n1+n2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h4 id="箭頭函數寫法-1"><a href="#箭頭函數寫法-1" class="headerlink" title="箭頭函數寫法"></a>箭頭函數寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let add &#x3D; (n1, n2) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return n1+n2</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h3 id="額外範例"><a href="#額外範例" class="headerlink" title="額外範例"></a>額外範例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let f &#x3D; () &#x3D;&gt; (5);</span></pre></td></tr><tr><td class="code"><pre><span class="line">let result &#x3D; f();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(result);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 印出 5</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let f &#x3D; (message) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">f(&quot;Hello, Pitt&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 印出 Hello, Pitt</span></pre></td></tr></table></figure>
<h3 id="匿名函數"><a href="#匿名函數" class="headerlink" title="匿名函數"></a>匿名函數</h3><h4 id="傳統寫法"><a href="#傳統寫法" class="headerlink" title="傳統寫法"></a>傳統寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(function()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(&quot;過了5秒&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;, 5000);</span></pre></td></tr></table></figure>
<h4 id="箭頭函數寫法-2"><a href="#箭頭函數寫法-2" class="headerlink" title="箭頭函數寫法"></a>箭頭函數寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(&quot;過了5秒&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;, 5000);</span></pre></td></tr></table></figure>
<h3 id="參數預設值"><a href="#參數預設值" class="headerlink" title="參數預設值"></a>參數預設值</h3><h4 id="傳統寫法-1"><a href="#傳統寫法-1" class="headerlink" title="傳統寫法"></a>傳統寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function show(message) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (typeof message &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        message &#x3D; &quot;default&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    alert(message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">show(&quot;Pitt&quot;); &#x2F;&#x2F; 顯示 Pitt</span></pre></td></tr><tr><td class="code"><pre><span class="line">show(); &#x2F;&#x2F; 顯示 default</span></pre></td></tr></table></figure>
<h4 id="箭頭函數寫法-3"><a href="#箭頭函數寫法-3" class="headerlink" title="箭頭函數寫法"></a>箭頭函數寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 若未給定參數資料，則直接採用等號後的賦值</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">function show(message&#x3D;&quot;default&quot;)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    alert(message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">show(&quot;Hello&quot;); &#x2F;&#x2F; 顯示 Hello</span></pre></td></tr><tr><td class="code"><pre><span class="line">show(); &#x2F;&#x2F; 顯示 default</span></pre></td></tr></table></figure>
<h4 id="額外範例-1"><a href="#額外範例-1" class="headerlink" title="額外範例"></a>額外範例</h4><h5 id="範例一：傳統寫法"><a href="#範例一：傳統寫法" class="headerlink" title="範例一：傳統寫法"></a>範例一：傳統寫法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function multiply(n1, n2&#x3D;2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return n1 + n2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">multiply(2, 3); &#x2F;&#x2F; 回傳 6</span></pre></td></tr><tr><td class="code"><pre><span class="line">multiply(); &#x2F;&#x2F; 回傳 4</span></pre></td></tr></table></figure>
<h5 id="範例一：箭頭函數寫法"><a href="#範例一：箭頭函數寫法" class="headerlink" title="範例一：箭頭函數寫法"></a>範例一：箭頭函數寫法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let multiply&#x3D;(n1, n2&#x3D;2) &#x3D;&gt; (n1+n2);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">multiply(2, 3); &#x2F;&#x2F; 回傳 6</span></pre></td></tr><tr><td class="code"><pre><span class="line">multiply(); &#x2F;&#x2F; 回傳 4</span></pre></td></tr></table></figure>
<h5 id="範例二"><a href="#範例二" class="headerlink" title="範例二"></a>範例二</h5><p>後方的參數可以使用前方的參數進行運算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function combine(first&#x3D;&quot;Pitt&quot;, last&#x3D;&quot;Wu&quot;, name&#x3D;first+&quot; &quot;+last) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">combine(&quot;Nini&quot;, &quot;Ya&quot;); &#x2F;&#x2F; 顯示 Nini Ya</span></pre></td></tr><tr><td class="code"><pre><span class="line">combine(&quot;Nini&quot;); &#x2F;&#x2F; 顯示 Nini Wu</span></pre></td></tr><tr><td class="code"><pre><span class="line">combine(); &#x2F;&#x2F; 顯示 Pitt Wu</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub + Netlify = Auto Deploy Hexo Post</title>
    <url>/2019/12/01/hexo-auto-deploy/</url>
    <content><![CDATA[<p>回歸 Hexo 寫技術筆記後，就一直懷念 Gatsby.js 可以透過 Netlify 自動推送部署，花了點時間 Google，終於也找到 Hexo 的自動部署方式，一整個對寫文章非常方便。</p>
<a id="more"></a>
<ul>
<li>step 1：<br>  先在 GitHub 建立遠端 repository</li>
<li>step 2：<br>  copy repository 的 url</li>
<li>step 3：<br>  回到 project 內，將本地和遠端進行關聯  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;your-githubname&#x2F;your-repository</span></pre></td></tr></table></figure></li>
<li>step 4：<br>  進行 commit  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .&#x2F;</span></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &#39;commit information&#39;</span></pre></td></tr></table></figure></li>
<li>step 5：<br>  推送到遠端  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin master</span></pre></td></tr></table></figure></li>
<li>step 6：<br>  打開最上層的<code>_config.yml</code>，修改設定  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  type: git # 部署方式</span></pre></td></tr><tr><td class="code"><pre><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;wuzhe0912&#x2F;pittwu-blog.git # 關聯 github</span></pre></td></tr><tr><td class="code"><pre><span class="line">  branch: run-page # 部署用 branch</span></pre></td></tr></table></figure>
  安裝 Hexo 部署插件  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add hexo-deployer-git</span></pre></td></tr></table></figure></li>
<li>step 7：<br>  執行指令  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  &#x2F;&#x2F; 清除舊的靜態文件</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo g      &#x2F;&#x2F; 生成新的靜態文件</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo d      &#x2F;&#x2F; 部署</span></pre></td></tr></table></figure>
  這時候本地的 Hexo 資料已推送到遠端的 Github repository</li>
<li>step 8：<br>  接著在<a href="https://www.netlify.com/" target="_blank" rel="noopener">Netlify</a>建立帳號，因為我們要關聯 GitHub，所以選擇第三方登入(使用 GitHub 帳號)</li>
<li>step 9：<br>  登入後，選擇右側的 New site from Git，再來選關聯 GitHub，授權完成後，選擇對應的 repository</li>
<li>step 10：<br>  Branch 需選擇剛剛<code>_config.yml</code>輸入的 branch name，下方 command 和 Publish 兩欄則清空，最後點選 Deploy site</li>
<li>step 11：<br>  很快就能在左上角看到 Netlify 幫我們生成的網址，但其中網址名的部分是亂數生成的，可以點選 Change site name 修改。</li>
<li>step 12：<br>  日後只要本地寫完文章，執行下面三道指令，即可完成自動部署。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo g</span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo d</span></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Netlify</tag>
        <tag>auto deploy</tag>
      </tags>
  </entry>
  <entry>
    <title>Node &amp; NPM Version Path Fixed</title>
    <url>/2019/12/01/node-version-fixed/</url>
    <content><![CDATA[<p>近期公司 MIS 調整硬體設備，造成環境有點跑掉，記錄一下自己在 Stack Overflow 上找到的解法。</p>
<a id="more"></a>
<p>打開 iTerm 會出現下述 error。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm is not compatible with the npm config “prefix” option: currently set to “&#x2F;Users&#x2F;xxx&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v8.12.0&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Run &#96;npm config delete prefix&#96; or &#96;nvm use --delete-prefix v8.12.0 --silent&#96; to unset it.</span></pre></td></tr></table></figure>
<p>從字面上來看，應該是 npm 和 nvm 管理的 node 版本沒有對上，按照終端機提供的訊息，敲入對應指令。再檢查 node 版本似乎是正常了，但事實上，若在 iTerm 上另開分頁，依然會跳相同的提示錯誤。雖然不影響操作，但看到總是不順眼，google 了一下解法，最終測試成功方案如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config delete prefix</span></pre></td></tr><tr><td class="code"><pre><span class="line">npm config set prefix $NVM_DIR&#x2F;versions&#x2F;node&#x2F;v8.12.0</span></pre></td></tr></table></figure>
<p>看起來應該是先刪除 npm 中設定的 prefix ，再重新設定當前 nvm 使用的版本。</p>
<p>最後附上 <a href="https://stackoverflow.com/questions/34718528/nvm-is-not-compatible-with-the-npm-config-prefix-option" target="_blank" rel="noopener">stackoverflow</a> 找到的解法。</p>
]]></content>
      <tags>
        <tag>Node.js</tag>
        <tag>NPM</tag>
        <tag>NVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Command Error Fixed</title>
    <url>/2019/12/01/git-command-error-fixed/</url>
    <content><![CDATA[<p>Git 雖然是基本知識，但有時操作上，還是不免出現一些 Error，記錄當中的解法，方便日後快速排查問題。</p>
<a id="more"></a>
<h2 id="初始化錯誤"><a href="#初始化錯誤" class="headerlink" title="初始化錯誤"></a>初始化錯誤</h2><p>由於之前習慣性從遠端 clone 下來，所以<code>.git</code>檔案同時會被準備完成，但這次因為嘗試自動部署<code>Hexo</code>，在推送時跳出下面這個錯誤。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: Not a git repository (or any of the parent directories): .git</span></pre></td></tr></table></figure>
<p>這個錯誤是說明，要推送的檔案不是一個<code>git</code>的<code>repository</code>，所以<code>git</code>在這個目錄底下會找不到<code>.git</code>檔案。解決方式是，執行指令<code>git init</code>，這樣就等於初始化一個<code>git repo</code>。</p>
<h2 id="GitLab-推送失敗錯誤"><a href="#GitLab-推送失敗錯誤" class="headerlink" title="GitLab 推送失敗錯誤"></a>GitLab 推送失敗錯誤</h2><p>這邊在 push branch 到 GitLab 時遇到一個問題，狀況如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GitLab: The project you were looking for could not be found.</span></pre></td></tr><tr><td class="code"><pre><span class="line">fatal: Could not read from remote repository.</span></pre></td></tr></table></figure>
<p>遠端的 GitLab 找不到我的 repository 位置，這邊會出現兩種可能，第一是還沒加入 SSH Key，第二是 SSH Key 正確，但需要重新更換遠端的名稱，首先輸入下面的指令，檢查本機公鑰有沒有正常加入 GitLab：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@gitlab.com</span></pre></td></tr></table></figure>
<p>如果出現 <code>Permission Denied (publickey)</code> 那就需要執行生成 SSH Key，並將公鑰加入 GitLab。</p>
<ol>
<li>生成 SSH Key：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;YOUR EMAIL&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">cd ~&#x2F;.ssh&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意生成過程中，會要求設定私人密碼，需要自己記住</span></pre></td></tr></table></figure></li>
<li>進入 ssh 底下，會看到兩個新的檔案：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id_rsa &#x3D;&gt; 私鑰</span></pre></td></tr><tr><td class="code"><pre><span class="line">id_rsa.pub &#x3D;&gt; 公鑰 &#x2F;&#x2F; 使用 vscode 將公鑰的檔案打開，複製裡面的內容</span></pre></td></tr></table></figure></li>
<li>回到 GitLab，操作路徑：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">點選右上角圖像&#x2F;setting&#x2F;左側 SSH Keys</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 將剛剛複製的內容貼到中間的輸入框，並點擊下方的 add key</span></pre></td></tr></table></figure></li>
<li>回到終端機，再次輸入<code>ssh -T git@gitlab.com</code>，這時會要求你輸入剛剛設定的私人密碼，成功後應該會看下面的文字：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome to GitLab, @Your_name!</span></pre></td></tr></table></figure>
到這邊第一步設定 SSH Keys 完成，但我嘗試重新 push 一次依然失敗：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">remote: The project you were looking for could not be found.</span></pre></td></tr><tr><td class="code"><pre><span class="line">fatal: repository &#39;https:&#x2F;&#x2F;gitlab.com&#x2F;Your_name&#x2F;Your_project.git&#x2F;&#39; not found</span></pre></td></tr></table></figure></li>
<li>重新更新並配對一次遠端名稱：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote rename origin old-origin</span></pre></td></tr><tr><td class="code"><pre><span class="line">git remote add origin git@gitlab.com:Your_name&#x2F;Your_project.git</span></pre></td></tr></table></figure>
到此，檔案就能正常推送到遠端了。</li>
</ol>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Next Theme Error Fixed</title>
    <url>/2019/11/29/next-theme-error-fixed/</url>
    <content><![CDATA[<p>雖然 Hexo 的學習曲線平滑，網路上也是隨手可得教學資料，但仍免不了，在使用過程中碰到一些難點，因此順手記錄這些難點的解法，方便自己日後回顧檢查。</p>
<a id="more"></a>
<h2 id="Next-主題背景動畫配置無效果"><a href="#Next-主題背景動畫配置無效果" class="headerlink" title="Next 主題背景動畫配置無效果"></a>Next 主題背景動畫配置無效果</h2><p><code>Next</code>在5.x版本時，設定背景動畫效果，僅需在<code>_config.yml</code>調整<code>true or false</code>即有效果。但在6.X版本，不知道因為何種原因，這種設置方式完全失效，因此改採用下述三個步驟設置動畫效果。</p>
<p>e.g. 選擇 canvas_nest 這個效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. cd themes&#x2F;next</span></pre></td></tr><tr><td class="code"><pre><span class="line">2. git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-canvas-nest source &#x2F; lib &#x2F; canvas-nest</span></pre></td></tr><tr><td class="code"><pre><span class="line">3. next&#x2F;_config.yml 設定 enable: true</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">其他三種動畫效果，同前述。</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Next Theme</tag>
      </tags>
  </entry>
  <entry>
    <title>Next Theme Install Note</title>
    <url>/2019/11/28/next-theme-install-note/</url>
    <content><![CDATA[<p>安裝 Hexo 的難度不高，但是調整 Hexo Theme 的配置是件不小的工程，記錄一下自己的調整流程。</p>
<a id="more"></a>

<h2 id="挑選主體"><a href="#挑選主體" class="headerlink" title="挑選主體"></a>挑選主體</h2><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">挑選 Hexo 主題網址</a>，這個 Blog 以<code>Next</code>為例。<br>step1. 安裝<code>theme</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd hexo-blog</span></pre></td></tr><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span></pre></td></tr></table></figure>
<p>step2. 修改設定<code>_config.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: landscape &#x3D;&gt; theme: next</span></pre></td></tr></table></figure>
<p>重新啟動<code>hexo s</code></p>
<h2 id="參數設定"><a href="#參數設定" class="headerlink" title="參數設定"></a>參數設定</h2><p>在<code>themes/next/_config.yml</code>中，可以透過調整參數，開啟非常多功能，以下條列其中。</p>
<h3 id="主題"><a href="#主題" class="headerlink" title="主題"></a>主題</h3><p>Next 有四種 Scheme 可以選擇，預設主題風格是 Muse，找到 scheme 設定，再將想選擇的註釋去除即可。<br>e.g.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Schemes</span></pre></td></tr><tr><td class="code"><pre><span class="line"># scheme: Muse</span></pre></td></tr><tr><td class="code"><pre><span class="line"># scheme: Mist</span></pre></td></tr><tr><td class="code"><pre><span class="line"># scheme: Pisces</span></pre></td></tr><tr><td class="code"><pre><span class="line">scheme: Gemini</span></pre></td></tr></table></figure>
<h3 id="開啟社群帳號連結"><a href="#開啟社群帳號連結" class="headerlink" title="開啟社群帳號連結"></a>開啟社群帳號連結</h3><p>打開或新增個人社群網站連結，僅須將註釋去除即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">social:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;wuzhe0912 || github</span></pre></td></tr><tr><td class="code"><pre><span class="line">  E-Mail: mailto:kgb00128@gmail.com || envelope</span></pre></td></tr></table></figure>
<h3 id="文章預覽"><a href="#文章預覽" class="headerlink" title="文章預覽"></a>文章預覽</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  enable: false</span></pre></td></tr><tr><td class="code"><pre><span class="line">  length: 150</span></pre></td></tr></table></figure>
<p>也可以透過<code>&lt;!--more--&gt;</code>來裁切，在<code>&lt;!--more--&gt;</code>以上的文字，會出現在預覽。</p>
<h3 id="啟用文章閱讀進度條"><a href="#啟用文章閱讀進度條" class="headerlink" title="啟用文章閱讀進度條"></a>啟用文章閱讀進度條</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reading_progress:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  enable: true</span></pre></td></tr></table></figure>
<h3 id="左側啟用文章閱讀-數"><a href="#左側啟用文章閱讀-數" class="headerlink" title="左側啟用文章閱讀%數"></a>左側啟用文章閱讀%數</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">back2top:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  enable: true</span></pre></td></tr><tr><td class="code"><pre><span class="line">  # Back to top in sidebar.</span></pre></td></tr><tr><td class="code"><pre><span class="line">  sidebar: true</span></pre></td></tr><tr><td class="code"><pre><span class="line">  # Scroll percent label in b2t button.</span></pre></td></tr><tr><td class="code"><pre><span class="line">  scrollpercent: true</span></pre></td></tr></table></figure>
<h3 id="開啟網站底部用戶訪問量"><a href="#開啟網站底部用戶訪問量" class="headerlink" title="開啟網站底部用戶訪問量"></a>開啟網站底部用戶訪問量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  enable: true</span></pre></td></tr></table></figure>
<p>接著調整<code>themes/next/layout/_third-party/statistics/busuanzi-counter.swig</code>中這兩行程式碼，可以在 i 標籤插入中文描述。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;i class&#x3D;&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;&quot;&gt;&lt;&#x2F;i&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;i class&#x3D;&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;&quot;&gt;&lt;&#x2F;i&gt;</span></pre></td></tr></table></figure>
<h3 id="調整文章末尾-tag-樣式"><a href="#調整文章末尾-tag-樣式" class="headerlink" title="調整文章末尾 tag 樣式"></a>調整文章末尾 tag 樣式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tag_icon: true</span></pre></td></tr></table></figure>
<h3 id="增加本地搜索功能"><a href="#增加本地搜索功能" class="headerlink" title="增加本地搜索功能"></a>增加本地搜索功能</h3><p>安裝插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add hexo-generator-search hexo-generator-searchdb</span></pre></td></tr></table></figure>
<p>調整設定為 true</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  enable: true</span></pre></td></tr></table></figure>
<h2 id="關於作者"><a href="#關於作者" class="headerlink" title="關於作者"></a>關於作者</h2><h3 id="新增大頭貼"><a href="#新增大頭貼" class="headerlink" title="新增大頭貼"></a>新增大頭貼</h3><p>step 1 建立存放圖片用的資料夾</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir source&#x2F;images</span></pre></td></tr></table></figure>
<p>step 2 將大頭貼的照片丟入資料夾<code>source/images</code>，接著在主題設定<code>themes/next/_config.yml</code>中，設定大頭貼路徑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avatar:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  url: &#x2F;images&#x2F;avatar.jpeg</span></pre></td></tr></table></figure>
<h3 id="調整大頭貼樣式"><a href="#調整大頭貼樣式" class="headerlink" title="調整大頭貼樣式"></a>調整大頭貼樣式</h3><p>邊框改為圓形，設為 true</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rounded: false &#x3D;&gt; rounded: true</span></pre></td></tr></table></figure>
<p>hover 時，添加旋轉特效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rotated: false &#x3D;&gt; rotated: true</span></pre></td></tr></table></figure>
<h2 id="上方添加-Github-Fork-圖片"><a href="#上方添加-Github-Fork-圖片" class="headerlink" title="上方添加 Github Fork 圖片"></a>上方添加 Github Fork 圖片</h2><p>step 1 首先到<a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">GitHub Corners</a>或是<a href="https://github.blog/2008-12-19-github-ribbons/" target="_blank" rel="noopener">GitHub Ribbons</a>尋找自己喜歡的樣式，並 copy code<br>step 2 打開<code>themes/next/layout/_layout.swig</code>，在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>下面<br>step 3 將<code>href</code>後面的網址，替換成個人<code>GitHub</code>主頁。<br>重新啟動服務<code>hexo s</code>。</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Next Theme</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記知識彙整</title>
    <url>/2019/11/16/interview-collection/</url>
    <content><![CDATA[<p>把不同知識面向的筆記統一進行彙整。</p>
<a id="more"></a>
<h2 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h2><ul>
<li><a href="/2020/01/14/vue-basic/" title="Vue.js 語法筆記">Vue.js 語法筆記</a>

</li>
</ul>
<h2 id="面試"><a href="#面試" class="headerlink" title="面試"></a>面試</h2><ul>
<li><a href="/2019/12/03/interview-basic/" title="常見面試問題">常見面試問題</a></li>
<li><a href="/2019/12/23/interview-html/" title="常見面試問題：HTML">常見面試問題：HTML</a></li>
<li><a href="/2020/01/04/interview-css/" title="常見面試問題：CSS">常見面試問題：CSS</a></li>
<li><a href="/2020/01/16/interview-js/" title="常見面試問題：JS">常見面試問題：JS</a></li>
<li><a href="/2020/01/05/interview-es6/" title="常見面試問題：ES6">常見面試問題：ES6</a></li>
</ul>
]]></content>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>重新拾筆</title>
    <url>/2019/09/27/firstPost/</url>
    <content><![CDATA[<p>信手寫一些雜談想法，就當做一篇簡單的隨筆。</p>
<a id="more"></a>
<h2 id="框架選擇"><a href="#框架選擇" class="headerlink" title="框架選擇"></a>框架選擇</h2><p><code>Hexo</code>從2018年開始接觸，期間雖然嘗試寫了幾篇筆記，但終究因為懶，時常無疾而終。雖然後面斷斷續續摸了幾種靜態站點框架，譬如<code>Hugo</code>、<code>Gatsby.js</code>、<code>Gridsome</code>，但始終沒有很順手。</p>
<p>但不否認，我個人蠻看好<code>Gatsby.js</code>的發展性，不過我目前還是走<code>Vue</code>的路線，對於<code>React</code>仍算陌生，<code>Gatsby.js</code>駕馭起來相當吃力，只能暫時放棄，重新運用<code>Hexo</code>作為Blog支撐，不過也不排除未來會遷移過去，就看後續的學習狀況吧。</p>
<h2 id="種一棵樹最好的時間是十年前，其次則是現在"><a href="#種一棵樹最好的時間是十年前，其次則是現在" class="headerlink" title="種一棵樹最好的時間是十年前，其次則是現在"></a>種一棵樹最好的時間是十年前，其次則是現在</h2><p>這句話，出自非洲經濟學家 Dambisa Moyo 的《dead aid》，作為書中的結尾言，非常簡短卻發人省思。從當下時間的角度來看，種下理想最好的決心固然是十年前，畢竟現在就能收穫。但既然這已成了往事，那考慮到未來的時間，<code>現在</code>就是未來的十年前。</p>
<p>勉勵自己，從現在開始認真寫blog吧！</p>
]]></content>
      <tags>
        <tag>隨想</tag>
      </tags>
  </entry>
</search>
