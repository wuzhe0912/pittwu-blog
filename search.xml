<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo 增加字數統計</title>
    <url>/2020/06/01/hexo/hexo-word-count/</url>
    <content><![CDATA[<p>優化 Hexo Blog 呈現的形式，添加筆記字數統計與閱讀時間計算。</p>
<a id="more"></a>
<h2 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add hexo-symbols-count-time</span></pre></td></tr></table></figure>

<h2 id="調整-config-yml-設定"><a href="#調整-config-yml-設定" class="headerlink" title="調整 _config.yml 設定"></a>調整 _config.yml 設定</h2><p>在<code>_config.yml</code>底部添加以下設定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  # 文章是否顯示字數統計 &amp; 閱讀時間</span></pre></td></tr><tr><td class="code"><pre><span class="line">  symbols: true</span></pre></td></tr><tr><td class="code"><pre><span class="line">  time: true</span></pre></td></tr><tr><td class="code"><pre><span class="line">  # 網頁底部是否顯示字數統計 &amp; 閱讀時間</span></pre></td></tr><tr><td class="code"><pre><span class="line">  total_symbols: true</span></pre></td></tr><tr><td class="code"><pre><span class="line">  total_time: true</span></pre></td></tr></table></figure>

<h2 id="NexT-設定"><a href="#NexT-設定" class="headerlink" title="NexT 設定"></a>NexT 設定</h2><p>預設已經開啟，所以無需額外調整。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  separated_meta: true  # false 時只會顯示單行</span></pre></td></tr><tr><td class="code"><pre><span class="line">  item_text_post: true  # 若為 false 只會顯示圖標和數字，不會顯示所需閱讀時間&amp;文章字數</span></pre></td></tr><tr><td class="code"><pre><span class="line">  item_text_total: true # footer 是否顯示 總字數文字與閱讀時間的文字</span></pre></td></tr><tr><td class="code"><pre><span class="line">  awl: 4 # 計算字數</span></pre></td></tr><tr><td class="code"><pre><span class="line">  wpm: 275 # 一分鐘閱讀的字數</span></pre></td></tr></table></figure>

<p>重新啟動 Hexo，即可看到相關功能已經開啟。</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>前端送出資料進行加密</title>
    <url>/2020/05/28/jsencrypt/</url>
    <content><![CDATA[<p>前端送出資料時(例如註冊、登入)，基於安全性考量，應該進行加密而非明文傳輸，目前已知的做法是採用<code>JSEncrypt</code>套件進行加密，再由後端進行解密，這邊記錄目前已知的做法。</p>
<a id="more"></a>
<h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add jsencrypt</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># or</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">npm install jsencrypt</span></pre></td></tr></table></figure>

<h2 id="設置公鑰"><a href="#設置公鑰" class="headerlink" title="設置公鑰"></a>設置公鑰</h2><p>公鑰為後端所提供，可能提供的方式有二，一是後端提供一組寫死的固定公鑰，二是由後端出API，提供動態的公鑰，這邊的做法先記錄第一種。另外，需要注意的是，若是前端需要進行解密動作，則後端同時也要提供私鑰。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Vuex store</span></pre></td></tr><tr><td class="code"><pre><span class="line">const state &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  publicKey: &#96;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  -----BEGIN PUBLIC KEY-----</span></pre></td></tr><tr><td class="code"><pre><span class="line">  xxx&#x2F;xxxx&#x2F;xxx</span></pre></td></tr><tr><td class="code"><pre><span class="line">  -----END PUBLIC KEY-----&#96;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">const getters &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  [&#39;publicKey&#39;](state) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return state.publicKey;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="建立加密函式"><a href="#建立加密函式" class="headerlink" title="建立加密函式"></a>建立加密函式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; src&#x2F;utils&#x2F;index.js</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import JSEncrypt from &#39;jsencrypt&#39;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import store from &#39;..&#x2F;store&#39;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">const encrypted &#x3D; (userInfo &#x3D; &#39;&#39;) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  const encrypt &#x3D; new JSEncrypt();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  encrypt.setPublicKey(store.getters.publicKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return encrypt.encrypt(JSON.stringify(userInfo));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">export &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  encrypted</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<h2 id="import-component"><a href="#import-component" class="headerlink" title="import component"></a>import component</h2><p>將要送出的參數抽離到物件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; login</span></pre></td></tr><tr><td class="code"><pre><span class="line">const userInfo &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  name: this.name,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  passWord: this.pwd</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">api</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .post(&#39;eLogin&#39;, userInfo)</span></pre></td></tr></table></figure>

<h2 id="axios-攔截器進行加密"><a href="#axios-攔截器進行加密" class="headerlink" title="axios 攔截器進行加密"></a>axios 攔截器進行加密</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; src&#x2F;api&#x2F;index.js</span></pre></td></tr><tr><td class="code"><pre><span class="line">import &#123; encrypted &#125; from &#39;..&#x2F;utils&#39;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">axios.interceptors.request.use(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  config &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 這邊可以加入所有需加密的API，例如login、register</span></pre></td></tr><tr><td class="code"><pre><span class="line">    const encryptedUrL &#x3D; [&#39;eLogin&#39;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    let haveEncryptedUrL &#x3D; encryptedUrL.some(j &#x3D;&gt; j &#x3D;&#x3D;&#x3D; config.url);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    haveEncryptedUrL &amp;&amp; (config.data &#x3D; encrypted(config.data));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return config;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  error &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return Promise.reject(error);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">);</span></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JSEncrypt</tag>
      </tags>
  </entry>
  <entry>
    <title>工作環境搭建(Mac)</title>
    <url>/2020/05/21/environment-build/</url>
    <content><![CDATA[<p>近期新工作取得新的 mac，整個環境初始化，需要耗費不少時間重新搭建需要的工具和安裝套件。為了避免日後同樣情況下，花費太多時間取得資源，因此建立一個 check<br>list，方便自己快速比對確認。</p>
<a id="more"></a>

<h2 id="Browser-瀏覽器"><a href="#Browser-瀏覽器" class="headerlink" title="Browser(瀏覽器)"></a>Browser(瀏覽器)</h2><p>安裝主流瀏覽器</p>
<ol>
<li>Chrome</li>
<li>Firefox</li>
<li>Safari(Mac 預設原生，無需安裝)</li>
</ol>
<h2 id="終端機環境與套件"><a href="#終端機環境與套件" class="headerlink" title="終端機環境與套件"></a>終端機環境與套件</h2><h3 id="HomeBrew"><a href="#HomeBrew" class="headerlink" title="HomeBrew"></a>HomeBrew</h3><p>打開 terminal 輸入以下指令，安裝過程中，同步會安裝 xcode。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span></pre></td></tr></table></figure>

<p>檢查 HomeBrew 版本號，確認是否安裝正常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew --version</span></pre></td></tr></table></figure>

<h3 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h3><p>使用 HomeBrew 進行安裝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew cask install iTerm2</span></pre></td></tr></table></figure>

<p>後續預設使用 iTerm2 來執行指令</p>
<h3 id="zash"><a href="#zash" class="headerlink" title="zash"></a>zash</h3><p>若 zash 尚未安裝，則安裝 zash 來取代 bash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install zsh zsh-completions</span></pre></td></tr></table></figure>

<p>調整預設的 shell 為 zsh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo sh -c &quot;echo $(which zsh) &gt;&gt; &#x2F;etc&#x2F;shells&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">chsh -s $(which zsh)</span></pre></td></tr></table></figure>

<p>重新啟動 iTerm2，使用指令檢查是否設定成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $SHELL</span></pre></td></tr></table></figure>

<h3 id="oh-my-zash"><a href="#oh-my-zash" class="headerlink" title="oh-my-zash"></a>oh-my-zash</h3><p>oh-my-zash 可以理解為 zash 的框架，安裝的目的是為了使用其外掛與主題(theme)，安裝指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.github.com&#x2F;robbyrussell&#x2F;oh-my-zsh&#x2F;master&#x2F;tools&#x2F;install.sh)&quot;</span></pre></td></tr></table></figure>

<p>打開<code>.zshrc</code>更改主題</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open ~&#x2F;.zshrc</span></pre></td></tr></table></figure>

<p>找到<code>ZSH_THEME</code>後，可以修改為自己喜歡的 <a href="https://github.com/ohmyzsh/ohmyzsh/wiki/themes" target="_blank" rel="noopener">theme</a>，預設是 robbyrussell，可改為自己喜歡的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZSH_THEME&#x3D;&quot;robbyrussell&quot;</span></pre></td></tr></table></figure>

<p>如果字體出現亂碼狀況，可以下載對應字體，譬如使用 agnoster theme，則可以下載<code>Melso</code>。字體修改路徑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Profiles &gt; Open Profiles &gt; Edit Profiles... &gt; Text &gt; Font</span></pre></td></tr></table></figure>

<h3 id="zash-權限問題"><a href="#zash-權限問題" class="headerlink" title="zash 權限問題"></a>zash 權限問題</h3><p>如果運行終端機的環境時出現以下狀況：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[oh-my-zsh] For safety, we will not load completions from these directories until</span></pre></td></tr><tr><td class="code"><pre><span class="line">[oh-my-zsh] you fix their permissions and ownership and restart zsh.</span></pre></td></tr><tr><td class="code"><pre><span class="line">[oh-my-zsh] See the above list for directories with group or other writability.</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[oh-my-zsh] To fix your permissions you can do so by disabling</span></pre></td></tr><tr><td class="code"><pre><span class="line">[oh-my-zsh] the write permission of &quot;group&quot; and &quot;others&quot; and making sure that the</span></pre></td></tr><tr><td class="code"><pre><span class="line">[oh-my-zsh] owner of these directories is either root or your current user.</span></pre></td></tr><tr><td class="code"><pre><span class="line">[oh-my-zsh] The following command may help:</span></pre></td></tr><tr><td class="code"><pre><span class="line">[oh-my-zsh]     compaudit | xargs chmod g-w,o-w</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[oh-my-zsh] If the above didn&#39;t help or you want to skip the verification of</span></pre></td></tr><tr><td class="code"><pre><span class="line">[oh-my-zsh] insecure directories you can set the variable ZSH_DISABLE_COMPFIX to</span></pre></td></tr><tr><td class="code"><pre><span class="line">[oh-my-zsh] &quot;true&quot; before oh-my-zsh is sourced in your zshrc file.</span></pre></td></tr></table></figure>
<p>代表 oh-my-zash 需要修復權限，打開文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open ~&#x2F;.zshrc</span></pre></td></tr></table></figure>
<p>文件中加入這一行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZSH_DISABLE_COMPFIX&#x3D;true</span></pre></td></tr></table></figure>
<p>重新運行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~&#x2F;.zshrc</span></pre></td></tr></table></figure>

<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://dustinhsiao21.com/2019/04/09/%E9%80%8F%E9%81%8E%E5%9C%A8-mac-%E4%B8%8A%E5%AE%89%E8%A3%9DiTerm2-%E6%B4%BB%E6%BD%91%E4%BD%A0%E7%9A%84%E7%B5%82%E7%AB%AF%E6%A9%9F/" target="_blank" rel="noopener">透過在 MAC 上安裝 iTerm2 活潑你的終端機</a></p>
<h2 id="解壓縮工具"><a href="#解壓縮工具" class="headerlink" title="解壓縮工具"></a>解壓縮工具</h2><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>2020 年的現在，仍以 Visual Studio Code 為主。</p>
<h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><p><a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener">官網下載網址</a></p>
<h3 id="擴充套件"><a href="#擴充套件" class="headerlink" title="擴充套件"></a>擴充套件</h3><ul>
<li>Beautify</li>
<li>Bracket Pair Colorizer</li>
<li>Code Spell Checker</li>
<li>ESLint</li>
<li>Git History</li>
<li>GitLens</li>
<li>Vue 2 Snippets</li>
<li>Vue VSCode Snippets</li>
<li>Vetur</li>
<li>Color Highlight</li>
<li>Material Icon Theme</li>
<li>Auto Close Tag</li>
<li>Auto Rename Tag</li>
<li>Path Intellisense</li>
<li>Path Autocomplete</li>
<li>indent-rainbow</li>
<li>One Dark Pro</li>
<li>One</li>
<li>Markdown Preview Enhanced</li>
</ul>
<h3 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h3><ul>
<li>Material Theme<ul>
<li>採用 default</li>
</ul>
</li>
</ul>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="install-1"><a href="#install-1" class="headerlink" title="install"></a>install</h3><p>使用 HomeBrew 的指令安裝 Git</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install git</span></pre></td></tr></table></figure>

<h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><p><a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">Sourcetree 官方網站</a></p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li>Slack</li>
<li>Postman</li>
<li>Zeplin</li>
<li>iStat Menus</li>
</ul>
<h3 id="依各自公司需求"><a href="#依各自公司需求" class="headerlink" title="依各自公司需求"></a>依各自公司需求</h3><ul>
<li>Rocket.Chat</li>
</ul>
<h2 id="NVM"><a href="#NVM" class="headerlink" title="NVM"></a>NVM</h2><p>使用 NVM 工具來管理 Node 版本與環境，安裝指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;nvm-sh&#x2F;nvm&#x2F;v0.35.3&#x2F;install.sh | bash</span></pre></td></tr></table></figure>

<p>重新啟動 iTerm2 後，檢查 nvm 是否安裝成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm --version</span></pre></td></tr></table></figure>

<p>查詢遠端可安裝的 Node 版本指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm ls-remote</span></pre></td></tr></table></figure>

<p>安裝所需要的 Node 版本號(通常安裝 LTS version)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm install v12.16.3</span></pre></td></tr></table></figure>

<p>切換所需使用的 node 版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm use v12.16.3</span></pre></td></tr></table></figure>

<p>設定預設使用的 node 版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm alias default v12.16.2</span></pre></td></tr></table></figure>

<p>檢查是否正常安裝成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span></pre></td></tr><tr><td class="code"><pre><span class="line">npm -v</span></pre></td></tr></table></figure>

<h2 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h2><p>安裝 Facebook 提供的模組管理工具 Yarn，雖然官方推薦使用 HomeBrew 來安裝，但我自己安裝的過程中是存在問題的，查了相關的 issues，多是推薦改用備選方案的指<br>令進行安裝：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -o- -L https:&#x2F;&#x2F;yarnpkg.com&#x2F;install.sh | bash</span></pre></td></tr></table></figure>

<h2 id="VSCode-加入終端機指令"><a href="#VSCode-加入終端機指令" class="headerlink" title="VSCode 加入終端機指令"></a>VSCode 加入終端機指令</h2><p>打開 VSCode 後開啟快捷鍵</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shift + cmd + p</span></pre></td></tr></table></figure>
<p>輸入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell command</span></pre></td></tr></table></figure>
<p>選擇</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Shell Command: Install code command in PATH</span></pre></td></tr></table></figure>
<p>重新啟動後，即可在終端機使用<code>code</code>打開 VSCode。</p>
]]></content>
      <tags>
        <tag>環境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 踩坑記錄</title>
    <url>/2020/05/21/css/question-I/</url>
    <content><![CDATA[<p>工作上或是進修時，常常會莫名卡在一些奇怪的點，每一次踩到坑都是一次教訓，但為了節省自己的時間，提升開發效率，決定動手把每次踩坑路上的雷點和解法記錄下來，預計一篇筆記會記錄20個雷點與解法。</p>
<a id="more"></a>
<h2 id="z-index-和-opacity-的覆蓋衝突問題"><a href="#z-index-和-opacity-的覆蓋衝突問題" class="headerlink" title="z-index 和 opacity 的覆蓋衝突問題"></a>z-index 和 opacity 的覆蓋衝突問題</h2><p>在 css 中，當元素設定 opacity 時其實具有權重效果，即被自動加入了 z-index，因此倘若有加入 fixed 效果的元素，在經過 opacity 的區域，仍會出現被覆蓋的狀況。</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法 1"></a>解法 1</h3><p>要解決上述的情況時，需要添加 z-index，但是僅在 fixed 的元素上加入再高的權重，都是無法蓋過 opacity 的元素，需要連添加 opacity 的元素也加入 z-index：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.fixed &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  position: fixed;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  z-index: 2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">.opacity &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  position: relative;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  z-index: 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法 2"></a>解法 2</h3><p>撇除 opacity 不談，其實要達到半透明效果的話，更好的做法應該是採用 rgba 的方式來達成，除了效果相同外，也可以迴避前述的權重問題：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.wrap &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  background: rgba($color: #000, $alpha: 0.8);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<ul>
<li><a href="https://coder-coder.com/z-index-isnt-working/" target="_blank" rel="noopener">附上 z-index 說明文章</a></li>
</ul>
<h2 id="background-size-在-android-手機需注意的細節"><a href="#background-size-在-android-手機需注意的細節" class="headerlink" title="background-size 在 android 手機需注意的細節"></a>background-size 在 android 手機需注意的細節</h2><p>一般我在使用圖片作為背景時，偏好使用 background-size 來填滿元素，當然做法有很多，包含 cover、contain、100% 等等，其中需要特別注意 100% 這個寫法。</p>
<p>早先我會寫的比較嚴謹：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.wrap &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  background-size: 100% 100%;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>這種寫法是沒有問題的。但是如果寫的比較簡略，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.wrap &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  background-size: 100%;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>在 ios 手機上或是 chrome 的模擬，都會正常顯示，但是在 android 手機不會正常吃到高的部分(縱軸)，所以這一點需要注意寫法嚴謹度。</p>
]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 傳值or傳址 &amp; 淺拷貝or深拷貝</title>
    <url>/2020/05/17/javascript/pass-by-value/</url>
    <content><![CDATA[<p>關於 JS 傳值的基礎知識，以及如何透過淺拷貝和深拷貝來改善潛在的問題。</p>
<a id="more"></a>
<h3 id="Pass-by-value-傳值"><a href="#Pass-by-value-傳值" class="headerlink" title="Pass by value(傳值)"></a>Pass by value(傳值)</h3><p>當變數的值為原始型別時，JS 的行為模式會採用 Pass by value</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 宣告 a 變數的賦值為 10，並且在記憶體中 copy 出 10，賦值給 b</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">var a &#x3D; 10</span></pre></td></tr><tr><td class="code"><pre><span class="line">var b &#x3D; a</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(b) &#x2F;&#x2F; 10</span></pre></td></tr></table></figure>

<p>上述的傳值適用以下原始型別：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String</span></pre></td></tr><tr><td class="code"><pre><span class="line">Number</span></pre></td></tr><tr><td class="code"><pre><span class="line">Boolean</span></pre></td></tr><tr><td class="code"><pre><span class="line">Undefined</span></pre></td></tr><tr><td class="code"><pre><span class="line">Null</span></pre></td></tr></table></figure>

<h3 id="Pass-by-reference-傳址"><a href="#Pass-by-reference-傳址" class="headerlink" title="Pass by reference(傳址)"></a>Pass by reference(傳址)</h3><p>而在物件型別中，則是另一番情景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var object1 &#x3D; &#123; num: 5 &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">var object2 &#x3D; object1</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(object2) &#x2F;&#x2F; &#123; num: 5 &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">object1.num &#x3D; 8</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(object2) &#x2F;&#x2F; &#123; num: 8 &#125;</span></pre></td></tr></table></figure>
<p>在物件型別中，object1 和 object2 的賦值在記憶體中都會指向同一個位置，因此如果改變 object1，則連帶會影響到 object2，它並不會像原始型別一樣，在記憶體中進行 copy。</p>
<p>適用以下型別：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object</span></pre></td></tr><tr><td class="code"><pre><span class="line">Array</span></pre></td></tr></table></figure>

<h3 id="淺拷貝-shallow-copy"><a href="#淺拷貝-shallow-copy" class="headerlink" title="淺拷貝(shallow copy)"></a>淺拷貝(shallow copy)</h3><p>為了改善前述的 Pass by reference 產生的問題，具體延伸出以下方法：</p>
<h4 id="處理-Array"><a href="#處理-Array" class="headerlink" title="處理 Array"></a>處理 Array</h4><ul>
<li><p>slice() 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; slice 會從括號內的索引位置開始進行 copy</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">var array1 &#x3D; [1, 2, 3]</span></pre></td></tr><tr><td class="code"><pre><span class="line">var array2 &#x3D; array1.slice(0)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(array2) &#x2F;&#x2F; [1, 2, 3]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">array1[1] &#x3D; 4</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(array1) &#x2F;&#x2F; [1, 4, 3]</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(array2) &#x2F;&#x2F; [1, 2, 3]</span></pre></td></tr></table></figure>
</li>
<li><p>展開運算符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var array1 &#x3D; [10, 20, 30]</span></pre></td></tr><tr><td class="code"><pre><span class="line">var array3 &#x3D; [...array1]</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(array3) &#x2F;&#x2F; [10, 20, 30]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">array1[2] &#x3D; 50</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(array1) &#x2F;&#x2F; [10, 20, 50]</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(array3) &#x2F;&#x2F; [10, 20, 30]</span></pre></td></tr></table></figure>
<p>上述這兩個方法都可以避免 Array 在記憶中被指向同一個位置。</p>
</li>
</ul>
<h4 id="處理-Object"><a href="#處理-Object" class="headerlink" title="處理 Object"></a>處理 Object</h4><ul>
<li>Object.assign<br>操作 Object 的資料時，不建議直接操作原始資料，而是 copy 出來再進行處理<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var object1 &#x3D; &#123; num: 10 &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">var object2 &#x3D; Object.assign(&#123;&#125;, object1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(object2) &#x2F;&#x2F; &#123; num: 10 &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">object1.num &#x3D; 100</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(object1) &#x2F;&#x2F; &#123; num: 100 &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(object2) &#x2F;&#x2F; &#123; num: 10 &#125;</span></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="淺拷貝存在的問題"><a href="#淺拷貝存在的問題" class="headerlink" title="淺拷貝存在的問題"></a>淺拷貝存在的問題</h4><p>淺拷貝只能處理物件型別中的第一層，如果資料中包含第二層甚至更多層時，淺拷貝無法處理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var object1 &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  name: &#39;Pitt&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  player: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: &#39;Nancy&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">var object2 &#x3D; &#123;...object1&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(object2)  &#x2F;&#x2F; &#123; name: &#39;Pitt&#39; player: &#123; name: &#39;Nancy&#39; &#125; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">object1.name &#x3D; &#39;Mike&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">object1.player.name &#x3D; &#39;Alisa&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(object2.name)   &#x2F;&#x2F; &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(object2.player.name) &#x2F;&#x2F; &#39;Alisa&#39;</span></pre></td></tr></table></figure>
<p>從上述可以看到，淺拷貝有辦法處理淺層資料，但更深層的資料他就無能為力了。</p>
<h3 id="深拷貝-deep-copy"><a href="#深拷貝-deep-copy" class="headerlink" title="深拷貝(deep copy)"></a>深拷貝(deep copy)</h3><ul>
<li>透過 Lodash 提供的方法來處理深拷貝<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var object1 &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  name: &#39;Amy&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  player: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: &#39;Betty&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">var object2 &#x3D; _.cloneDeep(object1)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">object1.player.name &#x3D; &#39;Alisa&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(object1.player.name) &#x2F;&#x2F; &#39;Alisa&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(object2.player.name) &#x2F;&#x2F; &#39;Betty&#39;</span></pre></td></tr></table></figure>
<a href="https://jsbin.com/vixabijenu/edit?html,js,console" target="_blank" rel="noopener">Jsbin</a><br>Lodash 提供的方法，成功對深層資料進行複製，避免記憶體中被同時指向一個位置。</li>
</ul>
<h3 id="Pass-by-sharing"><a href="#Pass-by-sharing" class="headerlink" title="Pass by sharing"></a>Pass by sharing</h3><p>凡事皆有例外，而 JavaScript 這門奇怪的語言，更是容易出現例外，它並不完全屬於傳值或傳址，而是同標題的 Pass by sharing。在函式的環境中，會出現特殊狀況：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var num &#x3D; &#123; value: 20 &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">function changeNum (val) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  val &#x3D; &#123; value: 40 &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">change(num)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(num) &#x2F;&#x2F; &#123; value: 20 &#125;</span></pre></td></tr></table></figure>
<p>按照傳址的邏輯，物件型別被改變時，記憶體中該位置的值也隨之被改變。但在函式的環境下，外部變數卻不受影響，但如果採用更新的方式，則會受到影響，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var num2 &#x3D; &#123; value: 20 &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">function changeNum (val) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  num2.value &#x3D; 40</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">changeNum(num2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(num2) &#x2F;&#x2F; &#123; value: 40 &#125;</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 需求解法：重組陣列</title>
    <url>/2020/05/15/javascript/array-reorganization/</url>
    <content><![CDATA[<p>朋友遇到業務上的一個場景，需要將原始陣列中的值進行過濾，重組後提到第一層，再重組第二層的子陣列。這邊嘗試解解看，先試解一個解法，後續若有新的解法再補充。</p>
<a id="more"></a>
<h3 id="原始陣列"><a href="#原始陣列" class="headerlink" title="原始陣列"></a>原始陣列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let studentList &#x3D; [</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    id: 1,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: &#39;小明&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    class: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      name: &#39;A班&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    id: 2,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: &#39;小王&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    class: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      name: &#39;C班&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    id: 3,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: &#39;小智&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    class: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      name: &#39;C班&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    id: 4,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: &#39;小美&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    class: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      name: &#39;A班&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    id: 5,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: &#39;小智障&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    class: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      name: &#39;B班&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">]</span></pre></td></tr></table></figure>

<h3 id="預期結果"><a href="#預期結果" class="headerlink" title="預期結果"></a>預期結果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let classRoster &#x3D; [</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: &#39;A班&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    students: [</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        id: 1,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        name: &#39;小明&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        id: 4,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        name: &#39;小美&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: &#39;B班&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    students: [</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        id: 5,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        name: &#39;小智障&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: &#39;C班&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    students: [</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        id: 2,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        name: &#39;小王&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        id: 3,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        name: &#39;小智&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">]</span></pre></td></tr></table></figure>

<h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 整理重複班別名稱</span></pre></td></tr><tr><td class="code"><pre><span class="line">let target &#x3D; []</span></pre></td></tr><tr><td class="code"><pre><span class="line">studentList.forEach(node &#x3D;&gt; target.push(node.class.name))</span></pre></td></tr><tr><td class="code"><pre><span class="line">let classNameList &#x3D; Array.from(new Set(target)).sort()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 重組陣列</span></pre></td></tr><tr><td class="code"><pre><span class="line">let subTarget &#x3D; classNameList.map((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let item &#x3D; studentList.filter((subNode) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return subNode.class.name &#x3D;&#x3D;&#x3D; node</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  let subItem &#x3D; item.map((val) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      id: val.id,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      name: val.name</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  return &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: node,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    students: subItem</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(subTarget)</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>實作 React 購物車</title>
    <url>/2020/05/11/react/shopping-cart/</url>
    <content><![CDATA[<p>入門 React 的基礎知識後，開始嘗試實作一些功能，方便進一步理解 React 的應用。</p>
<a id="more"></a>
<h2 id="環境搭建"><a href="#環境搭建" class="headerlink" title="環境搭建"></a>環境搭建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx create-react-app react-store</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>入門 React</title>
    <url>/2020/05/10/react/basic/</url>
    <content><![CDATA[<p>客觀來說，個人沒有特別偏好使用 React，但因為 Vue 3.0 的走向會朝向函數式編程的趨勢，這點似乎會和 React 目前的境況不謀而合，因此算是透過學習 React 來提前為 Vue 3.0 預作準備。再者，和好友聊天之餘，對方也希望我能偶爾摸摸 React，盛情難卻之下，也算是學習契機。</p>
<a id="more"></a>
<h2 id="React-元素"><a href="#React-元素" class="headerlink" title="React 元素"></a>React 元素</h2><h3 id="屬性名稱"><a href="#屬性名稱" class="headerlink" title="屬性名稱"></a>屬性名稱</h3><p>一些 HTML 標籤的屬性名稱，原先是全小寫，但在 React 的環境下，若屬性為兩個單字，統一需要改為駝峰式名稱才能正常運作。譬如 <code>input</code> 標籤中 <code>readonly</code> =&gt; <code>readOnly</code>。</p>
<h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><p>部分 HTML 標籤使用的名稱會和 React 產生的元素出現衝突，最常見的就是 <code>class</code>、<code>for</code>，所以需要使用 React 規範的名稱，<code>class</code> =&gt; <code>className</code>、<code>for</code> =&gt; <code>htmlFor</code>。</p>
<h3 id="在-JS-中撰寫-CSS"><a href="#在-JS-中撰寫-CSS" class="headerlink" title="在 JS 中撰寫 CSS"></a>在 JS 中撰寫 CSS</h3><p>這邊還真的寫起來蠻卡的，和過往撰寫 css 的做法有一定差異，使用 style 物件包裹的方式來添加屬性的樣式，結尾自然也就改為 <code>,</code> 而非 <code>;</code>。css 的屬性名稱，如果原先用 <code>-</code> 隔開者，則改為駝峰式名稱。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const textArea &#x3D; React.createElement(&quot;input&quot;, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  style: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    color: &#39;blue&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    border: &#39;1px solid green&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    borderRadius: &#39;6px&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<h3 id="設定事件"><a href="#設定事件" class="headerlink" title="設定事件"></a>設定事件</h3><ul>
<li>寫法1<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const clickEvent &#x3D; () &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(&quot;arrow&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">const textArea &#x3D; React.createElement(&quot;input&quot;, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  onInput: clickEvent</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure></li>
<li>寫法2<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const textArea &#x3D; React.createElement(&quot;input&quot;, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  onInput: () &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(&quot;arrow&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="傳入多個元素"><a href="#傳入多個元素" class="headerlink" title="傳入多個元素"></a>傳入多個元素</h3><p>在 createElement 中第三個參數可以使用陣列形式呈現，這樣就能在畫面上渲染多個元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const item &#x3D; React.createElement(&#39;li&#39;, &#123;&#125;, &#39;第一項&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">const subItem &#x3D; React.createElement(&#39;li&#39;, &#123;&#125;, &#39;第二項&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">const target &#x3D; React.createElement(&#39;ul&#39;, &#123;&#125;, [</span></pre></td></tr><tr><td class="code"><pre><span class="line">  item,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  subItem</span></pre></td></tr><tr><td class="code"><pre><span class="line">])</span></pre></td></tr></table></figure>
<p>當元素過多時，這種 React.createElement 其實並不適合維護與開發，因此才會導入 JSX 語法來進行撰寫。</p>
<h2 id="JSX-語法"><a href="#JSX-語法" class="headerlink" title="JSX 語法"></a>JSX 語法</h2>]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>實作遊戲介紹網站(Nuxt.js &amp; Tailwind CSS)</title>
    <url>/2020/04/29/nuxt/video-game/</url>
    <content><![CDATA[<p>Tailwind CSS 是一個結合設計規範的 UI Framework，近年在海外的社群極速竄紅，相較於 BootStrap 之類框架，它更像是先和設計師約定好預期的設計內容，並據此設定好變數，方便後續調用。恰好它也是 Nuxt.js 官方預設腳手架中的 UI 框架之一，因此來練習實作看看。</p>
<a id="more"></a>]]></content>
      <tags>
        <tag>Nuxt.js</tag>
        <tag>Tailwind CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>關於 Parcel：基礎實作</title>
    <url>/2020/04/21/parcel/</url>
    <content><![CDATA[<p>Parcel 相較於 webpack 是更新的打包工具，主打兩大賣點，設定簡化 &amp; 打包快速。恰好，最近想幫朋友寫一些簡單的 Landing Page，所以來嘗試 Parcel。</p>
<a id="more"></a>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><ul>
<li><a href="https://chihting.netlify.app/" target="_blank" rel="noopener">Landing Page 連結</a></li>
</ul>
<p>寫在前面，簡單應用一下 Parcel 這個新的打包工具，實作一個 RWD 的單頁 Landing Page。</p>
<p>第一次嘗試套用 video tag 應用在 background，但效能實在不太好，頁面進入後，從靜態頁面到完成讀取轉為動態影片，需要花不少時間。後續找時間來優化一下效能，看看能不能讓影片讀取速度更快。</p>
<h3 id="global-install"><a href="#global-install" class="headerlink" title="global install"></a>global install</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn global add parcel-bundler</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># or</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">npm install -g parcel-bundler</span></pre></td></tr></table></figure>

<h3 id="local-install"><a href="#local-install" class="headerlink" title="local install"></a>local install</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir project-name</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">cd project</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn init</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add parcel-bundler --dev</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># or</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">npm install parcel-bundler --save-dev</span></pre></td></tr></table></figure>
<h4 id="package-json-scripts-setting"><a href="#package-json-scripts-setting" class="headerlink" title="package.json scripts setting"></a>package.json scripts setting</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; --open &#x3D;&gt; auto open browser</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &quot;scripts&quot;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;dev&quot;: &quot;parcel src&#x2F;index.pug --open&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;build&quot;: &quot;parcel build src&#x2F;index.pug&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="test-run"><a href="#test-run" class="headerlink" title="test run"></a>test run</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn dev &#x3D;&gt; 檢查頁面有無正常開啟</span></pre></td></tr></table></figure>

<h3 id="SCSS"><a href="#SCSS" class="headerlink" title="SCSS"></a>SCSS</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add -D sass</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># or</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">npm install -D sass</span></pre></td></tr></table></figure>
<h4 id="資料結構"><a href="#資料結構" class="headerlink" title="資料結構"></a>資料結構</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- src</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - scss</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - style.scss</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - color.scss</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - js</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - index.js</span></pre></td></tr><tr><td class="code"><pre><span class="line">- index.pug</span></pre></td></tr></table></figure>
<p>引用方式，將共用 color 或後續的共用函數，透過 @import 載入 style.scss，再把 style.scss 註冊到 index.js。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#39;..&#x2F;scss&#x2F;style.scss&#39;</span></pre></td></tr></table></figure>

<h3 id="PostCSS-處理前綴詞"><a href="#PostCSS-處理前綴詞" class="headerlink" title="PostCSS 處理前綴詞"></a>PostCSS 處理前綴詞</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; mkdir .postcssrc</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">project</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - src</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - .postcssrc</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; content</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &quot;plugins&quot;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;autoprefixer&quot;: true</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; install commend</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn add -D autoprefixer</span></pre></td></tr></table></figure>

<h4 id="支援版本"><a href="#支援版本" class="headerlink" title="支援版本"></a>支援版本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; mkdir .browserslistrc</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">project</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - src</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - .browserslistrc</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; content</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">last 4 versions</span></pre></td></tr></table></figure>

<h3 id="集成-jQuery"><a href="#集成-jQuery" class="headerlink" title="集成 jQuery"></a>集成 jQuery</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; install commend</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn add jquery</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import $ from &#39;jquery&#39;</span></pre></td></tr></table></figure>

<h3 id="集成-Bootstrap"><a href="#集成-Bootstrap" class="headerlink" title="集成 Bootstrap"></a>集成 Bootstrap</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; install commend</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn add bootstrap</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; style.scss</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@import &quot;~bootstrap&#x2F;scss&#x2F;bootstrap&quot;;</span></pre></td></tr></table></figure>

<h3 id="Clear-old-data-dist"><a href="#Clear-old-data-dist" class="headerlink" title="Clear old data(dist)"></a>Clear old data(dist)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; plugins</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn add -D parcel-plugin-clean-dist</span></pre></td></tr></table></figure>
<p>運行前會清除一次 dist</p>
<h3 id="調整生產模式路徑-build"><a href="#調整生產模式路徑-build" class="headerlink" title="調整生產模式路徑(build)"></a>調整生產模式路徑(build)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &quot;scripts&quot;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;build&quot;: &quot;parcel build src&#x2F;index.pug --public-url .&#x2F;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>避免打包出來的路徑出現錯誤</p>
]]></content>
      <tags>
        <tag>Parcel</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 設定與理解</title>
    <url>/2020/04/15/webpack-config/</url>
    <content><![CDATA[<p>雖然到 vue-cli 3.0 之後，其實 vue 官方已經將 webpack 進行封裝，希望開發者專注在開發而非設定上，但還是需要理解基本的設定，以及細節的理解。</p>
<a id="more"></a>
<h3 id="模組化"><a href="#模組化" class="headerlink" title="模組化"></a>模組化</h3><p>現代開發專案的複雜度，容易面臨維護上的不易。為了更有效的管理專案開發，模塊化、組件化的思想蔚為風潮，而在 Node.js 中模塊化的思想自然也是重中之重。require 引入 &amp; module.exports 導出，被頻繁用來抽換模塊。但對瀏覽器來說，原生不支援這種 CommonJS 標準，所以我們仰賴 webpack 這種工具將程式碼進行打包(類似早期的 browserify)。同時 webpack 已經預先將 babel 此類工具封裝好，在處理 ES6 之類的語法時，會自動進行轉換，可以讓我們省下不少工。</p>
<h3 id="使用-webpack-的理由？"><a href="#使用-webpack-的理由？" class="headerlink" title="使用 webpack 的理由？"></a>使用 webpack 的理由？</h3><ol>
<li>透過 webpack 幫助我們針對檔案進行壓縮(uglify)和輕量化(minify)。</li>
<li>圖片或 CSS 都能以資源的方式引入。</li>
<li>如果想要安裝 npm 上的第三方套件，會更為輕鬆容易。</li>
</ol>
<h3 id="常用的-loader-有哪些？"><a href="#常用的-loader-有哪些？" class="headerlink" title="常用的 loader 有哪些？"></a>常用的 loader 有哪些？</h3><ul>
<li>樣式類：style-loader、css-loader、sass-loader</li>
<li>自動編譯：babel-loader、ts-loader</li>
<li>文件相關：raw-loader、file-loader、url-loader</li>
<li>自動測試或書寫規範：eslint-loader、jshint-loader、mocha-loader<br>e.g.：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; sass-loader &#x3D;&gt; 將 sass 轉為 css</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; css-loader &#x3D;&gt; 解析並處理 @import || url() 的用法</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; style-loader &#x3D;&gt; 協助建立 style 標籤，並將 css 檔案載入到 html</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  module: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    rules: [</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          test: &#x2F;\.scss$&#x2F;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          use:[</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#123;loader:&#39;style-loader&#39;&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#123;loader:&#39;css-loader&#39;,options:&#123;sourceMap:true,modules:true&#125;&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#123;loader:&#39;sass-loader&#39;,options:&#123;sourceMap:true&#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">          exclude:&#x2F;node_modules&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="有使用過哪些插件？"><a href="#有使用過哪些插件？" class="headerlink" title="有使用過哪些插件？"></a>有使用過哪些插件？</h3><p>許多常用的 plugins 都已被 cli 腳手架封裝進去，譬如自動壓縮程式碼 UglifyJsPlugin，即時熱更新 HotModuleReplacementPlugin。</p>
<h4 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h4><p>因為可以在編譯改變全域的變數，因此可以修改設定來達到生產環境和開發環境的差異，但我目前還沒實際設定過。</p>
<h4 id="IgnorePlugin"><a href="#IgnorePlugin" class="headerlink" title="IgnorePlugin"></a>IgnorePlugin</h4><p>可以用於忽略特定的模塊或文件，例如特定較大的 library，可能需要在打包時進行忽略，進而縮減專案體積。</p>
<!-- ### module chunk bundle 差別
- module
  - 在 webpack 當中，一切都是模組，module 等同於源碼文件 -->

<h3 id="所以為何要使用-build？"><a href="#所以為何要使用-build？" class="headerlink" title="所以為何要使用 build？"></a>所以為何要使用 build？</h3><p>承前面的問題，透過這一類的打包工具(gulp || webpack)，來進行打包優化，並將程式碼轉為瀏覽器可以理解並支援的語法，如此才能在瀏覽器上運行。</p>
<h3 id="vue-config-js"><a href="#vue-config-js" class="headerlink" title="vue.config.js"></a>vue.config.js</h3><h4 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h4><p>只要專案內有設定二級 router，就必須設定 publicPath，但除非你希望調整 url 出現的路徑，否則一般都使用 <code>/</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 寫在 module.exports 內任一處即可</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  publicPath: &#39;&#x2F;&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="outputDir"><a href="#outputDir" class="headerlink" title="outputDir"></a>outputDir</h4><p>設定 Vue 打包後的資料，要生成到那個資料夾內，可任意改成你想要的資料夾名稱，預設為 dist：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  publicPath: &#39;&#x2F;&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  outputDir: &#39;dist&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="indexPath"><a href="#indexPath" class="headerlink" title="indexPath"></a>indexPath</h4><p>指定打包後生成的 html 檔案名稱，無需特別變動。</p>
<h4 id="filenameHashing"><a href="#filenameHashing" class="headerlink" title="filenameHashing"></a>filenameHashing</h4><p>瀏覽器基本上都會有緩存的問題，所以如果都是同一個檔案名的狀況下，譬如都是 app.js，那假定我更新一個版本，結果瀏覽器緩存，導致它拉到 app.js 是上一個版本，那就尷尬了。所以透過 hash 的方式，來生成獨一無二的檔案名，避免被緩存卡住，預設為 true，不需要調整。</p>
<h4 id="lintOnSave"><a href="#lintOnSave" class="headerlink" title="lintOnSave"></a>lintOnSave</h4><p>檢查 code 有沒有符合 eslint 規範，預設開啟，但也不需要特別調整，畢竟現在開發都會遵循 eslint，至於採用哪種風格，則是依照團隊 coding style。</p>
<h4 id="chainWebpack"><a href="#chainWebpack" class="headerlink" title="chainWebpack"></a>chainWebpack</h4><p>根據自己的需求，進行客製化調整，譬如希望修改網頁上方標題：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chainWebpack: (config) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  config</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .plugin(&#39;html&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .tap((args) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      args[0].title &#x3D; &#39;Tiger Coding Blog&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      return args</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue &amp; React 簡單的對比</title>
    <url>/2020/04/15/vue-react-compare/</url>
    <content><![CDATA[<p>雖然還沒有實務上開發 React 的經驗，但還是可以先簡單理解一下，這兩個框架間的差異與雷同處。</p>
<a id="more"></a>
<h3 id="兩個框架的相同處"><a href="#兩個框架的相同處" class="headerlink" title="兩個框架的相同處"></a>兩個框架的相同處</h3><ol>
<li>現代前端開發基本上，都是組件化的形式，所以本質上都是由 component 所組成，自然也都是支持組件化。</li>
<li>再者，兩個都是 MVVM 框架，所以也都是透過數據變化，進而重新渲染畫面。</li>
<li>都使用虛擬 DOM(vdom) 來操作 DOM。</li>
</ol>
<h3 id="語法差異"><a href="#語法差異" class="headerlink" title="語法差異"></a>語法差異</h3><ul>
<li><p>React</p>
<ul>
<li>使用 JSX 語法來撰寫 JS</li>
<li>React 本質上就是在寫 JS，只是透過 JSX 這種類似語法糖來寫(副檔名自然也都是 .js)</li>
<li>React 相對來說，會更為自由，但框架本身提供的幫助就比較少，需要靠開發者自力更生去實現功能</li>
<li>舉裡來說，如果要循環一組 array，React 這邊必須使用 JS 操作陣列的方式</li>
</ul>
</li>
<li><p>Vue</p>
<ul>
<li>透過 template 來呈現 html</li>
<li>vue 會更像是寫一個獨立的語法，需要遵循一定的官方書寫規則</li>
<li>vue 的官方則是提前準備一些可能的開發情境，或是需要的語法，方便開發者直接使用，而不需要自己處理</li>
<li>同樣是循環陣列，vue 就提供了 v-for 可以快速上手</li>
</ul>
</li>
<li><p>客觀來說，我確實比較喜歡 Vue 的 template，可能受限於我個人對讀 code 的速度，vue 等於是將邏輯和畫面視圖的部分進行拆分。但 JSX 會將邏輯和視圖耦合在一起，如果寫得太自由的話，後面的維護者可能會不理解前一個開發者在寫什麼。</p>
</li>
</ul>
<h3 id="函數式編程"><a href="#函數式編程" class="headerlink" title="函數式編程"></a>函數式編程</h3><p>React 本身就是函數式編程，這不需多言。比較需要注意的是，Vue 預期在 3.0 的版本中，也要將 JS 的部分採用函數式編程，除了寫法上有所改變，component 的編寫也會更加靈活(官方說法)，但具體如何使用，等未來摸到時，才能有更細節的理解。</p>
]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>實作 Blog 前後台(BootstrapVue &amp; Firebase)</title>
    <url>/2020/04/13/vue-firebase-blog/</url>
    <content><![CDATA[<p>沒有使用過 UI Framework 來實作，先嘗試套一個 BootstrapVue 來練習，選擇這個框架的原因，是因為 Bootstrap 依然是蠻多網站的選擇，如果有需要維護同類型的產品，銜接起來相對容易。但是單純的 component 應用就不做記錄了，僅記錄之前未使用過，或是自己少用的用法。</p>
<a id="more"></a>
<ul>
<li><a href="https://bootstrap-vue.js.org/docs" target="_blank" rel="noopener">BootstrapVue 官網</a></li>
</ul>
<h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add vue bootstrap-vue bootstrap</span></pre></td></tr></table></figure>

<h3 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h3><ul>
<li>註冊到 main.js<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; BootstrapVue, IconsPlugin &#125; from &#39;bootstrap-vue&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; styles</span></pre></td></tr><tr><td class="code"><pre><span class="line">import &#39;bootstrap&#x2F;dist&#x2F;css&#x2F;bootstrap.css&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import &#39;bootstrap-vue&#x2F;dist&#x2F;bootstrap-vue.css&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Vue.use(BootstrapVue)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Vue.use(IconsPlugin)</span></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p>之前工作採用 axios 套件，但現在 JS 原生語法中已經提供 fetch() 的用法了，而且 fetch 的好處是預設用 promise 包裹，如果有需要就可以直接使用 async/await。而且檢查 can i use，fetch 目前來看兼容性也已經相當高了，所以這個專案開始改用 fetch。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fetch(url).then((res) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; 回傳的檔案若為 JSON 格式，需要解析處理</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return res.json()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;).then((result) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(result)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  this.articleData &#x3D; result.data</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;).catch((err) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Firebase</tag>
        <tag>BootstrapVue</tag>
      </tags>
  </entry>
  <entry>
    <title>Nuxt.js 實作 Blog</title>
    <url>/2020/04/02/nuxt/blog/</url>
    <content><![CDATA[<p>寫在前面，為了理解 Nuxt 的基礎運用，動手實作一個簡易的 Blog，同時記錄下目前的流程，方便後續可以參照比對。</p>
<a id="more"></a>
<p>受限於目前還未掌握 Node 開發後端的能力，因此直接採用官方建議的 CMS 系統(storyblok)。不過樣式就不特別處理，簡單的 RWD。另外渲染 markdown 的部分，v-html 要改的樣式太多，只能以後有時間再來慢慢處理。部署仍是萬年的 netlify 不變。</p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><ul>
<li><a href="https://activello-nuxt-blog.netlify.com/" target="_blank" rel="noopener">Nuxt.js Blog 連結</a></li>
</ul>
<p>待優化的部分：</p>
<ul>
<li>API 呼叫等待時間，加入 Loading 樣式</li>
<li>關於 nuxt store 的部分還沒觸碰</li>
<li>專案複雜度太低，仍有許多潛在的雷點還未踩到</li>
<li>nuxt 的基礎是 node，除了補強 node 知識，可能要考慮用 node 實作後端</li>
<li>高交互的頁面，可能會需要掌握多種 layout</li>
</ul>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx create-nuxt-app nuxt-blog</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">cd nuxt-blog</span></pre></td></tr></table></figure>
<p>除了 axios 其他都採用預設默認。</p>
<h3 id="install-plugin"><a href="#install-plugin" class="headerlink" title="install plugin"></a>install plugin</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; pug</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn add pug pug-plain-loader</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; scss</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn add node-sass sass-loader</span></pre></td></tr></table></figure>
<p>run 一下測試是否正常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn run dev</span></pre></td></tr></table></figure>

<h3 id="架構設計"><a href="#架構設計" class="headerlink" title="架構設計"></a>架構設計</h3><ul>
<li>共用樣式統一由 assets 控管。</li>
<li>盡可能多使用 html5 語義化標籤。</li>
</ul>
<h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><ul>
<li>因為功能相對較少，僅採用 default layout，主體拆成三個區塊，header、main(nuxt)、footer。</li>
<li>HomePage 的文章列表抽成 component 形式。</li>
</ul>
<h3 id="nuxt-link"><a href="#nuxt-link" class="headerlink" title="nuxt-link"></a>nuxt-link</h3><ul>
<li>active 樣式使用官方預設的 class =&gt; .nuxt-link-exact-active</li>
</ul>
<h3 id="Headless-CMS"><a href="#Headless-CMS" class="headerlink" title="Headless CMS"></a>Headless CMS</h3><ul>
<li>先試用 storyblok，未來再試試看 Strapi</li>
<li>本地安裝對應套件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add storyblok-nuxt</span></pre></td></tr></table></figure></li>
<li>引入格式：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modules: [</span></pre></td></tr><tr><td class="code"><pre><span class="line">  [&#39;storyblok-nuxt&#39;, &#123; accessToken: &#39;xxxxxxxxx&#39;, cacheProvider: &#39;memory&#39; &#125;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">],</span></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="asyncData"><a href="#asyncData" class="headerlink" title="asyncData()"></a>asyncData()</h3><p>在 MVC 架構下，網站的運作是由前端向後端發出請求，拿到頁面的 url 的同時，也由後端 return html 給前端。但到了 MVVM 架構下，router 改由前端處理，後端只負責給數據，頁面的渲染生成統一由前端負責，也因此爬蟲這種基於 server 端的技術，無法抓到頁面，也就無法達到 SEO 的效果。nuxt 中的 asyncData() 可以理解為在後端做處理，因為是在 server 端所以也不存在跨域問題。</p>
<h3 id="動態-router"><a href="#動態-router" class="headerlink" title="動態 router"></a>動態 router</h3><p>nuxt 的動態路由，需透過 _ 下底線來自動生成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- pages</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - _postId</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; &#x3D;&gt; &#x2F;:postId</span></pre></td></tr></table></figure>

<h3 id="解析-markdown-格式"><a href="#解析-markdown-格式" class="headerlink" title="解析 markdown 格式"></a>解析 markdown 格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add marked</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import marked from &#39;marked&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">marked(res.data.story.content.content)</span></pre></td></tr></table></figure>

<h3 id="v-html-style"><a href="#v-html-style" class="headerlink" title="v-html style"></a>v-html style</h3><p>在 scoped 屬性下，v-html 無法直接修改樣式，但如果移除 scoped 可能會污染全域樣式，除了透過特殊命名外，還有一種方法可以修改樣式，就是透過 deep scoped，而且也不會影響到全域，寫法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.post-content &#x2F;deep&#x2F; pre &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  background-color: #f7f7f7;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">.post-content &#x2F;deep&#x2F; h2,h3 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  margin: 8px 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="fetch-API"><a href="#fetch-API" class="headerlink" title="fetch API"></a>fetch API</h3><p>同 asyncData，因為他們都是在組件初始化之前就已經執行的方法，這個時候 this 是無法指向我們需要的對象，會導致無法取得值，因此 fetch api 在 nuxt 中不可以使用 this。</p>
<h3 id="component-name"><a href="#component-name" class="headerlink" title="component name"></a>component name</h3><p>組件名稱通常是方便我們使用 chrome 插件的 vue dev tools 時，可以快速查詢，但和 Vue 不同，nuxt 預設的 eslint 規則中，名稱首字必須大寫。</p>
<h3 id="Nuxt-生命週期"><a href="#Nuxt-生命週期" class="headerlink" title="Nuxt 生命週期"></a>Nuxt 生命週期</h3><p>承前述，Nuxt 的 <a href="https://zh.nuxtjs.org/guide/" target="_blank" rel="noopener">lifecycle</a> 如下：<br>起步進入 =&gt; </p>
<ol>
<li>檢查 Nuxt 專案內的 store(類似 Vuex)是否有需要執行的內容</li>
<li>進入中間件(middleware)，並且做三件事，檢查全域設定(nuxt.config.js)，在檢查配對的 Layout，配對要進入的頁面</li>
<li>驗證進入的頁面是否存在，是 =&gt; 進入該頁面，否 =&gt; 轉往 404 頁面</li>
<li>初始化之前，先將 server端 資料取回</li>
<li>開始渲染頁面</li>
</ol>
<p>當點擊前往其他頁面時，重新回到第二步開始執行</p>
]]></content>
      <tags>
        <tag>Nuxt.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Nuxt.js II - 框架基礎觀念</title>
    <url>/2020/03/22/nuxt/basic-II/</url>
    <content><![CDATA[<p>記錄 Nuxt 專案開發與框架基礎觀念。</p>
<a id="more"></a>
<h2 id="Nuxt-js-的注意事項"><a href="#Nuxt-js-的注意事項" class="headerlink" title="Nuxt.js 的注意事項"></a>Nuxt.js 的注意事項</h2><p>Nuxt =&gt; 基底語法以 node.js 為主，因此 node 不支援的語法，在 Nuxt 中也無法運作。</p>
<ol>
<li>Nuxt 的 <code>created()</code> =&gt; 不可使用 window、alert、document 等原生屬性。<ul>
<li>node.js 本身是在 server 端環境運行，而非瀏覽器，自然吃不到瀏覽器的屬性</li>
</ul>
</li>
<li>Nuxt =&gt; 基底語法以 node.js 為主，因此 node 不支援的語法，即便是 Vue 的語法也不可行。</li>
<li>需優先考慮 node 的執行環境。</li>
</ol>
<h3 id="Router-路徑"><a href="#Router-路徑" class="headerlink" title="Router 路徑"></a>Router 路徑</h3><p>Nuxt 本身已經封裝了許多 Vue-cli 功能，譬如 router 本身在 Vue 需要設置，但在 Nuxt 只要建立好頁面，router 就會自動匹配。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>同 Vue 相同，Nuxt 也是採用 shorthand：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  formatter () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="install-scss"><a href="#install-scss" class="headerlink" title="install scss"></a>install scss</h2><p>在 Nuxt 環境中，<code>~</code>、<code>@</code>兩者皆通用，都被指向根目錄。但非 nuxt 結構的 js 檔與 nuxt.config.js 則不吃這個規則，必須使用過往的<code>./</code>尋找。</p>
<ul>
<li>install plugin<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; pug</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn add pug pug-plain-loader</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; scss</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn add node-sass sass-loader</span></pre></td></tr></table></figure>
但是放在靜態資源(static)內的引用規則稍有不同，僅透過<code>/</code>，e.g.：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">link: [</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123; rel: &#39;icon&#39;, type: &#39;image&#x2F;x-icon&#39;, href: &#39;&#x2F;favicon.ico&#39; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">]</span></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="nuxt-config-js-設定"><a href="#nuxt-config-js-設定" class="headerlink" title="nuxt.config.js 設定"></a>nuxt.config.js 設定</h2><ul>
<li><p>head<br>就是過往 HTML 頁面的 head 區塊，可以調整頁面的 title，或是添加 meta 來改善 SEO。需要稍微注意 static 靜態資源的飲用路徑略有不同僅<code>/</code>。</p>
</li>
<li><p>css<br>可以註冊全域 css，方便整個專案調用。</p>
</li>
</ul>
<h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><ul>
<li><p>nuxt 在 css 的環境中，使用 background 載入圖片時，不允許使用 <code>/</code>，正確寫法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background: url(&quot;~assets&#x2F;images&#x2F;girl.jpg&quot;) no-repeat;</span></pre></td></tr></table></figure>
<p>這邊也無法用 @ 來載入，唯一只能使用 <code>~</code>。</p>
</li>
<li><p>預設若圖片小於 1KB，會被 nuxt 轉為 base 64 編碼，使用 data uri 的形式引入。若需要調整上下限，可以在 nuxt.config.js 中的 build 進行調整。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">build: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  loaders: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    imgUrl: &#123; limit: 10000 &#125; &#x2F;&#x2F; 1000 &#x3D;&gt; 1KB</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="頁面結構"><a href="#頁面結構" class="headerlink" title="頁面結構"></a>頁面結構</h2><p>nuxt 和 vue 相似，router 對應要前往的頁面，且不需要我們來配置，而每個 page 則可以根據需要的 layout 來進行設定，再彙整到 <nuxt />，原理和 vue 的 router-view 雷同。</p>
<p>每個 page 預設父層 layout 直接使用 default.vue，但如果需要客製化，可以根據需求加入不同的 xxx.vue，再到需要的 page 從 export default 導入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">export default &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  layout: &#39;xxx&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;script&gt;</span></pre></td></tr></table></figure>

<h2 id="錯誤頁面"><a href="#錯誤頁面" class="headerlink" title="錯誤頁面"></a>錯誤頁面</h2><p>根據 nuxt 官方的設定，在 layouts 下建立 error.vue，即可攔截錯誤 router，如果需要自定義頁面，同樣可以加入客製化 layout。</p>
<h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><p>在 nuxt.config.js，有全域的 head，但如果特定頁面需要調整 head，可以在 page 下的 export default 中放入 head 的格式，但需要注意改為 function 的寫法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  layout: &#39;xxx&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  head () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      title: this.title,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      meta: [],</span></pre></td></tr><tr><td class="code"><pre><span class="line">      script: []</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="nuxt-link"><a href="#nuxt-link" class="headerlink" title="nuxt-link"></a>nuxt-link</h2><p>和 vue 的 router-link 本質相同，需要特別注意的是，nuxt-link 會提前先幫你預先載入好要連過去頁面的 css 資源。但如果該頁面有大量圖片或是樣式，可能會影響到 loading 速度，如果要關閉這個功能，寫法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; pug 寫法</span></pre></td></tr><tr><td class="code"><pre><span class="line">nuxt-link(to&#x3D;&quot;&#x2F;demo&quot; no-prefetch)</span></pre></td></tr></table></figure>

<h2 id="components"><a href="#components" class="headerlink" title="components"></a>components</h2><p>nuxt 的 component 有一些特點需要注意，在 nuxt 的 .vue 檔案中允許導入 head、asyncData，但這些寫法在 component 中的 .vue 是不允許的，只能寫在 pages 內的 .vue。命名規則上，官方採用開頭大寫書寫格式，但實際上可依團隊 coding style。</p>
]]></content>
      <tags>
        <tag>Nuxt.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Nuxt.js I - 架站與手動部署(GCP)</title>
    <url>/2020/03/21/nuxt/basic-I/</url>
    <content><![CDATA[<p>記錄 Nuxt 前期架站準備工作。</p>
<a id="more"></a>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ol>
<li>node =&gt; 已使用 nvm 管理安裝版本。</li>
<li>git =&gt; homebrew 已安裝。</li>
<li>GitLab 帳號已申請。</li>
</ol>
<h2 id="關於-Nuxt-js"><a href="#關於-Nuxt-js" class="headerlink" title="關於 Nuxt.js"></a>關於 Nuxt.js</h2><ul>
<li>優點<ul>
<li>核心要解決 SPA 網站的 SEO 問題</li>
<li>對於個人開發者來說，如果熟悉 Node.js 可以將前後端整合在同一專案</li>
<li>促使前端可以處理一部分後端功能，例如緩存資料之類的，使 API 負擔減輕</li>
<li>Nuxt.js 可以多做一層轉發關於安全性的資訊，對網站安全較佳</li>
</ul>
</li>
<li>缺點<ul>
<li>沒有 SEO 需求的網站，基本不需要使用 Nuxt.js(例如後台)</li>
<li>學習 Nuxt.js 需要理解部分後端原理知識，學習成本高</li>
<li>開發難度增加，Server 的負擔也會變重</li>
</ul>
</li>
</ul>
<h2 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h2><ul>
<li>GitLab create new project</li>
<li>install(這邊嘗試使用 npx)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx create-nuxt-app project-name</span></pre></td></tr></table></figure></li>
<li>連接上遠端 repository<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init &#x3D;&gt; 通常現在腳手架工具都會處理好，可省略</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 按照 GitLab 步驟執行</span></pre></td></tr><tr><td class="code"><pre><span class="line">1. git remote add origin https:&#x2F;&#x2F;gitlab.com&#x2F;xxx</span></pre></td></tr><tr><td class="code"><pre><span class="line">2. git add.</span></pre></td></tr><tr><td class="code"><pre><span class="line">3. git commit -m &#39;initial commit&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">4. git branch develop</span></pre></td></tr><tr><td class="code"><pre><span class="line">5. git push -u origin develop</span></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Push-Error"><a href="#Push-Error" class="headerlink" title="Push Error"></a>Push Error</h3><p>這邊在 push branch 到 GitLab 時遇到一個問題，狀況如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GitLab: The project you were looking for could not be found.</span></pre></td></tr><tr><td class="code"><pre><span class="line">fatal: Could not read from remote repository.</span></pre></td></tr></table></figure>
<p>遠端的 GitLab 找不到我的 repository 位置，這邊會出現兩種可能，第一是還沒加入 SSH Key，第二是 SSH Key 正確，但需要重新更換遠端的名稱，首先輸入下面的指令，檢查本機公鑰有沒有正常加入 GitLab：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@gitlab.com</span></pre></td></tr></table></figure>
<p>如果出現 <code>Permission Denied (publickey)</code> 那就需要執行生成 SSH Key，並將公鑰加入 GitLab。</p>
<ol>
<li>生成 SSH Key：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;YOUR EMAIL&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">cd ~&#x2F;.ssh&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意生成過程中，會要求設定私人密碼，需要自己記住</span></pre></td></tr></table></figure></li>
<li>進入 ssh 底下，會看到兩個新的檔案：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id_rsa &#x3D;&gt; 私鑰</span></pre></td></tr><tr><td class="code"><pre><span class="line">id_rsa.pub &#x3D;&gt; 公鑰 &#x2F;&#x2F; 使用 vscode 將公鑰的檔案打開，複製裡面的內容</span></pre></td></tr></table></figure></li>
<li>回到 GitLab，操作路徑：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">點選右上角圖像&#x2F;setting&#x2F;左側 SSH Keys</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 將剛剛複製的內容貼到中間的輸入框，並點擊下方的 add key</span></pre></td></tr></table></figure></li>
<li>回到終端機，再次輸入<code>ssh -T git@gitlab.com</code>，這時會要求你輸入剛剛設定的私人密碼，成功後應該會看下面的文字：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome to GitLab, @Your_name!</span></pre></td></tr></table></figure>
到這邊第一步設定 SSH Keys 完成，但我嘗試重新 push 一次依然失敗：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">remote: The project you were looking for could not be found.</span></pre></td></tr><tr><td class="code"><pre><span class="line">fatal: repository &#39;https:&#x2F;&#x2F;gitlab.com&#x2F;Your_name&#x2F;Your_project.git&#x2F;&#39; not found</span></pre></td></tr></table></figure></li>
<li>重新更新並配對一次遠端名稱：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote rename origin old-origin</span></pre></td></tr><tr><td class="code"><pre><span class="line">git remote add origin git@gitlab.com:Your_name&#x2F;Your_project.git</span></pre></td></tr></table></figure>
到此，檔案就能正常推送到遠端了。</li>
</ol>
<h2 id="架站與部署"><a href="#架站與部署" class="headerlink" title="架站與部署"></a>架站與部署</h2><ol>
<li>建立 GCP 帳號</li>
<li>操作路徑：左側 menu/Computer Engine/VM 執行個體/建立</li>
<li>機器類型 =&gt; g1-small(小型專案)</li>
<li>開機磁碟 =&gt; Ubuntu 18.04 LTS</li>
<li>防火牆 =&gt; 允許 HTTP 流量、允許 HTTPS 流量</li>
</ol>
<h2 id="登入-Linux-主機"><a href="#登入-Linux-主機" class="headerlink" title="登入 Linux 主機"></a>登入 Linux 主機</h2><ul>
<li>google gcp 瀏覽器介面登入<br>打開 gcp 專案，專案右側有一個 dropdown 連接 ssh，點擊打開下拉選單，選擇在瀏覽視窗中開啟。</li>
<li>操作指令<br>大多和 mac 的操作相同，記錄比較少用的指令：<br>下載 url 上的檔案<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget (網址路徑)</span></pre></td></tr></table></figure>
刪除資料<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm (檔案名稱)</span></pre></td></tr></table></figure>
刪除資料夾<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -r (資料名稱)</span></pre></td></tr></table></figure>
複製文件到指定路徑<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp 檔案名稱 欲加入的檔案名稱</span></pre></td></tr></table></figure>
複製資料夾<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp -r a b</span></pre></td></tr></table></figure>
建立檔案<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch 檔案名稱</span></pre></td></tr></table></figure>
查看系統記憶體<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free -h</span></pre></td></tr></table></figure>
登出 Linux<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit</span></pre></td></tr></table></figure>
重開機 Linux<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo reboot</span></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="PM2"><a href="#PM2" class="headerlink" title="PM2"></a>PM2</h2><p>一個開源的 Node.js 流程管理器，重開機可以自動重啟 Node，另外也能針對 cpu 進行負載均衡設定。Nuxt 需安裝 nuxt-start 套件來搭配使用 pm2。</p>
<ul>
<li>install pm2<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install pm2 -g</span></pre></td></tr><tr><td class="code"><pre><span class="line">or</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn global add pm2</span></pre></td></tr></table></figure></li>
<li>install nuxt-start<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install nuxt-start</span></pre></td></tr><tr><td class="code"><pre><span class="line">or</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn add nuxt-start</span></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="使用-PM2-架設-Nuxt-站台-本地"><a href="#使用-PM2-架設-Nuxt-站台-本地" class="headerlink" title="使用 PM2 架設 Nuxt 站台(本地)"></a>使用 PM2 架設 Nuxt 站台(本地)</h2><ul>
<li>生產環境</li>
</ul>
<ol>
<li>pm2 init =&gt; 初始化，產生 ecosystem.config.js<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  apps:[&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: &#39;project_name&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    script: &#39;.&#x2F;node_modules&#x2F;nuxt-start&#x2F;bin&#x2F;nuxt-start.js&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    instances: &#39;max&#39;, &#x2F;&#x2F; 負載平衡模式下的 cpu 數量</span></pre></td></tr><tr><td class="code"><pre><span class="line">    exec_mode: &#39;cluster&#39;, &#x2F;&#x2F; 負載平衡模式</span></pre></td></tr><tr><td class="code"><pre><span class="line">    max_memory_restart: &#39;1G&#39;, &#x2F;&#x2F; 緩存了多少記憶體重新整理</span></pre></td></tr><tr><td class="code"><pre><span class="line">    port: 3001 &#x2F;&#x2F; 指定伺服器上的 port </span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li>
<li>yarn run build</li>
<li>pm2 start =&gt; 啟用 ecosystem.config.js 的內容</li>
</ol>
<h2 id="pm2-指令"><a href="#pm2-指令" class="headerlink" title="pm2 指令"></a>pm2 指令</h2><p>啟動 pm2 =&gt; ecosystem.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 start</span></pre></td></tr></table></figure>
<p>查看目前的 server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 list</span></pre></td></tr></table></figure>
<p>停用全部 server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 stop all</span></pre></td></tr></table></figure>
<p>刪除指定 ID 的 server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 delete 4</span></pre></td></tr></table></figure>
<p>刪除全部 server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 delete all</span></pre></td></tr></table></figure>
<p>重新整理所有 server =&gt; 使用情境，git pull 後需重新整理 server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 reload all</span></pre></td></tr></table></figure>
<p>儲存目前的 pm2 server，重開機後會還原</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 save</span></pre></td></tr></table></figure>
<p>檢查 pm2 錯誤(使用 log 排查)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 log</span></pre></td></tr></table></figure>

<ul>
<li>pm2 容易被快取卡住，這時候必須砍掉重新安裝 pm2<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall pm2 -g</span></pre></td></tr><tr><td class="code"><pre><span class="line">~&#x2F;.pm2   &#x3D;&gt; 這個要整個砍掉(不然會被快取)</span></pre></td></tr><tr><td class="code"><pre><span class="line">npm install pm2 -g</span></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="GCP-Linux-主機安裝環境-server"><a href="#GCP-Linux-主機安裝環境-server" class="headerlink" title="GCP Linux 主機安裝環境(server)"></a>GCP Linux 主機安裝環境(server)</h2><ol>
<li>install node.js<ul>
<li>install nvm<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -qO- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;nvm-sh&#x2F;nvm&#x2F;v0.35.3&#x2F;install.sh | bash</span></pre></td></tr></table></figure></li>
<li>安裝後，為了要生效 nvm，需要重新啟動終端機</li>
<li>nvm ls-remote =&gt; nvm install last-version</li>
</ul>
</li>
<li>install pm2<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install pm2 -g</span></pre></td></tr></table></figure>
pm2 目前會安裝在當前的node版本資料夾下，未來如果使用nvm切換node版本，會導致pm2失效。</li>
<li>install git<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo apt install git</span></pre></td></tr></table></figure></li>
<li>install nginx<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo apt install nginx</span></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="git-手動部署-遠端-Linux-操作"><a href="#git-手動部署-遠端-Linux-操作" class="headerlink" title="git 手動部署 + 遠端 Linux 操作"></a>git 手動部署 + 遠端 Linux 操作</h2><ul>
<li>先將 develop 分支進行 commit<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span></pre></td></tr><tr><td class="code"><pre><span class="line">git commit -m &#39;commit content&#39;</span></pre></td></tr></table></figure></li>
<li>切回 master 分支，再將 develop merge<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span></pre></td></tr><tr><td class="code"><pre><span class="line">git merge develop</span></pre></td></tr></table></figure></li>
<li>master 推送到 Gitlab<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span></pre></td></tr></table></figure></li>
<li>回到 gcp</li>
</ul>
<ol>
<li>瀏覽器打開 Linux 介面</li>
<li>git clone 專案(注意 gitlab 是否已先切回 master 分支)<ul>
<li>日後遠端 gitlab 專案若有更新(git pull 進行同步) =&gt; pm2 reload id</li>
</ul>
</li>
<li>cd 專案</li>
<li>npm install</li>
<li>npm run build</li>
<li>啟用 pm2 站台</li>
</ol>
<h2 id="網域設定-DNS"><a href="#網域設定-DNS" class="headerlink" title="網域設定 DNS"></a>網域設定 DNS</h2><ul>
<li>設定 A 記錄</li>
</ul>
<ol>
<li>前往任何網址商購買網址 =&gt; 這邊使用 godady</li>
<li>購買完成後，打開右上角的 My Products =&gt; 進入自己購買的網址</li>
<li>選擇要綁定的 Domain，點擊右方的 DNS 進入</li>
<li>選擇第一列的 A 記錄，右邊可以進行編輯</li>
<li>複製 gcp 專案的外部 IP，貼到指向欄位(Points to)</li>
<li>將 gcp 外部 IP 轉為靜態 =&gt; 左側選單/VPC網路/外部IP位址/調整類型</li>
</ol>
<h2 id="Nginx-反向代理設定"><a href="#Nginx-反向代理設定" class="headerlink" title="Nginx 反向代理設定"></a>Nginx 反向代理設定</h2><ul>
<li>nginx =&gt; 一種網頁伺服器，就是架設網頁的軟體，其他還有 IIS、Apache</li>
</ul>
<p>一般而言，node.js 為求提高效能，多會採用 nginx 來架站。</p>
<ol>
<li>node 使用 pm2 建立後，port 的設定不可低於1024，避免安全性問題。</li>
<li>架設 nginx server(nginx 監聽 80 port)</li>
<li>nginx 透過反向代理機制，將來源網址代理到 node 站台</li>
</ol>
<ul>
<li>nginx 指令</li>
</ul>
<ol>
<li>啟動 nginx server<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nginx</span></pre></td></tr></table></figure></li>
<li>重新整理 nginx server<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nginx -s reload</span></pre></td></tr></table></figure></li>
<li>快速停用 server<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nginx -s stop</span></pre></td></tr></table></figure></li>
<li>nginx 位置：/etc/nginx =&gt; 預設</li>
<li>檢查 nginx log<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx log</span></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="nginx-config-設定"><a href="#nginx-config-設定" class="headerlink" title="nginx config 設定"></a>nginx config 設定</h2><ul>
<li>第一個入口點 =&gt; nginx.conf</li>
<li>vi 編輯器 =&gt; 常見的是 vim，這邊使用 nano</li>
</ul>
<ol>
<li>sudo nano /etc/nginx/conf.d/pittwu.fun.conf</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  server_name pittwu.fun www.pittwu.fun;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  location &#x2F; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    proxy_pass http:&#x2F;&#x2F;localhost:3001;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="SSL-憑證"><a href="#SSL-憑證" class="headerlink" title="SSL 憑證"></a>SSL 憑證</h2><p>SSL For Free =&gt; 取得免費憑證(憑證機構：Let’s Encypt)，缺點每三個月會過期，為此 Linux 可以透過 certbot 來自動更新憑證。</p>
<ul>
<li>install certbot</li>
</ul>
<ol>
<li>指令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. sudo apt-get update</span></pre></td></tr><tr><td class="code"><pre><span class="line">2. sudo apt-get install software-properties-common &#x2F;&#x2F; 載入 certbot 的 ppa</span></pre></td></tr><tr><td class="code"><pre><span class="line">3. sudo add-apt-repository ppa:certbot&#x2F;certbot</span></pre></td></tr><tr><td class="code"><pre><span class="line">4. sudo apt-get update</span></pre></td></tr><tr><td class="code"><pre><span class="line">5. sudo apt-get install python-certbot-nginx # install python&#39;s certbot for nginx</span></pre></td></tr></table></figure></li>
<li>產生憑證：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo certbot --nginx</span></pre></td></tr></table></figure></li>
<li>重新整理 nginx：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nginx -s reload</span></pre></td></tr></table></figure></li>
<li>檢查憑證續約狀況<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo certbot renew --dry-run</span></pre></td></tr></table></figure></li>
<li>執行憑證續約動作<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo certbot renew</span></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>Nuxt.js</tag>
      </tags>
  </entry>
  <entry>
    <title>關於 SEO 簡述</title>
    <url>/2020/03/18/vue-seo/</url>
    <content><![CDATA[<p>關於 SEO 方面的一些簡述。</p>
<a id="more"></a>
<h2 id="過往的觀點"><a href="#過往的觀點" class="headerlink" title="過往的觀點"></a>過往的觀點</h2><p>雖然以往刻板認知，搜尋引擎無法爬到現代 SPA 網頁的內容，但其實現代瀏覽器已經有能力抓到 JS Render 出來的內容，但還是以靜態為主，ajax 呼叫的內容依然無法。其中又以 Chrome 能更近一步抓到 Render 出來的連結。</p>
<h2 id="作者的觀點"><a href="#作者的觀點" class="headerlink" title="作者的觀點"></a>作者的觀點</h2><p>尤大大在面對SEO這個問題時，有提出自己的論點，SPA依然側重於實現後台類系統頁面，諸如會員、帳務相關，這些後台頁面，本質上就完全不仰賴SEO，畢竟他們是 for 內部人員使用。</p>
<p>至於 landing page，此類較無動態資料的網頁，他建議直接寫成靜態頁面，或是將 Vue 專案透過 Prerender 進行轉換。而高度交互或是大量動態資料的網站，則改使用 SSR(Server Side Rendering)。</p>
<h2 id="如何處理-SEO"><a href="#如何處理-SEO" class="headerlink" title="如何處理 SEO"></a>如何處理 SEO</h2><p>比較早期的做法是使用 Prerender 的插件，但我個人的主觀觀點是，中大型網站隨著 Nuxt 框架越發成熟，大多改用 Nuxt，而小型網站坦白說依賴網站SEO效益，不如經營社群媒體成效更佳。</p>
<p>另外，這幾年，有另一種針對這種靜態網站的解決方案也被提出來：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">React &#x3D;&gt; Gatsby</span></pre></td></tr><tr><td class="code"><pre><span class="line">Vue &#x3D;&gt; Gridsome</span></pre></td></tr></table></figure>
<p>這一類的靜態網站解決方案，除了以其封裝的框架為基底，同時也對SEO友好，更支援PWA。部署方面則和近年很夯的 Netlify 相結合，同時將後端服務分散各類雲端sass，形成自有的生態圈，或許會是未來的一個技術方向。</p>
]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title>前端自動化測試基礎知識</title>
    <url>/2020/03/18/test-basic/</url>
    <content><![CDATA[<p>之前工作的團隊是完全不碰這塊的，所以本身沒有摸過，但考慮到目前整體趨勢上，不少公司的前端正在導入測試，還是記錄一些筆記，方便未來能夠上手。</p>
<a id="more"></a>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>e.g.<br>許多舊專案的維護，改動不易，且重構成本高昂，且在重構的過程中，可能面臨需求改動，或是重構過中忽略一些歷史因素，導致功能不足前功盡棄。為了降低重構成本，在重構前預先準備測試，這樣在階段性重構的過程，這些測試皆會被調用，若測試沒過，代表重構的程式碼存在問題，第一時間先進行修復，避免出現重構完才發現重構程式存在瑕疵。</p>
<h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><p>結構</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- index.html</span></pre></td></tr><tr><td class="code"><pre><span class="line">- math.js</span></pre></td></tr><tr><td class="code"><pre><span class="line">- math.test.js</span></pre></td></tr></table></figure>
<p>我將 math.js 寫好兩個計算函式並引入 index.html，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add (a, b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return a + b</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">function minus (a, b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; 這邊我故意寫錯，將減法寫成除法</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return a &#x2F; b</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>同時準備測試代碼在 <code>math.test.js</code>，當然這邊的結構是無法直接執行測試，所以我們將測試程式丟到瀏覽器上的<code>console</code>測試時，在 run 的過程中因為函式本身有錯誤，這時就會進入 throw，提醒我哪邊發生錯誤了，可以回頭去檢視。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 預先將結果寫出來</span></pre></td></tr><tr><td class="code"><pre><span class="line">var result &#x3D; add(2, 4)</span></pre></td></tr><tr><td class="code"><pre><span class="line">var expected &#x3D; 6</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">if (result !&#x3D;&#x3D; 6) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; throw 拋出例外狀況</span></pre></td></tr><tr><td class="code"><pre><span class="line">  throw Error(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#96;2 + 6 應該等於 $&#123;expected&#125;，但結果卻是 $&#123;result&#125;，請檢查add()&#96;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">var result &#x3D; minus(10, 5)</span></pre></td></tr><tr><td class="code"><pre><span class="line">var expected &#x3D; 5</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">if (result !&#x3D;&#x3D; 5) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  throw Error(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#96;10 - 5 應該等於 $&#123;expected&#125;，但結果卻是 $&#123;result&#125;，請檢查minus()&#96;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>如此一來，未來如果進行擴充新函式時，而我不小心手殘改到舊的函式時，在 run 測試的時候，我也可以獲得提醒，避免發生不必要的 bug。</p>
<h3 id="封裝"><a href="#封裝" class="headerlink" title="封裝"></a>封裝</h3><p>除了上述寫法，也可以將測試的函式合併在一起。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function expect (result) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(result)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    toBe: function(actual) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      console.log(actual)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      if (result !&#x3D;&#x3D; actual) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        throw new Error(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#96;程式碼執行結果和預期結果不同，預期是$&#123;actual&#125;，結果卻是$&#123;result&#125;&#96;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        )</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 測試描述，方便測試後，更好理解哪一部分出現錯誤</span></pre></td></tr><tr><td class="code"><pre><span class="line">function testDescription(desc, params) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  try &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    params()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(&#96;$&#123;desc&#125; 已通過測試&#96;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  catch(err) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(&#96;$&#123;desc&#125; 未通過測試 $&#123;err&#125;&#96;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">testDescription(&#39;測試加法函式&#39;, () &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  expect(add(2, 4)).toBe(6)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">testDescription(&#39;測試減法函式&#39;, () &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  expect(minus(10, 5)).toBe(5)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<p>假設我故意將<code>minus()</code>寫成+法，那拿到的 result(函式計算的結果)和 actual(預期的結果)將不會相等，則會拋出 throw。</p>
<h2 id="Jest"><a href="#Jest" class="headerlink" title="Jest"></a>Jest</h2><ul>
<li>速度快<ul>
<li>a、b兩者互不關聯的函式，若僅改a，但b未改動，則b不做測試，節省測試時間。</li>
</ul>
</li>
<li>多項目並行<ul>
<li>若前後台專案，使用不同框架或是一方使用Vue，另一方使用Node，依然可以並行測試。</li>
</ul>
</li>
</ul>
<h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd project</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn init</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 測試僅需要運行在開發環境</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn add jest --dev</span></pre></td></tr></table></figure>
<h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p>在<code>Jest</code>中，已經提供了<code>test()</code>和<code>expect()</code>，直接使用即可。</p>
<ul>
<li>導出，在<code>math.js</code>中使用<code>module.exports</code>將函式導出。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add (a, b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return a + b</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">function minus (a, b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return a - b</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  add,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  minus</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li>
<li>引入，在<code>math.test.js</code>中將導出的函式引入測試。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const math &#x3D; require(&#39;.&#x2F;math.js&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">const &#123; add, minus &#125; &#x3D; math</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">test(&#39;測試加法函式&#39;, () &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  expect(add(2, 4)).toBe(6)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">test(&#39;測試減法函式&#39;, () &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  expect(minus(10, 5)).toBe(5)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure></li>
<li><code>package.json</code>腳本加入運行<code>Jest</code>指令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 這個指令執行後，會去尋找目錄下，以 test.js 結尾的文件，並加以運行</span></pre></td></tr><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &quot;test&quot;: &quot;jest&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
接著在終端機運行<code>yarn run test</code>，就可以看到測試的過程。<br><code>Jest</code>的主要功能在於單元測試與集成測試，但這兩者本質上就是單一模組測試和多模組測試。所以為了配合<code>Jest</code>，必須將既有的函式透過<code>module.exports</code>的方式轉為模組化後，才能讓<code>Jest</code>調用測試。</li>
<li>測試環境和瀏覽器環境<br>一般來說，在沒有<code>cli</code>之類的工具下，瀏覽器無法自動編譯<code>module</code>，但對測試環境來說需要<code>module</code>，所以需要透過<code>try catch</code>包裹，避免出現紅字錯誤。不過實務上，我們目前開發大多已在腳手架工具內，自動會協助處理編譯，所以其實是不需要<code>try catch</code>包裹。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(&#39;test&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  module.exports &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    add,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    minus</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">catch (err) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="設定"><a href="#設定" class="headerlink" title="設定"></a>設定</h3><ul>
<li>指令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn jest --init</span></pre></td></tr></table></figure>
這道指令的目的，在於啟用<code>node_modules</code>下的<code>Jest</code>進行初始化。執行指令後，接下來會詢問測試環境是<code>Node</code>還是瀏覽器，是否生成覆蓋率報告，測試結束後是否自動清除模擬。這邊選瀏覽器環境，其他則都選y，最後目錄下會生成<code>jest.config.js</code>的檔案。</li>
<li>jest.config.js<br>在設定檔中，可以看到下面這一行，意思是生成覆蓋率報告時，會自動存放於<code>coverage</code>的資料夾內。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">coverageDirectory: &quot;coverage&quot;</span></pre></td></tr></table></figure>
同時因為剛剛選擇的是瀏覽器環境，所以預設會註釋<code>browser</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; browser: false</span></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>自動化測試</tag>
        <tag>Jest</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 基礎知識補充</title>
    <url>/2020/03/15/js-basic/</url>
    <content><![CDATA[<p>補強 JS 基礎知識，方便自己隨時複習。</p>
<a id="more"></a>
<h2 id="JS-變數類型"><a href="#JS-變數類型" class="headerlink" title="JS 變數類型"></a>JS 變數類型</h2><h3 id="value-type"><a href="#value-type" class="headerlink" title="value type"></a>value type</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 單純的賦值</span></pre></td></tr><tr><td class="code"><pre><span class="line">let a &#x3D; 10</span></pre></td></tr><tr><td class="code"><pre><span class="line">let b &#x3D; 20</span></pre></td></tr><tr><td class="code"><pre><span class="line">a &#x3D; 30</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(b) &#x3D;&gt; ? &#x2F;&#x2F; 20</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#39;test&#39; &#x2F;&#x2F; string</span></pre></td></tr><tr><td class="code"><pre><span class="line">let b &#x3D; 100 &#x2F;&#x2F; number</span></pre></td></tr><tr><td class="code"><pre><span class="line">let c &#x3D; true &#x2F;&#x2F; boolean</span></pre></td></tr><tr><td class="code"><pre><span class="line">let d &#x3D; Symbol(&#39;d&#39;) &#x2F;&#x2F; ES6 新增</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 另外還有 null、undefined、BigInt</span></pre></td></tr></table></figure>
<h3 id="reference-type"><a href="#reference-type" class="headerlink" title="reference type"></a>reference type</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#123; num: 10 &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">let b &#x3D; a</span></pre></td></tr><tr><td class="code"><pre><span class="line">b.num &#x3D; 15</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(a.age) &#x3D;&gt; ? &#x2F;&#x2F; 15</span></pre></td></tr></table></figure>
<p>不同於前者存放於 Stack(棧)，後者存放於 Heap(堆)，存放於堆的變數，看似賦值，但其實是存在電腦中一個位址，即便賦值兩個變數，但其實都是指向同一個位址，也因此就會造成覆蓋。</p>
<h4 id="pass-by-sharing"><a href="#pass-by-sharing" class="headerlink" title="pass by sharing"></a>pass by sharing</h4><p>JS 的屬性，當有<code>function</code>時，賦值不影響外部變數，但更新可以改變變數。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 賦值無法影響</span></pre></td></tr><tr><td class="code"><pre><span class="line">let a &#x3D; &#123; num: 10 &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">function changeVal(obj) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  obj &#x3D; &#123; num: 50 &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">changeVal(a)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(a) &#x3D;&gt; ? &#x2F;&#x2F; &#123; num: 10 &#125;</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 更新會改變</span></pre></td></tr><tr><td class="code"><pre><span class="line">let a &#x3D; &#123; num: 10 &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">function changeVal(obj) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  obj.num &#x3D; 50</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">changeVal(a)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(a) &#x3D;&gt; ? &#x2F;&#x2F; &#123; num: 50 &#125;</span></pre></td></tr></table></figure>
<ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10191057" target="_blank" rel="noopener">重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？</a></li>
<li><a href="https://pjchender.blogspot.com/2016/03/javascriptby-referenceby-value.html" target="_blank" rel="noopener">[筆記] 談談 JavaScript 中 by reference 和 by value 的重要觀念</a></li>
</ul>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>檢查 value</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#39;test&#39;      typeof(a)   &#x2F;&#x2F; string</span></pre></td></tr><tr><td class="code"><pre><span class="line">let b &#x3D; 100         typeof(b)   &#x2F;&#x2F; number</span></pre></td></tr><tr><td class="code"><pre><span class="line">let c &#x3D; true        typeof(c)   &#x2F;&#x2F; boolean</span></pre></td></tr><tr><td class="code"><pre><span class="line">let d &#x3D; Symbol(&#39;d&#39;) typeof(d)   &#x2F;&#x2F; Symbol</span></pre></td></tr><tr><td class="code"><pre><span class="line">let e               typeof(e)   &#x2F;&#x2F; undefined</span></pre></td></tr></table></figure>
<p>檢查 function</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof console.log   &#x2F;&#x2F; &#39;function&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">typeof function()&#123;&#125;  &#x2F;&#x2F; &#39;function&#39;</span></pre></td></tr></table></figure>
<p>陣列、物件、null 都會被判斷為 object</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof null        &#x2F;&#x2F; object</span></pre></td></tr><tr><td class="code"><pre><span class="line">typeof [1, 2]      &#x2F;&#x2F; object</span></pre></td></tr><tr><td class="code"><pre><span class="line">typeof &#123; num: 2 &#125;  &#x2F;&#x2F; object</span></pre></td></tr></table></figure>
<!-- ### Deep Clone (深拷貝) -->
<h3 id="變數計算"><a href="#變數計算" class="headerlink" title="變數計算"></a>變數計算</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; 10 + 2      &#x2F;&#x2F; 12</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果其中有 string 會變成組合 string</span></pre></td></tr><tr><td class="code"><pre><span class="line">let b &#x3D; 10 + &#39;1&#39;    &#x2F;&#x2F; &#39;101&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">let c &#x3D; false + &#39;2&#39; &#x2F;&#x2F; &#39;false2&#39;</span></pre></td></tr></table></figure>
<h3 id="判斷檢查"><a href="#判斷檢查" class="headerlink" title="判斷檢查"></a>判斷檢查</h3><p><code>==</code>在運算上，會盡可能讓兩側相等，容易出現許多錯誤。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 &#x3D;&#x3D; &#39;10&#39;         &#x2F;&#x2F; true</span></pre></td></tr><tr><td class="code"><pre><span class="line">0 &#x3D;&#x3D; &#39;&#39;            &#x2F;&#x2F; true</span></pre></td></tr><tr><td class="code"><pre><span class="line">0 &#x3D;&#x3D; false         &#x2F;&#x2F; true</span></pre></td></tr><tr><td class="code"><pre><span class="line">false &#x3D;&#x3D; &#39;&#39;        &#x2F;&#x2F; true</span></pre></td></tr><tr><td class="code"><pre><span class="line">null &#x3D;&#x3D; undefined  &#x2F;&#x2F; true</span></pre></td></tr></table></figure>
<p>目前基本都是一律使用<code>===</code>做判斷，不會使用<code>==</code>，但如果為了判斷<code>null</code>，可以使用，但我個人是不使用<code>==</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (a &#x3D;&#x3D; null) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 等同於</span></pre></td></tr><tr><td class="code"><pre><span class="line">if (a &#x3D;&#x3D;&#x3D; null || a &#x3D;&#x3D;&#x3D; undefined) &#123;&#125;</span></pre></td></tr></table></figure>
<h2 id="JS-作用域"><a href="#JS-作用域" class="headerlink" title="JS 作用域"></a>JS 作用域</h2><p>JS 屬於靜態作用域，變數在語法解析時，就已經確定作用域，且不再改變。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let val &#x3D; 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">function a() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(val)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">function b() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let val &#x3D; 2</span></pre></td></tr><tr><td class="code"><pre><span class="line">  a()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">b()</span></pre></td></tr></table></figure>
<p>雖然在 b() 當中重新對 val 進行賦值，但因為前述靜態作用域的特性，不會觸發這個改變後的賦值，而會選擇維持調用全域的變數。但如果今天這個是動態作用域，則結果相反，會等到函式執行後，取最新的變數。</p>
<h2 id="範圍鍊"><a href="#範圍鍊" class="headerlink" title="範圍鍊"></a>範圍鍊</h2><p>承前述，在函式內如果沒有變數，那倘若要印出變數，這個時候會向外尋找，先找到父層的函式，再沒有則往全域尋找，這樣的過程可以理解為一個範圍鍊。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person &#x3D; &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">function first () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(1, person) &#x2F;&#x2F; Pitt</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">function second () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  var person &#x3D; &#39;Nini&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(2, person) &#x2F;&#x2F; Nini</span></pre></td></tr><tr><td class="code"><pre><span class="line">  function third () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    var person &#x3D; &#39;Yumi&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(3, person) &#x2F;&#x2F; Yumi</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  first()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  third()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">first()</span></pre></td></tr><tr><td class="code"><pre><span class="line">second()</span></pre></td></tr></table></figure>
<p>第一次執行 first() 時，因為這個函式內沒有變數 person，所以會向全域尋找，賦值為 Pitt，接著執行 second()，這時函式內 person 已經有值為 Nini 了，所以會印出 Nini，但這時再次執行 first()，因為靜態作用域的特性，所以 second() 的變數不會影響到 first()，因此仍會向全域尋找印出 Pitt。最後則是執行 third()，因為 third() 內同樣有變數，所以會印出 Yumi。</p>
<p>倘若我將 third() 中的變數註釋掉，那 third() 會先向父層 second() 尋找印出 Nini，如果 second() 也被註釋掉則會尋找全域變數印出 Pitt。</p>
<h2 id="Event-queue"><a href="#Event-queue" class="headerlink" title="Event queue"></a>Event queue</h2><p>JS 本身是單執行緒，因此非同步的事件在 JS 的執行過程中，會被放置到事件等待序列中，直到其他同步事件先被執行完成，才會被執行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function a () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">function b () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">function c () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(3)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(4)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;, 0)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">function Doing () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  a()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  b()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Doing() &#x2F;&#x2F; &#x3D;&gt; 依序印出 1 3 2 4</span></pre></td></tr></table></figure>

<h2 id="物件取值"><a href="#物件取值" class="headerlink" title="物件取值"></a>物件取值</h2><p>除了過往用使用 . 來連結取值外，object也可以透過 [] 來進一步取值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  name: &#39;Pitt&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  2: 2</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(obj.name)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(obj[2])</span></pre></td></tr></table></figure>
<p>如上，這種 index 特殊的狀況下，用 . 是無法取值，必須仰賴 []。此外，還有一種寫法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  name: &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">var newName &#x3D; &#39;name&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(obj[newName])</span></pre></td></tr></table></figure>
<p>宣告變數，並將它的賦值和對應的物件屬性相同，就可以透過 [] 進行取值。物件新增同理，使用 . 或是 [] 都可以增加物件中尚未存在的欄位。前面加入 delete 則是刪除對應的欄位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  name: &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">obj.weapon &#x3D; &#39;arrow&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">obj[&#39;archer&#39;] &#x3D; &#39;Nancy&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(obj)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">obj &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  name: &#39;Pitt&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  weapon: &#39;arrow&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  archer: &#39;Nancy&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete obj.weapon</span></pre></td></tr><tr><td class="code"><pre><span class="line">delete obj[&#39;archer&#39;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(obj)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">obj &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  name: &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>*tips：變數無法被刪除，但屬性可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; 10 &#x2F;&#x2F; 宣告後才是變數</span></pre></td></tr><tr><td class="code"><pre><span class="line">b &#x3D; 20 &#x2F;&#x2F; 賦值只能算是屬性</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">delete a</span></pre></td></tr><tr><td class="code"><pre><span class="line">delete b</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(window.a) &#x2F;&#x2F; 10</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(window.b) &#x2F;&#x2F; undefined</span></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Interview</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js &amp; Firebase 實作即時聊天室</title>
    <url>/2020/02/26/vue-firebase-chat/</url>
    <content><![CDATA[<p>首次嘗試套用 Vue.js + Firebase 來實作一個聊天室 Demo，但因為沒有透過後端轉發，安全性上大概是0吧(苦笑)。考慮到後續還要摸 Nuxt.js，學習 Node.js 這一塊是躲不掉了。</p>
<a id="more"></a>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><ul>
<li><p><a href="https://vue-chat-6a66d.firebaseapp.com/" target="_blank" rel="noopener">Vue Chat 連結</a></p>
</li>
<li><p>結構：</p>
<ul>
<li>前端框架：Vue.js</li>
<li>UI：手刻(Flexbox)<ul>
<li>Layout：App 風格</li>
</ul>
</li>
<li>Database：Firebase</li>
</ul>
</li>
</ul>
<h3 id="預期重構"><a href="#預期重構" class="headerlink" title="預期重構"></a>預期重構</h3><h4 id="優化"><a href="#優化" class="headerlink" title="優化"></a>優化</h4><ul>
<li>聊天室輸入內容時，可以添加檔案或圖片</li>
<li>添加標情符號欄位</li>
<li>玩家可以自創私人聊天室(類似群組)</li>
</ul>
<h4 id="修正"><a href="#修正" class="headerlink" title="修正"></a>修正</h4><ul>
<li>在多人註冊的狀況下，聊天內容會產生傳送誤判，需要檢查資料結構，若無解的話，可能需要採用 socket.io</li>
</ul>
<h3 id="開發流程"><a href="#開發流程" class="headerlink" title="開發流程"></a>開發流程</h3><p>此處內容待重寫ing…</p>
]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Firebase</tag>
      </tags>
  </entry>
  <entry>
    <title>實作 Vue.js Web App 簡單工具</title>
    <url>/2020/02/26/web-app-vue/</url>
    <content><![CDATA[<p>寫在前頭，這個 Demo 看似 Web App，但本質上並不是，畢竟我自己還沒有碰過 Hybrid App。但因為前職其中一項專案產品，其 Layout 佈局採用 Web App 的風格來實作，並且成功存活。因此自己也來試寫一個小型 Demo。</p>
<p>也因為沒有搭配後端，所以僅有接幾個 API 來呈現資料內容，並套用了 i18n 來處理多語系功能。</p>
<a id="more"></a>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>建議手機直接掃描操作進入網址。<br><img src="/images/vue-tools-app.png" alt=""></p>
<ul>
<li><p>結構：</p>
<ul>
<li>前端框架：Vue.js</li>
<li>UI：手刻(Flexbox)<ul>
<li>Layout：App 風格</li>
</ul>
</li>
</ul>
</li>
<li><p>待優化：</p>
<ul>
<li>需要調整 UserStory</li>
<li>加入會員系統</li>
<li>另建一個專案來設定後台(有空的話…)</li>
</ul>
</li>
<li><p>Layout：<br>和過往的 RWD 設計佈局不同，出現 footer vs navbar 的情境，在 RWD 的 footer，多數是不具備實質功能的，若非版權宣告，就是條列網站的一些聲明文字或連結。</p>
<p>相反的 navbar 卻是重心之一，當使用者在手機或平板操作時，navbar 可以讓客戶快速切換自己想前往的頁面，而非上下滾動來尋找目錄。但這種 Web App 在 PC 的介面時，則會奇醜無比，目前尚未看到兼容兩者的方案。</p>
</li>
</ul>
<h3 id="開發流程"><a href="#開發流程" class="headerlink" title="開發流程"></a>開發流程</h3><p>待重構優化後，重新撰寫~</p>
]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Web App</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js(建立後端API接口)</title>
    <url>/2020/02/22/node-interface/</url>
    <content><![CDATA[<p>嘗試理解 <code>Node.js</code> 如何建立後端API接口，簡略記下自己的建立流程。</p>
<a id="more"></a>
<h2 id="Install-plugin"><a href="#Install-plugin" class="headerlink" title="Install plugin"></a>Install plugin</h2><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>建立如註冊類的API時，需使用 <code>POST</code>，這邊安裝一個插件來應用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add body-parser</span></pre></td></tr></table></figure>
<h3 id="密碼加密"><a href="#密碼加密" class="headerlink" title="密碼加密"></a>密碼加密</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add bcrypt</span></pre></td></tr></table></figure>
<h3 id="avatar-大頭貼"><a href="#avatar-大頭貼" class="headerlink" title="avatar 大頭貼"></a>avatar 大頭貼</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add gravatar</span></pre></td></tr></table></figure>
<h3 id="jwt-token"><a href="#jwt-token" class="headerlink" title="jwt token"></a>jwt token</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add jsonwebtoken</span></pre></td></tr></table></figure>
<h3 id="驗證"><a href="#驗證" class="headerlink" title="驗證"></a>驗證</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add passport passport-jwt</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 指令記錄</title>
    <url>/2020/02/21/git/command/</url>
    <content><![CDATA[<p>前工作的前端團隊都使用 SourceTree 進行版控，相對較少使用指令操作 git，為了方便日後終端機操作，記錄一下指令功能。</p>
<a id="more"></a>
<ul>
<li>初始化git專案<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span></pre></td></tr></table></figure></li>
<li>將檔案加入版本控制<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span></pre></td></tr></table></figure></li>
<li>建立 develop 分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch develop</span></pre></td></tr></table></figure></li>
<li>切換分支到 develop<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout develop</span></pre></td></tr></table></figure></li>
<li>推送分支到遠端<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin develop</span></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>實作 Element UI CMS</title>
    <url>/2020/02/21/vue-element-cms-shop/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p><a href="https://vue-shope-admin.netlify.com/" target="_blank" rel="noopener">Element UI CMS 連結</a></p>
<ul>
<li><p>結構：</p>
<ul>
<li>前端：Vue.js</li>
<li>UI：Element UI</li>
<li>後端：六角學院提供 API</li>
</ul>
</li>
<li><p>待修正 &amp; 優化<br>這個 Demo 主要是因之前工作都寫前台居多，沒有參與後台維護與開發，簡單練手寫一個後台，但整體來說寫得不好，蠻多細節需要重新調整，同時也考慮日後自己寫 API，視情況重構或是另起爐灶。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Element UI</tag>
      </tags>
  </entry>
  <entry>
    <title>Quasar(Vue.js UI Framework)</title>
    <url>/2020/02/18/quasar/</url>
    <content><![CDATA[<p>Quasar Framework 是支援 Vue.js 的 UI 框架，作者設計出發的概念還蠻宏偉的，兼容全平台，實用性與否還有待評估，這邊先按照作者的教學實作看看。</p>
<a id="more"></a>
<h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p><a href="https://quasar.dev/" target="_blank" rel="noopener">官網連結</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn global add @quasar&#x2F;cli</span></pre></td></tr><tr><td class="code"><pre><span class="line"># or</span></pre></td></tr><tr><td class="code"><pre><span class="line">npm install -g @quasar&#x2F;cli</span></pre></td></tr></table></figure>
<h3 id="Quasar-Cli"><a href="#Quasar-Cli" class="headerlink" title="Quasar Cli"></a>Quasar Cli</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">quasar create project-name</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">cd project</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">quasar dev</span></pre></td></tr></table></figure>
<h2 id="Install-Pug"><a href="#Install-Pug" class="headerlink" title="Install Pug"></a>Install Pug</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add --dev pug pug-plain-loader</span></pre></td></tr></table></figure>
<h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; quasar.conf.js</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">build: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  extendWebpack (cfg) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cfg.module.rules.push(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      test: &#x2F;\.pug$&#x2F;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      loader: &#39;pug-plain-loader&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="Install-Firebase"><a href="#Install-Firebase" class="headerlink" title="Install Firebase"></a>Install Firebase</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add firebase</span></pre></td></tr></table></figure>
<p><code>quasar</code> 導入 <code>firebase</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">quasar new boot firebase</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 新生成檔案在 src&#x2F;boot&#x2F;firebase.js</span></pre></td></tr></table></figure>
<p>設定 <code>quasar.config.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  boot: [</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#39;firebase&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="firebase-js"><a href="#firebase-js" class="headerlink" title="firebase.js"></a>firebase.js</h3><p>設定內容寫法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Firebase App (the core Firebase SDK) is always required and must be listed first</span></pre></td></tr><tr><td class="code"><pre><span class="line">import * as firebase from &#39;firebase&#x2F;app&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; If you enabled Analytics in your project, add the Firebase SDK for Analytics</span></pre></td></tr><tr><td class="code"><pre><span class="line">import &#39;firebase&#x2F;analytics&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Add the Firebase products that you want to use</span></pre></td></tr><tr><td class="code"><pre><span class="line">import &#39;firebase&#x2F;auth&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import &#39;firebase&#x2F;database&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 下方貼上 SDK 一大串 script</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化需做調整 Initialize Firebase</span></pre></td></tr><tr><td class="code"><pre><span class="line">const firebaseApp &#x3D; firebase.initializeApp(firebaseConfig)</span></pre></td></tr><tr><td class="code"><pre><span class="line">const firebaseAuth &#x3D; firebaseApp.auth()</span></pre></td></tr><tr><td class="code"><pre><span class="line">const firebaseDB &#x3D; firebaseApp.database()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">export &#123; firebaseAuth, firebaseDB &#125;</span></pre></td></tr></table></figure>
<p>回到 <code>Vuex</code> 載入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; firebaseAuth, firebaseDB &#125; from &#39;boot&#x2F;firebase&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(1, firebaseAuth)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(2, firebaseDB)</span></pre></td></tr></table></figure>
<h2 id="quasar-conf-js"><a href="#quasar-conf-js" class="headerlink" title="quasar.conf.js"></a>quasar.conf.js</h2><p>設定 router =&gt; History Mode</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vueRouterMode: &#39;history&#39;</span></pre></td></tr></table></figure>
<h2 id="Error-Fixed"><a href="#Error-Fixed" class="headerlink" title="Error Fixed"></a>Error Fixed</h2><p>資料無法正常送出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">q-btn 若僅加上 type&#x3D;&quot;submit&quot; 無法正常送出 q-form 內的資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">需在 q-btn 本身再補上一個 @click 事件，才能執行 methods</span></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Quasar</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Express 框架運用與理解</title>
    <url>/2020/02/16/node/express/</url>
    <content><![CDATA[<p>Express 算是比較老牌的輕量級 Node.js Web 框架，透過學習使用 Express 來加深自己對 Node 的理解，同時提高對後端的認知。</p>
<a id="more"></a>
<h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始專案</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn init</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn add express</span></pre></td></tr></table></figure>
<h2 id="Open-Web-Server"><a href="#Open-Web-Server" class="headerlink" title="Open Web Server"></a>Open Web Server</h2><p>載入並調用 <code>Express</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">const app &#x3D; express()</span></pre></td></tr></table></figure>
<p>使用 <code>get()</code> 方法，來檢查資料有無傳送到對應頁面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.send(&#39;Hello Express!&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; watch port</span></pre></td></tr><tr><td class="code"><pre><span class="line">let port &#x3D; 3000</span></pre></td></tr><tr><td class="code"><pre><span class="line">app.listen(port)</span></pre></td></tr></table></figure>
<h3 id="監聽端口的正式站環境寫法"><a href="#監聽端口的正式站環境寫法" class="headerlink" title="監聽端口的正式站環境寫法"></a>監聽端口的正式站環境寫法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; process.env &#x3D;&gt; 意指環境變數，當完成部署後，端口由 server 提供</span></pre></td></tr><tr><td class="code"><pre><span class="line">const port &#x3D; process.env.PORT || 3000</span></pre></td></tr><tr><td class="code"><pre><span class="line">app.listen(port)</span></pre></td></tr></table></figure>
<h2 id="params-amp-query"><a href="#params-amp-query" class="headerlink" title="params &amp; query"></a>params &amp; query</h2><p>這兩者概略來說，就是向後端發出請求時所帶的參數，差別在於，url 上所呈現格式不同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 按照之前的開發合作的經驗</span></pre></td></tr><tr><td class="code"><pre><span class="line">params &#x3D;&gt; 通常為必填值</span></pre></td></tr><tr><td class="code"><pre><span class="line">query &#x3D;&gt; 選填值</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">app.get(&#39;&#x2F;user&#x2F;:name&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let userName &#x3D; req.params.name</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let limit &#x3D; req.query.limit</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.send(&#39;&lt;html&gt;&lt;head&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;&#39;+userName+&#39;&lt;&#x2F;h1&gt;&lt;h2&gt;&#39;+limit+&#39;&lt;&#x2F;h2&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h2 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h2><p>意指中介層，等於替資料庫做一層防護，當用戶發出請求進入對應頁面，檢查對方是否符合請求邏輯，譬如登入頁可能會檢查一些帳號資訊等等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 調用 use() 方法做檢查</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">app.use((req, res, next) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(&#39;login&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  next()  &#x2F;&#x2F; next() 方法是為了當邏輯驗證正確後，能繼續執行下一步驟</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h3 id="驗證檢查"><a href="#驗證檢查" class="headerlink" title="驗證檢查"></a>驗證檢查</h3><p>為了避免用戶刻意透過 router 進入頁面，前後端都會進行驗證檢查。此外不存在的資料或是 server 掛了，為了用戶體驗也必須給予對應的狀態提示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 當用戶隨意亂打參數，使用 use() 方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使其進入我們希望他進入的頁面提示，避免直接回傳 cannot get 訊息</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">app.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.send(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#39;&lt;html&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;head&gt;&lt;&#x2F;head&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;body&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;h1&gt;123&lt;&#x2F;h1&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;&#x2F;body&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;html&gt;&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">app.use((req, res, next) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.status(404).send(&#39;404 is not found&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<p><code>use()</code> 方法，除了提示找不到頁面，若是程式碼本身有錯，也可以提醒，通常狀態碼為 500。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 這邊使用了一個未定義的函式，除了出現 not defined 的 error</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 也會回傳 500 的狀態碼</span></pre></td></tr><tr><td class="code"><pre><span class="line">app.use((req, res, next) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  test()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  next()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">app.use((err, req, res, next) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.status(500).send(&#39;sorry try again&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h3 id="增加靜態檔案路徑"><a href="#增加靜態檔案路徑" class="headerlink" title="增加靜態檔案路徑"></a>增加靜態檔案路徑</h3><p>使用 express 提供的原生方法 <code>static()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 建立名為 public 的資料夾作為靜態檔案存放</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 順序上必須放在最前面，方便後面的 router 能正常引用</span></pre></td></tr><tr><td class="code"><pre><span class="line">app.use(express.static(&#39;public&#39;))</span></pre></td></tr></table></figure>
<h2 id="Template-EJS"><a href="#Template-EJS" class="headerlink" title="Template - EJS"></a>Template - EJS</h2><h3 id="Install-1"><a href="#Install-1" class="headerlink" title="Install"></a>Install</h3>]]></content>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 生命週期簡單理解</title>
    <url>/2020/02/13/vue-life-cycle/</url>
    <content><![CDATA[<p>整理 Vue 的生命週期和用法理解。</p>
<a id="more"></a>
<h2 id="數據變化與更新"><a href="#數據變化與更新" class="headerlink" title="數據變化與更新"></a>數據變化與更新</h2><h3 id="beforeUpdate-amp-updated"><a href="#beforeUpdate-amp-updated" class="headerlink" title="beforeUpdate &amp; updated"></a>beforeUpdate &amp; updated</h3><p>透過 @click 事件來達到數據更新的功能。<br>一開始頁面渲染 data 的初始資料，當點擊時觸發函式執行資料更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; template</span></pre></td></tr><tr><td class="code"><pre><span class="line">p &#123;&#123; msg &#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">button(@click&#x3D;&quot;update()&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; data 存放資料的初始值</span></pre></td></tr><tr><td class="code"><pre><span class="line">data () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    msg: &#39;Hello Vue!&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; methods 存放執行的函式，透過點擊執行函式來更新資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">methods: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  update () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    this.msg &#x3D; &#39;Hello Pitt!&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="銷毀"><a href="#銷毀" class="headerlink" title="銷毀"></a>銷毀</h2><h3 id="beforeDestroy-amp-destroyed"><a href="#beforeDestroy-amp-destroyed" class="headerlink" title="beforeDestroy &amp; destroyed"></a>beforeDestroy &amp; destroyed</h3><p>理解銷毀的概念，可以透過 v-if 來理解。當判斷為 false 時，本質上就等於銷毀該 Dom 節點。若預設 data 為 true，一開始頁面渲染時會出現，此時不會觸發 beforeDestroy &amp; destroyed。但當點擊動作觸發轉為 false 時，則會觸發 beforeDestroy &amp; destroyed，這時頁面上被綁定的對象也會消失，即可是為銷毀。</p>
<h2 id="掛載順序"><a href="#掛載順序" class="headerlink" title="掛載順序"></a>掛載順序</h2><p>在 Vue.js 的生命週期中，當頁面渲染時，透過 console.log，可以看到依序為：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. beforeCreate &#x2F;&#x2F; 在這個階段 $el 和 $data 都尚未掛載 &#x3D;&gt; undefined</span></pre></td></tr><tr><td class="code"><pre><span class="line">2. created &#x2F;&#x2F; $data 初始資料已載入，$el 尚未 &#x3D;&gt; undefined</span></pre></td></tr><tr><td class="code"><pre><span class="line">3. beforeMount &#x2F;&#x2F; $el 依然為空 &#x3D;&gt; undefined</span></pre></td></tr><tr><td class="code"><pre><span class="line">4. mounted &#x2F;&#x2F; $el 完成渲染出現資料</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Firebase 操作記錄筆記</title>
    <url>/2020/02/12/firebase/note/</url>
    <content><![CDATA[<p>記錄自己操作 Firebase 的流程，以及問題解法。</p>
<a id="more"></a>
<h2 id="新版-SDK-異動"><a href="#新版-SDK-異動" class="headerlink" title="新版 SDK 異動"></a>新版 SDK 異動</h2><p>除了引入的 firebase-app.js 是主要核心，其他功能則被拆分到各子項目。<br>若要調用 <code>firebase.database()</code> 需再引入以下 script：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;www.gstatic.com&#x2F;firebasejs&#x2F;7.8.2&#x2F;firebase-database.js&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;script&gt;</span></pre></td></tr></table></figure>
<h3 id="檢查是否載入-Firebase-成功"><a href="#檢查是否載入-Firebase-成功" class="headerlink" title="檢查是否載入 Firebase 成功"></a>檢查是否載入 Firebase 成功</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const database &#x3D; firebase.database()</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(database)</span></pre></td></tr></table></figure>
<h2 id="操作資料庫"><a href="#操作資料庫" class="headerlink" title="操作資料庫"></a>操作資料庫</h2><p><code>ref()</code> =&gt; 尋找資料庫路徑<br><code>set()</code> =&gt; 新增資料</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 目前練習使用 Realtime Database</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 若沒有目錄的狀況，預設會寫入到根目錄</span></pre></td></tr><tr><td class="code"><pre><span class="line">firebase.database().ref().set(&#39;Hello Firebase!&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 除了字串，也可以寫入物件</span></pre></td></tr><tr><td class="code"><pre><span class="line">firebase.database().ref().set(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  name: &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h3 id="修改資料"><a href="#修改資料" class="headerlink" title="修改資料"></a>修改資料</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 原始資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">firebase.database().ref(&#39;firstArray&#39;).set([</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: &#39;Pitt&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hasMac: true</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: &#39;NiNi&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hasMac: true</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">])</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 尋找對應路徑後修改資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">firebase.database().ref(&#39;firstArray&#x2F;0&#x2F;hasMac&#39;).set(false)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 陣列中的第一組變數 hasMac 即會修改為 false</span></pre></td></tr></table></figure>
<h3 id="顯示資料至頁面"><a href="#顯示資料至頁面" class="headerlink" title="顯示資料至頁面"></a>顯示資料至頁面</h3><p><code>once()</code> =&gt; 讀取一次資料庫的資料<br>snapshot =&gt; 意指快照，其中 <code>snapshot.val()</code> 是 Firebase 的讀取語法，snapshot 本身是變數命名，可用其他名稱取代。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firebase.database().ref(&#39;userName&#39;).set(&#39;PittWu&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">let userName &#x3D; firebase.database().ref(&#39;userName&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">userName.once(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let item &#x3D; snapshot.val()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(item)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  document.getElementById(&#39;title&#39;).textContent &#x3D; item</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h3 id="隨時監聽資料"><a href="#隨時監聽資料" class="headerlink" title="隨時監聽資料"></a>隨時監聽資料</h3><p><code>on()</code> =&gt; 監聽</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用 on 語法時，當資料變更時，頁面也隨之渲染變化</span></pre></td></tr><tr><td class="code"><pre><span class="line">firebase.database().ref(&#39;userName&#39;).set(&#39;Pitt&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">let userName &#x3D; firebase.database().ref(&#39;userName&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">userName.on(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let item &#x3D; snapshot.val()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  document.getElementById(&#39;title&#39;).textContent &#x3D; item</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h2 id="Firebase-非同步"><a href="#Firebase-非同步" class="headerlink" title="Firebase 非同步"></a>Firebase 非同步</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firebase.database().ref(&#39;userName&#39;).set(&#39;Pitt&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">let userName &#x3D; firebase.database().ref(&#39;userName&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">userName.on(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let item &#x3D; snapshot.val()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(&#39;test1&#39;, item)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  document.getElementById(&#39;title&#39;).textContent &#x3D; item</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(&#39;test2&#39;)</span></pre></td></tr></table></figure>
<p>在前述程式碼中，正常資料庫回傳應該會需要等待時間，所以應該是先執行 <code>test2</code>，但在本地測試時，可能資料量太小，導致即使使用 Slow 3G，<code>test1</code> 依然先跑完，後續資料多的時候要再觀察非同步狀況。 </p>
<h2 id="新增資料"><a href="#新增資料" class="headerlink" title="新增資料"></a>新增資料</h2><p>透過 push 語法，添加資料至 Firebase，同時因為資料庫本身有協助建立 key 值，不需擔心資料衝突的問題。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const todoList &#x3D; firebase.database().ref(&#39;todoList&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">todoList.push(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  content: &#39;shopping&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 會拿到如下格式的資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">-M00rdx2RilLDFK9lmSg &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  content: &quot;shopping&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="刪除資料"><a href="#刪除資料" class="headerlink" title="刪除資料"></a>刪除資料</h2><p>child =&gt; 子路徑<br>可以透過 <code>ref()</code> 找到根目錄，也可以透過 <code>child()</code> 找到子目錄，下面兩種做法功能相同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let todoList &#x3D; firebase.database().ref(&#39;todoList&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">let todoList2 &#x3D; firebase.database().ref().child(&#39;todoList&#39;)</span></pre></td></tr></table></figure>
<p>remove =&gt; 刪除資料<br>最笨的刪除方法，直接根據 key 值進行刪除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">todoList.child(&#39;-M00rdx2RilLDFK9lmSg&#39;).remove()</span></pre></td></tr></table></figure>
<h2 id="網頁即時查看-Firebase-資料變動"><a href="#網頁即時查看-Firebase-資料變動" class="headerlink" title="網頁即時查看 Firebase 資料變動"></a>網頁即時查看 Firebase 資料變動</h2><p>先透過 <code>on()</code> 語法監聽資料庫，將快照取得的資料渲染到頁面，同時為了方便查看，再使用 <code>JSON.stringify</code> 格式化，<code>null, 2</code>則是縮排便於查看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const allData &#x3D; firebase.database().ref()</span></pre></td></tr><tr><td class="code"><pre><span class="line">allData.on(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let path &#x3D; document.getElementById(&#39;content&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  path.textContent &#x3D; JSON.stringify(snapshot.val(), null, 2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>透過 <code>orderByChild()</code> 選擇資料中排序的基準屬性，再透過 <code>forEach()</code> 依序撈出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firebase.database().ref(&#39;practice&#39;).set(people)</span></pre></td></tr><tr><td class="code"><pre><span class="line">let peopleRef &#x3D; firebase.database().ref(&#39;practice&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 先取得路徑 &#x3D;&gt; 是否需要排序(&#39;屬性&#39;) &#x3D;&gt; 讀取資料 &#x3D;&gt; 使用 forEach 依序撈出</span></pre></td></tr><tr><td class="code"><pre><span class="line">peopleRef.orderByChild(&#39;height&#39;).once(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  snapshot.forEach((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(node.val())</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h3 id="排序規則"><a href="#排序規則" class="headerlink" title="排序規則"></a>排序規則</h3><p>Firebase 的 <code>orderByChild()</code> 排序規則，需參考<a href="https://firebase.google.com/docs/database/admin/retrieve-data?hl=zh-cn#orderbychild" target="_blank" rel="noopener">官網文件</a></p>
<h2 id="搜尋區間"><a href="#搜尋區間" class="headerlink" title="搜尋區間"></a>搜尋區間</h2><p><code>startAt()</code> =&gt; 多少以上<br><code>endAt()</code> =&gt; 多少以下<br><code>equalTo()</code> =&gt; 等於</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e.g. 體重3000以上</span></pre></td></tr><tr><td class="code"><pre><span class="line">peopleRef.orderByChild(&#39;weight&#39;).startAt(3000).once(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  snapshot.forEach((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(node.val())</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 也可以透過 startAt() 和 endAt() 交叉運用來設定範圍</span></pre></td></tr><tr><td class="code"><pre><span class="line">peopleRef.orderByChild(&#39;weight&#39;).startAt(3000).endAt(5000).once(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  snapshot.forEach((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(node.val())</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 相等於</span></pre></td></tr><tr><td class="code"><pre><span class="line">peopleRef.orderByChild(&#39;weight&#39;).equalTo(3000).once(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  snapshot.forEach((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(node.val())</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h2 id="限制筆數"><a href="#限制筆數" class="headerlink" title="限制筆數"></a>限制筆數</h2><p><code>limitToFirst()</code> =&gt; 撈取從第一筆資料開始的資料，()內的條件設定預撈取的比數<br><code>limitToLast()</code> =&gt; 反之，從最後一筆開始撈資料</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">peopleRef.orderByChild(&#39;weight&#39;).startAt(2000).limitToLast(2).once(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  snapshot.forEach((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(node.val())</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h2 id="時間"><a href="#時間" class="headerlink" title="時間"></a>時間</h2><p>先透過 <code>JS</code> 原生語法檢查時間：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let time &#x3D; new Date()</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time.getFullYear())</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在 JS 中，0 &#x3D; 1月</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time.getMonth())</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 週日(禮拜7) &#x3D; 0、週一(禮拜一) &#x3D; 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time.getDay())</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time.getHours())</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time.getMinutes())</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time.getSeconds())</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1000毫秒 &#x3D; 1秒</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time.getMilliseconds())</span></pre></td></tr></table></figure>
<h3 id="UNIX-時間"><a href="#UNIX-時間" class="headerlink" title="UNIX 時間"></a>UNIX 時間</h3><p>從協調世界時1970年1月1日0時0分0秒起算至今</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let time &#x3D; new Date()</span></pre></td></tr><tr><td class="code"><pre><span class="line">time.getTime()  &#x2F;&#x2F; 拿到總秒數</span></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Firebase</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-Cli 初始化專案操作記錄</title>
    <url>/2020/02/12/vue-init-step/</url>
    <content><![CDATA[<p>前端框架版本迭代太快，更新過程中安裝的版本又容易出現錯誤，單靠記憶不可行，只好記錄自己的操作步驟，隨時更新方便檢查。</p>
<a id="more"></a>
<h2 id="全域環境調整-vue-cli-4-0-以上版本"><a href="#全域環境調整-vue-cli-4-0-以上版本" class="headerlink" title="全域環境調整(vue-cli 4.0 以上版本)"></a>全域環境調整(vue-cli 4.0 以上版本)</h2><h3 id="remove-old-version"><a href="#remove-old-version" class="headerlink" title="remove old version"></a>remove old version</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall vue-cli -g</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># or</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn global remove vue-cli</span></pre></td></tr></table></figure>
<h3 id="install-new-version"><a href="#install-new-version" class="headerlink" title="install new version"></a>install new version</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g @vue&#x2F;cli</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># or</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn global add @vue&#x2F;cli</span></pre></td></tr></table></figure>
<h3 id="check-version"><a href="#check-version" class="headerlink" title="check version"></a>check version</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue --version</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># or</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">vue -V</span></pre></td></tr></table></figure>
<h2 id="fixed-yarn"><a href="#fixed-yarn" class="headerlink" title="fixed yarn"></a>fixed yarn</h2><h3 id="clean-yarn-cache"><a href="#clean-yarn-cache" class="headerlink" title="clean yarn cache"></a>clean yarn cache</h3><p>yarn 更新至 v1.19.0 後，一度在終端機一直跳提醒，google 到的解法是清除 cache。<br>但目前已是 v1.22.0 已無目前問題。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn update v1.19.0 後，需清除一次 cache，指令如下：</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn cache clean</span></pre></td></tr></table></figure>
<h2 id="build-project"><a href="#build-project" class="headerlink" title="build project"></a>build project</h2><h3 id="version-not-match-error"><a href="#version-not-match-error" class="headerlink" title="version not match error"></a>version not match error</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">若出現vue的版本為 2.6.9，但套件採用 2.6.10 的 error</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">需升級vue的版本，指令如下：</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn global add vue@2.6.11</span></pre></td></tr></table></figure>
<h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue create project-name</span></pre></td></tr></table></figure>
<h3 id="選擇需要的項目"><a href="#選擇需要的項目" class="headerlink" title="選擇需要的項目"></a>選擇需要的項目</h3><p>官方預設提供的 css 預處理器，存在一些配置上的錯誤，這邊不做使用<br>僅選擇 Router &amp; Vuex(單元測試和 PWA 尚未掌握)<br>Router 採用 History Mode</p>
<h3 id="進入項目並啟動"><a href="#進入項目並啟動" class="headerlink" title="進入項目並啟動"></a>進入項目並啟動</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd project</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn server</span></pre></td></tr></table></figure>
<h2 id="install-Plugins"><a href="#install-Plugins" class="headerlink" title="install Plugins"></a>install Plugins</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add axios vue-axios</span></pre></td></tr></table></figure>
<h3 id="驗證"><a href="#驗證" class="headerlink" title="驗證"></a>驗證</h3><p><a href="https://github.com/vuelidate/vuelidate" target="_blank" rel="noopener">vuelidate</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add vuelidate</span></pre></td></tr></table></figure>
<h3 id="拖曳"><a href="#拖曳" class="headerlink" title="拖曳"></a>拖曳</h3><p><a href="https://github.com/SortableJS/Vue.Draggable" target="_blank" rel="noopener">vuedraggable</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add vuedraggable</span></pre></td></tr></table></figure>
<h3 id="預處理器"><a href="#預處理器" class="headerlink" title="預處理器"></a>預處理器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; pug</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn add vue-cli-plugin-pug --dev</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; scss</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn add vue-cli-plugin-pug sass sass-loader --dev</span></pre></td></tr></table></figure>
<h2 id="專案結構"><a href="#專案結構" class="headerlink" title="專案結構"></a>專案結構</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assets</span></pre></td></tr><tr><td class="code"><pre><span class="line">components</span></pre></td></tr><tr><td class="code"><pre><span class="line">views</span></pre></td></tr></table></figure>
<h3 id="scss"><a href="#scss" class="headerlink" title="scss"></a>scss</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assets</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - scss</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - color.scss &#x3D;&gt; 基礎共用色碼</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - mixin.scss &#x3D;&gt; 基礎共用函式</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - share.scss &#x3D;&gt; @import 上面兩個基礎共用scss，建立共用參數</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - style.scss &#x3D;&gt; @import share.scss &#x3D;&gt; 全域 scss，權重最重，在此處 reset css</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">main.js</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - import &#39;scss&#x2F;style.scss&#39;</span></pre></td></tr></table></figure>
<h4 id="scss-gt-vue-config-js"><a href="#scss-gt-vue-config-js" class="headerlink" title="scss =&gt; vue.config.js"></a>scss =&gt; vue.config.js</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 調整相對路徑，方便 component 引入樣式</span></pre></td></tr><tr><td class="code"><pre><span class="line">chainWebpack: config &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  config.resolve.alias</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .set(&#39;scss&#39;, resolve(&#39;src&#x2F;assets&#x2F;scss&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="router"><a href="#router" class="headerlink" title="router"></a>router</h3><p>拆分為 index.js 和 map.js<br>當頁面數過多時，將 routes 抽離至 map.js，再載入到 index.js</p>
<h3 id="webpack-設定"><a href="#webpack-設定" class="headerlink" title="webpack 設定"></a>webpack 設定</h3><p>建立 vue.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">function resolve (dir) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return path.join(__dirname, dir)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  publicPath: &#39;&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; 調整本地端口</span></pre></td></tr><tr><td class="code"><pre><span class="line">  devServer: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    host: &#39;localhost&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    port: 8081,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 設置代理 &#x3D;&gt; 解決跨域問題(調用後端API接口時通常不是同一個域名)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    proxy: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#39;&#x2F;api&#39;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        target: &#39;http:&#x2F;&#x2F;localhost:8081&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; websocket 縮寫 &#x3D;&gt; ws</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ws: false,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 避免在訪問網址時，自動將原點移除</span></pre></td></tr><tr><td class="code"><pre><span class="line">        changeOrigin: false</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  chainWebpack: (config) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    config.resolve.alias</span></pre></td></tr><tr><td class="code"><pre><span class="line">      .set(&#39;@&#39;, resolve(&#39;src&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6：解構賦值</title>
    <url>/2020/02/09/es6/destructuring/</url>
    <content><![CDATA[<p>解構賦值簡單來說，就是輕便且快速地取出元素。</p>
<a id="more"></a>
<h2 id="陣列解構"><a href="#陣列解構" class="headerlink" title="陣列解構"></a>陣列解構</h2><p>若有一個陣列如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numArray &#x3D; [2, 4, 6]</span></pre></td></tr></table></figure>
<p>可以透過下面兩種方法進行解構</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法一</span></pre></td></tr><tr><td class="code"><pre><span class="line">let [subNode, subItem] &#x3D; numArray</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法二</span></pre></td></tr><tr><td class="code"><pre><span class="line">let subNode</span></pre></td></tr><tr><td class="code"><pre><span class="line">let subItem</span></pre></td></tr><tr><td class="code"><pre><span class="line">[subNode, subItem] &#x3D; numArray</span></pre></td></tr></table></figure>
<p>這兩種方法，都會拿到相同結果。當陣列解構後，就可以進行一般運算或處理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let res &#x3D; subNode * subItem</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(res)  &#x2F;&#x2F; 印出8</span></pre></td></tr></table></figure>
<h2 id="預設值"><a href="#預設值" class="headerlink" title="預設值"></a>預設值</h2><p>如果無法預期拿到陣列內容為何？透過預設值，可以避免缺少值的問題。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numArray &#x3D; [2, 4]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">let [first, second, third] &#x3D; numArray</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">first + second + third  &#x2F;&#x2F; 這邊做計算的話，會產生 NaN</span></pre></td></tr></table></figure>
<p>但如果透過預設值為0，則能避免上面的問題</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let [first, second, third &#x3D; 0] &#x3D; numArray</span></pre></td></tr></table></figure>
<h2 id="忽略元素"><a href="#忽略元素" class="headerlink" title="忽略元素"></a>忽略元素</h2><p>意指，僅調用陣列中某一元素。可以透過前面的值為空，但逗號保留的方式來進行忽略元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numArray &#x3D; [2, 4, 8, 10]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">let [, , , item] &#x3D; numArray</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(item)</span></pre></td></tr></table></figure>
<h2 id="變數交換"><a href="#變數交換" class="headerlink" title="變數交換"></a>變數交換</h2><p>透過陣列的形式，進行陣列解構的變數交換</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; 2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">let b &#x3D; 4;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[a, b] &#x3D; [b, a]</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(a) &#x2F;&#x2F; 印出 4</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(b) &#x2F;&#x2F; 印出 2</span></pre></td></tr></table></figure>
<h2 id="剩餘部分重組"><a href="#剩餘部分重組" class="headerlink" title="剩餘部分重組"></a>剩餘部分重組</h2><p>去除原始陣列中部分元素，透過 <code>...</code> 的方式，將剩餘的元素重組成新陣列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numArray &#x3D; [1, 3, 5, 7, 9]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">let [first, ...node] &#x3D; numArray</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(node) &#x2F;&#x2F; 印出 [3, 5, 7, 9]</span></pre></td></tr></table></figure>
<h2 id="物件解構"><a href="#物件解構" class="headerlink" title="物件解構"></a>物件解構</h2><p>類似陣列解構，將變數快速賦值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let itemObj &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  a: 10,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  b: 20</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">let &#123;a, b&#125; &#x3D; itemObj</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(a) &#x2F;&#x2F; 印出 10</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(b) &#x2F;&#x2F; 印出 20</span></pre></td></tr></table></figure>
<p>物件解構，同樣可以給予預設值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123;a, b, c &#x3D; 0&#125; &#x3D; itemObj</span></pre></td></tr></table></figure>
<p>改變變數名稱，解構時，冒號左側的 <code>key</code> 值必須維持和物件中相同，但右側可以命名新的變數。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let itemObj &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  a: 10,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  b: 35</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">let &#123;a:x, b:y&#125; &#x3D; itemObj</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(y) &#x2F;&#x2F; 印出 35</span></pre></td></tr></table></figure>
<h2 id="解構函式"><a href="#解構函式" class="headerlink" title="解構函式"></a>解構函式</h2><p>透過解構傳進來的參數，精簡程式碼</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function distance(point) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let &#123;x, y&#125; &#x3D; point</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return Math.sqrt(x*x + y*y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>但是解構函式，更進階的用法是，在參數內直接解構</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function distance(&#123;x, y&#125;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return Math.sqrt(x*x + y*y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>因此既能給予預設值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function distance(&#123;x &#x3D; 0, y&#125;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return Math.sqrt(x*x + y*y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>也能重新命名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function distance(&#123;x:a, y&#125;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return Math.sqrt(a*a + y*y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6：筆記整理</title>
    <url>/2020/02/09/es6/note/</url>
    <content><![CDATA[<p>整理散落各方的 ES6 筆記，方便自己日後查詢。</p>
<a id="more"></a>
<h2 id="變數宣告"><a href="#變數宣告" class="headerlink" title="變數宣告"></a>變數宣告</h2><p>傳統變數宣告採用 <code>var</code> 的方式，但容易存在污染環境的問題。因此在 ES6 的語法中，新增兩個變數宣告方式 <code>let、const</code>。</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>使用 const 定義常數，意味著這個變數不作變動，且要求一定要賦值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a &#x3D; 1</span></pre></td></tr></table></figure>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>和傳統的<code>var</code>相似，側重解決過往的 scope(執行環境)問題。使用<code>let</code>宣告變數時，僅會作用在當前區域，且可以選擇賦值或不賦值，通常以 function 本身為分界。</p>
<ul>
<li>var<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (true) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    var b &#x3D; 10</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(b) &#x2F;&#x2F; 印出 10</span></pre></td></tr></table></figure></li>
<li>let<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (true) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    let c &#x3D; 20</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(c) &#x2F;&#x2F; error，c is not defined</span></pre></td></tr></table></figure>
<h2 id="樣板字面值-模板字符串-Template-literals"><a href="#樣板字面值-模板字符串-Template-literals" class="headerlink" title="樣板字面值(模板字符串) Template literals"></a>樣板字面值(模板字符串) Template literals</h2>過往<code>ES5</code>寫法如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(&quot;My name is &quot; + name)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 印出 My name is Pitt</span></pre></td></tr></table></figure>
修改為<code>ES6</code>時，則需調整寫法如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let name &#x3D; &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(&#96;My name is $&#123;name&#125;&#96;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 同樣印出 My name is Pitt</span></pre></td></tr></table></figure>
最外圍使用倒鉤符號包裹，先用$符號聲明，再用{}包覆變數。<h3 id="多行字串"><a href="#多行字串" class="headerlink" title="多行字串"></a>多行字串</h3><code>ES5</code>寫法中，多行字串使用<code>\n</code>，但在<code>ES6</code>中，若使用倒鉤符號包裹後，自動換行即可，寫法如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let msg &#x3D;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#96;&lt;span&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Hello World!</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;span&gt;&#96;</span></pre></td></tr></table></figure>
<h2 id="展開與其餘運算符"><a href="#展開與其餘運算符" class="headerlink" title="展開與其餘運算符"></a>展開與其餘運算符</h2>用法為<code>...</code>，常用於陣列合併或是複製陣列。<br>合併用法如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; [1, 2, 3]</span></pre></td></tr><tr><td class="code"><pre><span class="line">let b &#x3D; [4, 5, 6]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">let c &#x3D; [...a, ...b]</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(c)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 印出 [1, 2, 3, 4, 5, 6]</span></pre></td></tr></table></figure>
複製陣列後修改其中的值：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let d &#x3D; [...c]</span></pre></td></tr><tr><td class="code"><pre><span class="line">d[2] &#x3D; 7</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(d)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 印出 [1, 2, 7, 4, 5, 6]，而此時的c陣列是不受影響的</span></pre></td></tr></table></figure>
<h2 id="import-module"><a href="#import-module" class="headerlink" title="import module"></a>import module</h2>在<code>ES6</code>語法中，JS開始原生支援模組系統，用法如下：<br>先建立一個引用的<code>HTML</code>檔案，同時引用js檔案時，需注意<code>type = module</code>，寫法如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;.&#x2F;index.js&quot; type&#x3D;&quot;module&quot;&gt;&lt;&#x2F;script&gt;</span></pre></td></tr></table></figure>
準備一個<code>index.js</code>檔案來載入導出的資料，再準備一個<code>module.js</code>來導出資料<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; index.js</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import &#123; data, userData &#125; from &#39;.&#x2F;module.js&#39;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(data)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(userData)</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; module.js</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">export const data &#x3D; [1, 2, 3]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">export const userData &#x3D; [&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#39;id&#39;: &#39;first&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#39;name&#39;: &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;]</span></pre></td></tr></table></figure>
如此便完成最基礎的<code>import</code>和<code>export</code>。</li>
</ul>
]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Node 基礎知識</title>
    <url>/2020/01/27/node/basic/</url>
    <content><![CDATA[<p>記錄自己學習 Node.js 基礎API用法。</p>
<a id="more"></a>
<h2 id="require、module-exports"><a href="#require、module-exports" class="headerlink" title="require、module exports"></a>require、module exports</h2><p><code>require</code>語法可以載入檔案，反之<code>module.exports</code>則能導出內容。寫法如下：<br>app.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let content &#x3D; require(&#39;.&#x2F;app2&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(content)</span></pre></td></tr></table></figure>
<p>app2.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let data &#x3D; &#39;node-test&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">module.exports &#x3D; data</span></pre></td></tr></table></figure>
<p>印出<code>&#39;node-test&#39;</code>字串。</p>
<p>除此之外也能放入物件格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  title: data,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  subTitle: &#39;title-test&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>印出對應的物件。</p>
<h3 id="相對冷門寫法"><a href="#相對冷門寫法" class="headerlink" title="相對冷門寫法"></a>相對冷門寫法</h3><p>一般導出寫法多採用<code>module.exports</code>，但單純使用<code>exports</code>也能導出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exports.subContent &#x3D; 123</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 這個寫法等於建立一個物件，如下：</span></pre></td></tr><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    subContent: 123</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;除了物件外，也能調用函式</span></pre></td></tr><tr><td class="code"><pre><span class="line">exports.call &#x3D; (() &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return &#39;call!&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h2 id="http-API"><a href="#http-API" class="headerlink" title="http API"></a>http API</h2><h3 id="createServer"><a href="#createServer" class="headerlink" title="createServer"></a>createServer</h3><p>Node 原生 http API 用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const http &#x3D; require(&#39;http&#39;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; request 使用者發出請求，常縮寫為 req</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; response 回傳結果，常縮寫為 res</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">http.createServer((req, res) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; 表頭內容</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text&#x2F;plain&quot; &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; 回傳結果內容</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.write(&#39;Hello Node!&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; 結束</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.end()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;).listen(8081) &#x2F;&#x2F; 監聽 port</span></pre></td></tr></table></figure>
<h2 id="查詢路徑或檔案名稱"><a href="#查詢路徑或檔案名稱" class="headerlink" title="查詢路徑或檔案名稱"></a>查詢路徑或檔案名稱</h2><p><code>__dirname</code>語法，可以查詢到當前檔案所在的路徑。<br><code>__filename</code>語法，則能檢查當前檔案名稱。</p>
<h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>Node 原生 path API 用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 抓目錄路徑，回傳 &#x2F;Path&#x2F;subNode</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(path.dirname(&#39;&#x2F;Path&#x2F;subNode&#x2F;index.js&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 路徑合併</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(path.join(__dirname, &#39;&#x2F;Path&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 抓取檔案名稱，回傳 index.js</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(path.basename(&#39;&#x2F;Path&#x2F;subNode&#x2F;index.js&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 抓副檔名，回傳 .js</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(path.extname(&#39;&#x2F;Path&#x2F;subNode&#x2F;index.js&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 分析路徑</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(path.parse(&#39;&#x2F;Path&#x2F;subNode&#x2F;index.js&#39;))</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>關於 Gulp</title>
    <url>/2020/01/21/gulp/</url>
    <content><![CDATA[<p>前端的工具的進化速度，蠻令人感慨的，2017 年甫入行時，Gulp 已經相對式微了，webpack 逐漸站穩舞台。</p>
<p>但即便如此，倘若是做一些輕量頁面或專案，或許 Gulp 仍是不錯的選擇，也或者可能會維護到一些舊專案。因此這邊簡單記錄一些關於 Gulp 的筆記。</p>
<a id="more"></a>
<h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><p>全域環境安裝 gulp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn global add gulp</span></pre></td></tr></table></figure>

<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir project-name</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">cd project-name</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn init</span></pre></td></tr></table></figure>

<h3 id="local-install"><a href="#local-install" class="headerlink" title="local install"></a>local install</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install gulp --save</span></pre></td></tr></table></figure>

<h3 id="簡易任務指令"><a href="#簡易任務指令" class="headerlink" title="簡易任務指令"></a>簡易任務指令</h3><p>建立兩個測試檔案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - source</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - index.html</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - gulpfile.js</span></pre></td></tr></table></figure>
<p>gulpfile.js 建立任務</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const gulp &#x3D; require(&#39;gulp&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; gulp.task &#x3D;&gt; gulp 任務</span></pre></td></tr><tr><td class="code"><pre><span class="line">gulp.task(&#39;copyHTML&#39;, function () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;* </span></pre></td></tr><tr><td class="code"><pre><span class="line">    gulp.src &#x3D;&gt; 資料來源</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;雙星號&#x2F;*.html &#x3D;&gt; 抓出 source 底下所有 html 檔案</span></pre></td></tr><tr><td class="code"><pre><span class="line">  *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return gulp.src(&#39;.&#x2F;source&#x2F;**&#x2F;*.html&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .pipe(gulp.dest(&#39;.&#x2F;public&#x2F;&#39;))  &#x2F;&#x2F; 輸出資料到指定資料夾</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<p>終端機運行 gulp copyHTML，建立 public 資料夾，導入 html 文件</p>
<h3 id="gulp-pug"><a href="#gulp-pug" class="headerlink" title="gulp-pug"></a>gulp-pug</h3><p>install command</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install gulp-pug --save</span></pre></td></tr></table></figure>
<p>gulpfile.js =&gt; build task</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const pug &#x3D; require(&#39;gulp-pug&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">gulp.task(&#39;pug&#39;, function buildHTML() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return gulp.src(&#39;.&#x2F;source&#x2F;**&#x2F;*.pug&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .pipe(pug(&#123;&#125;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .pipe(gulp.dest(&#39;.&#x2F;public&#x2F;&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<p>run</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp pug</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以看到 public 底下建立一個編譯後的 html 文件</span></pre></td></tr></table></figure>

<h3 id="gulp-sass"><a href="#gulp-sass" class="headerlink" title="gulp-sass"></a>gulp-sass</h3><p>install command</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install gulp-sass --save</span></pre></td></tr></table></figure>
<p>資料夾結構</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - source</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - scss</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - style.scss</span></pre></td></tr></table></figure>
<p>gulpfile.js =&gt; build task</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const sass &#x3D; require(&#39;gulp-sass&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">gulp.task(&#39;sass&#39;, function () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return gulp.src(&#39;.&#x2F;source&#x2F;scss&#x2F;**&#x2F;*.scss&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .pipe(sass().on(&#39;error&#39;, sass.logError))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .pipe(gulp.dest(&#39;.&#x2F;public&#x2F;css&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<p>使用 watch 方法來監聽 scss 的變化進行編譯。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp.task(&#39;watch&#39;, function () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  gulp.watch(&#39;.&#x2F;source&#x2F;scss&#x2F;**&#x2F;*.scss&#39;, gulp.series(&#39;sass&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<h3 id="4-0-版本的寫法改變"><a href="#4-0-版本的寫法改變" class="headerlink" title="4.0 版本的寫法改變"></a>4.0 版本的寫法改變</h3><p>gulp 在 4.0 版本後，調整了部分寫法：<br>gulp.series  // 按照順序執行<br>gulp.paralle // 並行執行</p>
<p>合併任務寫法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp.task(&#39;default&#39;, gulp.series(&#39;pug&#39;, &#39;sass&#39;, &#39;watch&#39;))</span></pre></td></tr></table></figure>

<h3 id="gulp-postcss"><a href="#gulp-postcss" class="headerlink" title="gulp-postcss"></a>gulp-postcss</h3><p>透過後處理器，來進一步強化 css，譬如 autoprefixer 可以自動加入前綴詞來兼容舊瀏覽器<br>install commend</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install gulp-postcss autoprefixer --save</span></pre></td></tr></table></figure>
<p>gulpfile.js =&gt; build task</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const postcss &#x3D; require(&#39;gulp-postcss&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">const autoprefixer &#x3D; require(&#39;autoprefixer&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">gulp.task(&#39;sass&#39;, function () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  const plugins &#x3D; [</span></pre></td></tr><tr><td class="code"><pre><span class="line">    autoprefixer()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return gulp.src(&#39;.&#x2F;source&#x2F;scss&#x2F;**&#x2F;*.scss&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .pipe(sass().on(&#39;error&#39;, sass.logError))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .pipe(postcss(plugins))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .pipe(gulp.dest(&#39;.&#x2F;public&#x2F;css&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<p>build .browserslistrc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - .browserslistrc</span></pre></td></tr></table></figure>
<p>內容寫入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Browsers that we support</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">last 5 version</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; 1%</span></pre></td></tr><tr><td class="code"><pre><span class="line">IE 10 # sorry</span></pre></td></tr></table></figure>

<h3 id="gulp-load-plugins"><a href="#gulp-load-plugins" class="headerlink" title="gulp-load-plugins"></a>gulp-load-plugins</h3><p>優化 gulp 相關套件，節省程式碼</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install gulp-load-plugins --save</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">const $ &#x3D; require(&#39;gulp-load-plugins&#39;)()</span></pre></td></tr></table></figure>
<p>使用 gulp-load-plugins 後，只要是 gulp- 開頭的套件，都可以無需特別 require，僅只要在對應名稱前面加上 $，範例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.pipe($.pug(&#123;&#125;))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">.pipe($.postcss(plugins))</span></pre></td></tr></table></figure>
<p>刪除原先的程式碼，促使專案更為精簡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; const pug &#x3D; require(&#39;gulp-pug&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; const sass &#x3D; require(&#39;gulp-sass&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; const postcss &#x3D; require(&#39;gulp-postcss&#39;)</span></pre></td></tr></table></figure>

<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>install commend</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save gulp-sourcemaps gulp-babel gulp-concat @babel&#x2F;core @babel&#x2F;preset-env</span></pre></td></tr></table></figure>
<p>gulpfile.js =&gt; build task</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp.task(&#39;babel&#39;, async () &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  gulp.src(&#39;.&#x2F;source&#x2F;js&#x2F;**&#x2F;*.js&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; .pipe(sourcemaps.init())</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .pipe($.babel(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      presets: [&#39;@babel&#x2F;env&#39;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .pipe($.concat(&#39;all.js&#39;))  &#x2F;&#x2F; 將所有 js 檔進行合併</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; .pipe(sourcemaps.write(&#39;.&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .pipe(gulp.dest(&#39;.&#x2F;public&#x2F;js&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 知識整理</title>
    <url>/2020/01/14/vue-basic/</url>
    <content><![CDATA[<p>雖然之前的工作使用 Vue，但很多時候只是依循主管前輩的用法而用，沒有實際去理解一些細節或是框架的原理，因此逐步整理成筆記。</p>
<a id="more"></a>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ul>
<li><p>computed<br>我們都知道 computed 是用於計算後回傳結果，但 computed 本身還帶有緩存的特性，這個特性意味著，如果 data 中的資料，我們沒有進行改變的情況下，computed 是不會再次被觸發的。</p>
</li>
<li><p>v-if &amp;&amp; v-show<br>剛開始工作時，用過一小段時間的 v-show，但很快地在團隊開發中，就不再使用 v-show 而全面改用 v-if。v-if 可以說本身就帶有生命週期中的銷毀性質，打開 F12 可以看到，當不滿足條件時，v-if 連 dom 結構都不會渲染，反之，v-show 則是採用 css 中的 display: none; 的屬性來隱藏不滿足條件的元素，但本身還是會被渲染出來。</p>
</li>
</ul>
<p>雖然之前工作幾乎多以 v-if 來判斷，但其實如果考慮到效能，v-show 在一些頻繁切換的場景，應該使用它，譬如我做一個 login &amp; register 的頁面，通常現在的設計，可能會使用 table-card 的形式來切換兩邊，蠆這個情景下，我確實應該考慮使用 v-show。</p>
<ul>
<li>v-for 的 key<br>眾所周知，v-for 用於在 template 上跑 array 或是 object，但是此前的開發，並沒有明確要求撰寫 v-for 時也必須綁上 key，通常是忽略不寫或根本沒意識到要寫。但實際上，按照嚴謹的寫法 key 應該要盡可能綁定資料中的唯一值，除非取得的資料中沒有 id 之類的值，才會考慮 index。當然 v-for 和前述的 v-if 不能共用，即使寫了也是會跳 error。</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul>
<li>click<br>在 Vue 當中一個 @click 事件被觸發時，假設我使用滑鼠點擊某一個元素時，他所觸發的事件對象，仍然是原生的事件，Vue 並沒有針對事件進行修飾或是修改。另一方面，我在哪一個元素上觸發事件，那麼，事件就會掛載在那個元素上，譬如 span 上觸發就掛載在 span 上。</li>
</ul>
<h2 id="父子組件的溝通"><a href="#父子組件的溝通" class="headerlink" title="父子組件的溝通"></a>父子組件的溝通</h2><p>最基礎的用法 =&gt; props(接收父組件傳來的值) &amp; $emit(向上傳值或是調用父組件的函式)，這部分就是單純的應用。</p>
]]></content>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 陣列&amp;物件 操作方法</title>
    <url>/2020/01/13/javascript/array-operating/</url>
    <content><![CDATA[<p>處理資料是開發 JS 過程中，常見的場景，如果是常用的資料格式，固然處理速度很快，解決方法也不難，但現實中，常會有一些特殊的情境。因此記錄各種操作方式，除了加深個人 JS 知識，未來若有類似場景，也能加速開發效率。</p>
<a id="more"></a>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>資料：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const playerData &#x3D; [&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    player: &#39;Pitt&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    job: &#39;witcher&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hp: 500</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    player: &#39;Mio&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    job: &#39;archer&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hp: 200</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    player: &#39;Ines&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    job: &#39;warrior&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hp: 600</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    player: &#39;Sue&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    job: &#39;archer&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hp: 200</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    player: &#39;Nicole&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    job: &#39;tank&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hp: 800</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    player: &#39;Nancy&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    job: &#39;mage&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hp: 200</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    player: &#39;Kuni&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    job: &#39;priest&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hp: 350</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">]</span></pre></td></tr></table></figure>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>將陣列中所有元素透過函式進行運算，相較於過往的<code>for</code>迴圈寫法，更為簡潔：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let totalHP &#x3D; 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">playerData.forEach((node, index) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  totalHP &#x3D; totalHP + node.hp</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(totalHP) &#x2F;&#x2F; 2850</span></pre></td></tr></table></figure>
<p>改變陣列中所有元素的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">playerData.forEach((node, index) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  node.hp &#x3D; node.hp + 250</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(playerData)</span></pre></td></tr></table></figure>

<h3 id="for-舊式用法，現多已不使用"><a href="#for-舊式用法，現多已不使用" class="headerlink" title="for(舊式用法，現多已不使用)"></a>for(舊式用法，現多已不使用)</h3><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>尋找陣列中所有符合函式條件的元素進行回傳</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const filterArr &#x3D; playerData.filter((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return node.job &#x3D;&#x3D;&#x3D; &#39;archer&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(filterArr) &#x2F;&#x2F; Mio、Sue</span></pre></td></tr></table></figure>
<p>若沒有符合條件的元素，則回傳空陣列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const filterArr &#x3D; playerData.filter((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return node.hp &lt; 50</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(filterArr) &#x2F;&#x2F; []</span></pre></td></tr></table></figure>
<p>判斷目錄餘數為1的條件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const filterArr &#x3D; playerData.filter((node, index) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return index % 2 &#x3D;&#x3D;&#x3D; 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(filterArr) &#x2F;&#x2F; [Mio、Sue、Nancy]</span></pre></td></tr></table></figure>

<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>近似於<code>filter</code>，但不同的點在於當找到陣列中第一個符合的元素時，即進行回傳，若陣列中沒有符合的值，則回傳<code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const findArr &#x3D; playerData.find((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return node.hp &gt; 1000</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(findArr) &#x2F;&#x2F; undefined</span></pre></td></tr></table></figure>
<p>找到陣列中第一個符合的值即回傳(適合用於進行<code>formatter</code>翻譯)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const findArr &#x3D; playerData.find((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return node.job &#x3D;&#x3D;&#x3D; &#39;archer&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(findArr) &#x2F;&#x2F; Mio</span></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map()</code>方法透過函式，將原始陣列進行重組後，回傳一個新的陣列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mapArr1 &#x3D; playerData.map((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return node.hp + 100</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(mapArr1)</span></pre></td></tr></table></figure>
<p>但這個方法本身有兩個條件，其一，一定會回傳值，若條件不符合則回傳<code>undefined</code>。其二，新的陣列長度等於原始陣列長度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mapArr2 &#x3D; playerData.map((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(mapArr2) &#x2F;&#x2F; 新陣列中會拿到全是 undefined</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mapArr3 &#x3D; playerData.map((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  if (node.hp &gt; 300) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return &#96;血量大於300的職業：$&#123;node.job&#125;&#96;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125; else return &#96;脆皮職業：$&#123;node.job&#125;&#96;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(mapArr3)</span></pre></td></tr></table></figure>

<h3 id="every"><a href="#every" class="headerlink" title="every"></a>every</h3><p>將陣列中所有元素帶入函式，並根據函式的要求進行判斷，若有一個元素不符合要求，則回傳<code>false</code>，反之，則回傳<code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const everyArray &#x3D; playerData.every((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return node.hp &gt; 400</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(everyArray) &#x2F;&#x2F; false</span></pre></td></tr></table></figure>

<h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><p>和<code>every()</code>非常相近，同樣都是回傳<code>true、false</code>，不過差別在於判斷條件，<code>some()</code>僅需陣列中任一元素符合條件，即回傳<code>true</code>。當然，若全部條件皆不符合，則回傳<code>false</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const somArray &#x3D; playerData.some((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return node.hp &gt; 500</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(somArray)</span></pre></td></tr></table></figure>

<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://www.oxxostudio.tw/articles/201908/js-array.html#array_every" target="_blank" rel="noopener">JavaScript Array 陣列操作方法大全 ( 含 ES6 )</a></li>
<li><a href="https://wcc723.github.io/javascript/2017/06/29/es6-native-array/#Array-prototype-some" target="_blank" rel="noopener">JavaScript 陣列處理方法</a></li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>NVM 常用指令</title>
    <url>/2019/12/09/node/nvm-instruction/</url>
    <content><![CDATA[<p>記錄常用 NVM 指令。</p>
<a id="more"></a>
<h4 id="查詢遠端可安裝的-node-版本"><a href="#查詢遠端可安裝的-node-版本" class="headerlink" title="查詢遠端可安裝的 node 版本"></a>查詢遠端可安裝的 node 版本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm ls-remote</span></pre></td></tr></table></figure>
<h4 id="安裝所需的版本號"><a href="#安裝所需的版本號" class="headerlink" title="安裝所需的版本號"></a>安裝所需的版本號</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm install v12.16.2</span></pre></td></tr></table></figure>
<h4 id="切換所需使用的-node-版本"><a href="#切換所需使用的-node-版本" class="headerlink" title="切換所需使用的 node 版本"></a>切換所需使用的 node 版本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm use v12.16.2</span></pre></td></tr></table></figure>
<h4 id="設定預設使用的-node-版本"><a href="#設定預設使用的-node-版本" class="headerlink" title="設定預設使用的 node 版本"></a>設定預設使用的 node 版本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm alias default v12.16.2</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>NVM</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6：類別與物件的基本觀念</title>
    <url>/2019/12/02/es6/object/</url>
    <content><![CDATA[<p>關於類別與物件的基本觀念。</p>
<a id="more"></a>
<h2 id="什麼是類別與物件"><a href="#什麼是類別與物件" class="headerlink" title="什麼是類別與物件"></a>什麼是類別與物件</h2><h3 id="舉例來說"><a href="#舉例來說" class="headerlink" title="舉例來說"></a>舉例來說</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">類別，可以理解為設計圖</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">物件，則是根據設計圖製造出來的實體</span></pre></td></tr></table></figure>
<h4 id="馬克杯"><a href="#馬克杯" class="headerlink" title="馬克杯"></a>馬克杯</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我們可以請設計師，繪出一個馬克杯的設計稿</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">接著，工廠可以根據設計圖，製造出無數的馬克杯</span></pre></td></tr></table></figure>
<h4 id="回到程式語言"><a href="#回到程式語言" class="headerlink" title="回到程式語言"></a>回到程式語言</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我們可以使用一個類別設計，產生無數個物件實體</span></pre></td></tr></table></figure>
<h4 id="關鍵字"><a href="#關鍵字" class="headerlink" title="關鍵字"></a>關鍵字</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在類別中，我們會使用到一些關鍵字</span></pre></td></tr><tr><td class="code"><pre><span class="line">class、constructor</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在物件中，則會使用到</span></pre></td></tr><tr><td class="code"><pre><span class="line">new</span></pre></td></tr></table></figure>
<h2 id="定義類別並產生物件"><a href="#定義類別並產生物件" class="headerlink" title="定義類別並產生物件"></a>定義類別並產生物件</h2><h3 id="寫法"><a href="#寫法" class="headerlink" title="寫法"></a>寫法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Car &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 利用已經定義好的類別，產生新的物件</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 再將 new Car() 產生的新物件，放入變數中</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car();</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car2 &#x3D; new Car();</span></pre></td></tr></table></figure>
<h3 id="定義建構式-constructor"><a href="#定義建構式-constructor" class="headerlink" title="定義建構式 (constructor)"></a>定義建構式 (constructor)</h3><ul>
<li>建構式：建立新物件時被呼叫的函式<h4 id="寫法-1"><a href="#寫法-1" class="headerlink" title="寫法"></a>寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Car &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 在類別中，定義建構式</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructor() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        console.log(&quot;呼叫建構式&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 利用已經定義好的類別，產生新的物件</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car();</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car2 &#x3D; new Car();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 上述流程</span></pre></td></tr><tr><td class="code"><pre><span class="line">定義類別 -&gt; 先呼叫建構式 -&gt; 執行完建構式內容 -&gt; 產生新物件 -&gt; 放入變數</span></pre></td></tr></table></figure>
<h3 id="定義與存取屬性-Attribute"><a href="#定義與存取屬性-Attribute" class="headerlink" title="定義與存取屬性 (Attribute)"></a>定義與存取屬性 (Attribute)</h3><h4 id="在建構式中建立屬性"><a href="#在建構式中建立屬性" class="headerlink" title="在建構式中建立屬性"></a>在建構式中建立屬性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor (參數) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    this.屬性名稱 &#x3D; 初始資料;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="寫法-2"><a href="#寫法-2" class="headerlink" title="寫法"></a>寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Car &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 在類別中，定義建構式</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructor() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.color &#x3D; &quot;blue&quot;; &#x2F;&#x2F; 建立新屬性 color，指定資料為&quot;blue&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 利用已經定義好的類別，產生新的物件</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car(); &#x2F;&#x2F; 新物件擁有 color 屬性，資料為&quot;blue&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car2 &#x3D; new Car(); &#x2F;&#x2F; 新物件擁有 color 屬性，資料為&quot;blue&quot;</span></pre></td></tr></table></figure>
<h4 id="透過參數，彈性建立新屬性，達到多個物件的差異"><a href="#透過參數，彈性建立新屬性，達到多個物件的差異" class="headerlink" title="透過參數，彈性建立新屬性，達到多個物件的差異"></a>透過參數，彈性建立新屬性，達到多個物件的差異</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Car &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 在類別中，定義建構式</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructor(color) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 透過新物件的參數，使屬性在賦值同時產生變化</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.color &#x3D; color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 利用已經定義好的類別，產生新的物件</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car(&quot;blue&quot;); &#x2F;&#x2F; 新物件擁有 color 屬性，資料為&quot;blue&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car2 &#x3D; new Car(&quot;red&quot;); &#x2F;&#x2F; 新物件擁有 color 屬性，資料為&quot;red&quot;</span></pre></td></tr></table></figure>
<h4 id="同一物件，更新屬性"><a href="#同一物件，更新屬性" class="headerlink" title="同一物件，更新屬性"></a>同一物件，更新屬性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Car &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 在類別中，定義建構式</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructor(color) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 透過新物件的參數，使屬性在賦值同時產生變化</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.color &#x3D; color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 利用已經定義好的類別，產生新的物件</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car(&quot;blue&quot;); &#x2F;&#x2F; 新物件擁有 color 屬性，資料為&quot;blue&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(car1.color); &#x2F;&#x2F; 取得屬性的資料，印出 blue</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">car1.color &#x3D; &quot;red&quot; &#x2F;&#x2F; 更新屬性資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(car1.color) &#x2F;&#x2F; 取得新的屬性資料，印出 red</span></pre></td></tr></table></figure>
<h3 id="定義、呼叫方法-Method"><a href="#定義、呼叫方法-Method" class="headerlink" title="定義、呼叫方法 (Method)"></a>定義、呼叫方法 (Method)</h3><h4 id="寫法-3"><a href="#寫法-3" class="headerlink" title="寫法"></a>寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Car &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 在類別中，定義建構式</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructor(color) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 透過新物件的參數，使屬性在賦值同時產生變化</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.color &#x3D; color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 定義一個 Run 方法，透過物件呼叫，並執行內部程式碼</span></pre></td></tr><tr><td class="code"><pre><span class="line">    run() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        console.log(&quot;Running&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 產生新物件，並且物件同時擁有 color 屬性和 run 方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car(&quot;blue&quot;);</span></pre></td></tr></table></figure>
<h4 id="call-method"><a href="#call-method" class="headerlink" title="call method"></a>call method</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Car &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 在類別中，定義建構式</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructor(color) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 透過新物件的參數，使屬性在賦值同時產生變化</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.color &#x3D; color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 定義一個 Run 方法，透過物件呼叫，並執行內部程式碼</span></pre></td></tr><tr><td class="code"><pre><span class="line">    run() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        console.log(&quot;Running&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car(&quot;blue&quot;); &#x2F;&#x2F; 產生新物件，並且物件同時擁有 color 屬性和 run 方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">car1.run(); &#x2F;&#x2F; call run method，並執行 run 內部的 code，印出 &quot;Running&quot;</span></pre></td></tr></table></figure>
<h4 id="綜合應用"><a href="#綜合應用" class="headerlink" title="綜合應用"></a>綜合應用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Car &#123; &#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructor(color) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.color &#x3D; color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.speed &#x3D; 0; &#x2F;&#x2F; 初始化車子速度為 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    run(val) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.speed &#x3D; val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        console.log(this.color + &quot;Car Running at&quot; + this.speed + &quot;km&#x2F;hr&quot; );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    stop() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.speed &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        console.log(this.color + &quot;Car is stopped&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 產生一個新物件，擁有 color、speed 屬性和 run、stop 方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car(&quot;red&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">car1.run(80);</span></pre></td></tr><tr><td class="code"><pre><span class="line">car1.stop();</span></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6：宣告變數與箭頭函式</title>
    <url>/2019/12/02/es6/const-arrow/</url>
    <content><![CDATA[<p>記錄自己學習 ES6 語法，對比 ES5 和 ES3 如何解決問題。</p>
<a id="more"></a>
<h2 id="var、let、const"><a href="#var、let、const" class="headerlink" title="var、let、const"></a>var、let、const</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">早期 javascript 只能用 var 宣告變數</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">在 ES6 版本後，添加 let、const 兩種方式</span></pre></td></tr></table></figure>
<h3 id="let、const"><a href="#let、const" class="headerlink" title="let、const"></a>let、const</h3><h4 id="let-用於宣告變數，可以選擇賦值或不賦值"><a href="#let-用於宣告變數，可以選擇賦值或不賦值" class="headerlink" title="let 用於宣告變數，可以選擇賦值或不賦值"></a>let 用於宣告變數，可以選擇賦值或不賦值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 賦值</span></pre></td></tr><tr><td class="code"><pre><span class="line">let a &#x3D; 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 不賦值</span></pre></td></tr><tr><td class="code"><pre><span class="line">let b;</span></pre></td></tr></table></figure>
<h4 id="const-用於宣告常數-不作變動-，一定要賦值"><a href="#const-用於宣告常數-不作變動-，一定要賦值" class="headerlink" title="const 用於宣告常數(不作變動)，一定要賦值"></a>const 用於宣告常數(不作變動)，一定要賦值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const c &#x3D; 10;</span></pre></td></tr></table></figure>
<h3 id="理解與應用"><a href="#理解與應用" class="headerlink" title="理解與應用"></a>理解與應用</h3><h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><p>傳統使用 var 宣告變數時，變數的 Scope(即影響範圍)，通常以 function 本身為分界</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (var i&#x3D;0;i&lt;3;i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	console.log(&quot;i:&quot;+i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(&quot;outside i:&quot;+i);</span></pre></td></tr></table></figure>
<h4 id="let-使用更嚴格的-Scope"><a href="#let-使用更嚴格的-Scope" class="headerlink" title="let (使用更嚴格的 Scope)"></a>let (使用更嚴格的 Scope)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (let i&#x3D;0;i&lt;3;i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	console.log(&quot;i:&quot;+i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(&quot;outside i:&quot;+i); &#x2F;&#x2F; error，i is not defined</span></pre></td></tr></table></figure>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a; &#x2F;&#x2F; 宣告變數，可以暫時不給資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">a &#x3D; 2; &#x2F;&#x2F; 變數中的資料可以變動</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">const b; &#x2F;&#x2F; error，常數宣告時，必須給定資料</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">const b &#x3D; 10; &#x2F;&#x2F; 正確，宣告常數同時給予資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">b &#x3D; 20; &#x2F;&#x2F; error，不能更動常數中的資料</span></pre></td></tr></table></figure>
<h3 id="比對-ES5-和-ES6-寫法"><a href="#比對-ES5-和-ES6-寫法" class="headerlink" title="比對 ES5 和 ES6 寫法"></a>比對 ES5 和 ES6 寫法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ES5</span></pre></td></tr><tr><td class="code"><pre><span class="line">Object.defineProperty(window, &quot;a&quot;, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    value: 1,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    writable: false,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(window.a)</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ES6</span></pre></td></tr><tr><td class="code"><pre><span class="line">const a &#x3D; 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(a)</span></pre></td></tr></table></figure>
<p>除了精簡程式碼，也讓寫法變得更輕鬆。</p>
<h2 id="Arrow-Function-箭頭函式"><a href="#Arrow-Function-箭頭函式" class="headerlink" title="Arrow Function (箭頭函式)"></a>Arrow Function (箭頭函式)</h2><h3 id="第一種：-參數列表-gt-回傳值"><a href="#第一種：-參數列表-gt-回傳值" class="headerlink" title="第一種：(參數列表) =&gt; (回傳值)"></a>第一種：(參數列表) =&gt; (回傳值)</h3><h4 id="傳統函式寫法"><a href="#傳統函式寫法" class="headerlink" title="傳統函式寫法"></a>傳統函式寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let add &#x3D; function (n1, n2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return n1+n2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h4 id="箭頭函式寫法"><a href="#箭頭函式寫法" class="headerlink" title="箭頭函式寫法"></a>箭頭函式寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let add &#x3D; (n1, n2) &#x3D;&gt; (n1+n2)</span></pre></td></tr></table></figure>
<h3 id="第二種：-參數列表-gt-函式內部程式"><a href="#第二種：-參數列表-gt-函式內部程式" class="headerlink" title="第二種：(參數列表) =&gt; {函式內部程式}"></a>第二種：(參數列表) =&gt; {函式內部程式}</h3><h4 id="傳統函式寫法-1"><a href="#傳統函式寫法-1" class="headerlink" title="傳統函式寫法"></a>傳統函式寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let add &#x3D; function (n1, n2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return n1+n2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h4 id="箭頭函式寫法-1"><a href="#箭頭函式寫法-1" class="headerlink" title="箭頭函式寫法"></a>箭頭函式寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let add &#x3D; (n1, n2) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return n1+n2</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h3 id="額外範例"><a href="#額外範例" class="headerlink" title="額外範例"></a>額外範例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let f &#x3D; () &#x3D;&gt; (5);</span></pre></td></tr><tr><td class="code"><pre><span class="line">let result &#x3D; f();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(result);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 印出 5</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let f &#x3D; (message) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">f(&quot;Hello, Pitt&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 印出 Hello, Pitt</span></pre></td></tr></table></figure>
<h3 id="匿名函式"><a href="#匿名函式" class="headerlink" title="匿名函式"></a>匿名函式</h3><h4 id="傳統寫法"><a href="#傳統寫法" class="headerlink" title="傳統寫法"></a>傳統寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(function()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(&quot;過了5秒&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;, 5000);</span></pre></td></tr></table></figure>
<h4 id="箭頭函式寫法-2"><a href="#箭頭函式寫法-2" class="headerlink" title="箭頭函式寫法"></a>箭頭函式寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(&quot;過了5秒&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;, 5000);</span></pre></td></tr></table></figure>
<h3 id="參數預設值"><a href="#參數預設值" class="headerlink" title="參數預設值"></a>參數預設值</h3><h4 id="傳統寫法-1"><a href="#傳統寫法-1" class="headerlink" title="傳統寫法"></a>傳統寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function show(message) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (typeof message &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        message &#x3D; &quot;default&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    alert(message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">show(&quot;Pitt&quot;); &#x2F;&#x2F; 顯示 Pitt</span></pre></td></tr><tr><td class="code"><pre><span class="line">show(); &#x2F;&#x2F; 顯示 default</span></pre></td></tr></table></figure>
<h4 id="箭頭函式寫法-3"><a href="#箭頭函式寫法-3" class="headerlink" title="箭頭函式寫法"></a>箭頭函式寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 若未給定參數資料，則直接採用等號後的賦值</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">function show(message&#x3D;&quot;default&quot;)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    alert(message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">show(&quot;Hello&quot;); &#x2F;&#x2F; 顯示 Hello</span></pre></td></tr><tr><td class="code"><pre><span class="line">show(); &#x2F;&#x2F; 顯示 default</span></pre></td></tr></table></figure>
<h4 id="額外範例-1"><a href="#額外範例-1" class="headerlink" title="額外範例"></a>額外範例</h4><h5 id="範例一：傳統寫法"><a href="#範例一：傳統寫法" class="headerlink" title="範例一：傳統寫法"></a>範例一：傳統寫法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function multiply(n1, n2&#x3D;2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return n1 + n2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">multiply(2, 3); &#x2F;&#x2F; 回傳 6</span></pre></td></tr><tr><td class="code"><pre><span class="line">multiply(); &#x2F;&#x2F; 回傳 4</span></pre></td></tr></table></figure>
<h5 id="範例一：箭頭函式寫法"><a href="#範例一：箭頭函式寫法" class="headerlink" title="範例一：箭頭函式寫法"></a>範例一：箭頭函式寫法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let multiply&#x3D;(n1, n2&#x3D;2) &#x3D;&gt; (n1+n2);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">multiply(2, 3); &#x2F;&#x2F; 回傳 6</span></pre></td></tr><tr><td class="code"><pre><span class="line">multiply(); &#x2F;&#x2F; 回傳 4</span></pre></td></tr></table></figure>
<h5 id="範例二"><a href="#範例二" class="headerlink" title="範例二"></a>範例二</h5><p>後方的參數可以使用前方的參數進行運算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function combine(first&#x3D;&quot;Pitt&quot;, last&#x3D;&quot;Wu&quot;, name&#x3D;first+&quot; &quot;+last) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">combine(&quot;Nini&quot;, &quot;Ya&quot;); &#x2F;&#x2F; 顯示 Nini Ya</span></pre></td></tr><tr><td class="code"><pre><span class="line">combine(&quot;Nini&quot;); &#x2F;&#x2F; 顯示 Nini Wu</span></pre></td></tr><tr><td class="code"><pre><span class="line">combine(); &#x2F;&#x2F; 顯示 Pitt Wu</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub + Netlify = Auto Deploy Hexo Post</title>
    <url>/2019/12/01/hexo/auto-deploy/</url>
    <content><![CDATA[<p>回歸 Hexo 寫技術筆記後，就一直懷念 Gatsby.js 可以透過 Netlify 自動推送部署，花了點時間 Google，終於也找到 Hexo 的自動部署方式，一整個對寫文章非常方便。</p>
<a id="more"></a>
<ul>
<li>step 1：<br>  先在 GitHub 建立遠端 repository</li>
<li>step 2：<br>  copy repository 的 url</li>
<li>step 3：<br>  回到 project 內，將本地和遠端進行關聯  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;your-githubname&#x2F;your-repository</span></pre></td></tr></table></figure></li>
<li>step 4：<br>  進行 commit  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .&#x2F;</span></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &#39;commit information&#39;</span></pre></td></tr></table></figure></li>
<li>step 5：<br>  推送到遠端  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin master</span></pre></td></tr></table></figure></li>
<li>step 6：<br>  打開最上層的<code>_config.yml</code>，修改設定  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  type: git # 部署方式</span></pre></td></tr><tr><td class="code"><pre><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;wuzhe0912&#x2F;pittwu-blog.git # 關聯 github</span></pre></td></tr><tr><td class="code"><pre><span class="line">  branch: run-page # 部署用 branch</span></pre></td></tr></table></figure>
  安裝 Hexo 部署插件  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add hexo-deployer-git</span></pre></td></tr></table></figure></li>
<li>step 7：<br>  執行指令  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  &#x2F;&#x2F; 清除舊的靜態文件</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo g      &#x2F;&#x2F; 生成新的靜態文件</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo d      &#x2F;&#x2F; 部署</span></pre></td></tr></table></figure>
  這時候本地的 Hexo 資料已推送到遠端的 Github repository</li>
<li>step 8：<br>  接著在<a href="https://www.netlify.com/" target="_blank" rel="noopener">Netlify</a>建立帳號，因為我們要關聯 GitHub，所以選擇第三方登入(使用 GitHub 帳號)</li>
<li>step 9：<br>  登入後，選擇右側的 New site from Git，再來選關聯 GitHub，授權完成後，選擇對應的 repository</li>
<li>step 10：<br>  Branch 需選擇剛剛<code>_config.yml</code>輸入的 branch name，下方 command 和 Publish 兩欄則清空，最後點選 Deploy site</li>
<li>step 11：<br>  很快就能在左上角看到 Netlify 幫我們生成的網址，但其中網址名的部分是亂數生成的，可以點選 Change site name 修改。</li>
<li>step 12：<br>  日後只要本地寫完文章，執行下面三道指令，即可完成自動部署。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo g</span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo d</span></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Netlify</tag>
        <tag>auto deploy</tag>
      </tags>
  </entry>
  <entry>
    <title>Node &amp; NPM Version Path Fixed</title>
    <url>/2019/12/01/node/version-fixed/</url>
    <content><![CDATA[<p>近期公司 MIS 調整硬體設備，造成環境有點跑掉，記錄一下自己在 Stack Overflow 上找到的解法。</p>
<a id="more"></a>
<p>打開 iTerm 會出現下述 error。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm is not compatible with the npm config “prefix” option: currently set to “&#x2F;Users&#x2F;xxx&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v8.12.0&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Run &#96;npm config delete prefix&#96; or &#96;nvm use --delete-prefix v8.12.0 --silent&#96; to unset it.</span></pre></td></tr></table></figure>
<p>從字面上來看，應該是 npm 和 nvm 管理的 node 版本沒有對上，按照終端機提供的訊息，敲入對應指令。再檢查 node 版本似乎是正常了，但事實上，若在 iTerm 上另開分頁，依然會跳相同的提示錯誤。雖然不影響操作，但看到總是不順眼，google 了一下解法，最終測試成功方案如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config delete prefix</span></pre></td></tr><tr><td class="code"><pre><span class="line">npm config set prefix $NVM_DIR&#x2F;versions&#x2F;node&#x2F;v8.12.0</span></pre></td></tr></table></figure>
<p>看起來應該是先刪除 npm 中設定的 prefix ，再重新設定當前 nvm 使用的版本。</p>
<p>最後附上 <a href="https://stackoverflow.com/questions/34718528/nvm-is-not-compatible-with-the-npm-config-prefix-option" target="_blank" rel="noopener">stackoverflow</a> 找到的解法。</p>
]]></content>
      <tags>
        <tag>Node.js</tag>
        <tag>NVM</tag>
        <tag>NPM</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Command Error Fixed</title>
    <url>/2019/12/01/git/command-error-fixed/</url>
    <content><![CDATA[<p>Git 雖然是基本知識，但有時操作上，還是不免出現一些 Error，記錄當中的解法，方便日後快速排查問題。</p>
<a id="more"></a>
<h2 id="初始化錯誤"><a href="#初始化錯誤" class="headerlink" title="初始化錯誤"></a>初始化錯誤</h2><p>由於之前習慣性從遠端 clone 下來，所以<code>.git</code>檔案同時會被準備完成，但這次因為嘗試自動部署<code>Hexo</code>，在推送時跳出下面這個錯誤。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: Not a git repository (or any of the parent directories): .git</span></pre></td></tr></table></figure>
<p>這個錯誤是說明，要推送的檔案不是一個<code>git</code>的<code>repository</code>，所以<code>git</code>在這個目錄底下會找不到<code>.git</code>檔案。解決方式是，執行指令<code>git init</code>，這樣就等於初始化一個<code>git repo</code>。</p>
<h2 id="GitLab-推送失敗錯誤"><a href="#GitLab-推送失敗錯誤" class="headerlink" title="GitLab 推送失敗錯誤"></a>GitLab 推送失敗錯誤</h2><p>這邊在 push branch 到 GitLab 時遇到一個問題，狀況如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GitLab: The project you were looking for could not be found.</span></pre></td></tr><tr><td class="code"><pre><span class="line">fatal: Could not read from remote repository.</span></pre></td></tr></table></figure>
<p>遠端的 GitLab 找不到我的 repository 位置，這邊會出現兩種可能，第一是還沒加入 SSH Key，第二是 SSH Key 正確，但需要重新更換遠端的名稱，首先輸入下面的指令，檢查本機公鑰有沒有正常加入 GitLab：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@gitlab.com</span></pre></td></tr></table></figure>
<p>如果出現 <code>Permission Denied (publickey)</code> 那就需要執行生成 SSH Key，並將公鑰加入 GitLab。</p>
<ol>
<li>生成 SSH Key：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;YOUR EMAIL&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">cd ~&#x2F;.ssh&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意生成過程中，會要求設定私人密碼，需要自己記住</span></pre></td></tr></table></figure></li>
<li>進入 ssh 底下，會看到兩個新的檔案：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id_rsa &#x3D;&gt; 私鑰</span></pre></td></tr><tr><td class="code"><pre><span class="line">id_rsa.pub &#x3D;&gt; 公鑰 &#x2F;&#x2F; 使用 vscode 將公鑰的檔案打開，複製裡面的內容</span></pre></td></tr></table></figure></li>
<li>回到 GitLab，操作路徑：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">點選右上角圖像&#x2F;setting&#x2F;左側 SSH Keys</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 將剛剛複製的內容貼到中間的輸入框，並點擊下方的 add key</span></pre></td></tr></table></figure></li>
<li>回到終端機，再次輸入<code>ssh -T git@gitlab.com</code>，這時會要求你輸入剛剛設定的私人密碼，成功後應該會看下面的文字：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome to GitLab, @Your_name!</span></pre></td></tr></table></figure>
到這邊第一步設定 SSH Keys 完成，但我嘗試重新 push 一次依然失敗：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">remote: The project you were looking for could not be found.</span></pre></td></tr><tr><td class="code"><pre><span class="line">fatal: repository &#39;https:&#x2F;&#x2F;gitlab.com&#x2F;Your_name&#x2F;Your_project.git&#x2F;&#39; not found</span></pre></td></tr></table></figure></li>
<li>重新更新並配對一次遠端名稱：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote rename origin old-origin</span></pre></td></tr><tr><td class="code"><pre><span class="line">git remote add origin git@gitlab.com:Your_name&#x2F;Your_project.git</span></pre></td></tr></table></figure>
到此，檔案就能正常推送到遠端了。</li>
</ol>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Next Theme Error Fixed</title>
    <url>/2019/11/29/hexo/next-theme-error-fixed/</url>
    <content><![CDATA[<p>雖然 Hexo 的學習曲線平滑，網路上也是隨手可得教學資料，但仍免不了，在使用過程中碰到一些難點，因此順手記錄這些難點的解法，方便自己日後回顧檢查。</p>
<a id="more"></a>
<h2 id="Next-主題背景動畫配置無效果"><a href="#Next-主題背景動畫配置無效果" class="headerlink" title="Next 主題背景動畫配置無效果"></a>Next 主題背景動畫配置無效果</h2><p><code>Next</code>在5.x版本時，設定背景動畫效果，僅需在<code>_config.yml</code>調整<code>true or false</code>即有效果。但在6.X版本，不知道因為何種原因，這種設置方式完全失效，因此改採用下述三個步驟設置動畫效果。</p>
<p>e.g. 選擇 canvas_nest 這個效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. cd themes&#x2F;next</span></pre></td></tr><tr><td class="code"><pre><span class="line">2. git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-canvas-nest source &#x2F; lib &#x2F; canvas-nest</span></pre></td></tr><tr><td class="code"><pre><span class="line">3. next&#x2F;_config.yml 設定 enable: true</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">其他三種動畫效果，同前述。</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Next Theme</tag>
      </tags>
  </entry>
  <entry>
    <title>Next Theme Install Note</title>
    <url>/2019/11/28/hexo/next-theme-install-note/</url>
    <content><![CDATA[<p>安裝 Hexo 的難度不高，但是調整 Hexo Theme 的配置是件不小的工程，記錄一下自己的調整流程。</p>
<a id="more"></a>

<h2 id="挑選主體"><a href="#挑選主體" class="headerlink" title="挑選主體"></a>挑選主體</h2><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">挑選 Hexo 主題網址</a>，這個 Blog 以<code>Next</code>為例。<br>step1. 安裝<code>theme</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd hexo-blog</span></pre></td></tr><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span></pre></td></tr></table></figure>
<p>step2. 修改設定<code>_config.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: landscape &#x3D;&gt; theme: next</span></pre></td></tr></table></figure>
<p>重新啟動<code>hexo s</code></p>
<h2 id="參數設定"><a href="#參數設定" class="headerlink" title="參數設定"></a>參數設定</h2><p>在<code>themes/next/_config.yml</code>中，可以透過調整參數，開啟非常多功能，以下條列其中。</p>
<h3 id="主題"><a href="#主題" class="headerlink" title="主題"></a>主題</h3><p>Next 有四種 Scheme 可以選擇，預設主題風格是 Muse，找到 scheme 設定，再將想選擇的註釋去除即可。<br>e.g.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Schemes</span></pre></td></tr><tr><td class="code"><pre><span class="line"># scheme: Muse</span></pre></td></tr><tr><td class="code"><pre><span class="line"># scheme: Mist</span></pre></td></tr><tr><td class="code"><pre><span class="line"># scheme: Pisces</span></pre></td></tr><tr><td class="code"><pre><span class="line">scheme: Gemini</span></pre></td></tr></table></figure>
<h3 id="開啟社群帳號連結"><a href="#開啟社群帳號連結" class="headerlink" title="開啟社群帳號連結"></a>開啟社群帳號連結</h3><p>打開或新增個人社群網站連結，僅須將註釋去除即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">social:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;wuzhe0912 || github</span></pre></td></tr><tr><td class="code"><pre><span class="line">  E-Mail: mailto:kgb00128@gmail.com || envelope</span></pre></td></tr></table></figure>
<h3 id="文章預覽"><a href="#文章預覽" class="headerlink" title="文章預覽"></a>文章預覽</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  enable: false</span></pre></td></tr><tr><td class="code"><pre><span class="line">  length: 150</span></pre></td></tr></table></figure>
<p>也可以透過<code>&lt;!--more--&gt;</code>來裁切，在<code>&lt;!--more--&gt;</code>以上的文字，會出現在預覽。</p>
<h3 id="啟用文章閱讀進度條"><a href="#啟用文章閱讀進度條" class="headerlink" title="啟用文章閱讀進度條"></a>啟用文章閱讀進度條</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reading_progress:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  enable: true</span></pre></td></tr></table></figure>
<h3 id="左側啟用文章閱讀-數"><a href="#左側啟用文章閱讀-數" class="headerlink" title="左側啟用文章閱讀%數"></a>左側啟用文章閱讀%數</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">back2top:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  enable: true</span></pre></td></tr><tr><td class="code"><pre><span class="line">  # Back to top in sidebar.</span></pre></td></tr><tr><td class="code"><pre><span class="line">  sidebar: true</span></pre></td></tr><tr><td class="code"><pre><span class="line">  # Scroll percent label in b2t button.</span></pre></td></tr><tr><td class="code"><pre><span class="line">  scrollpercent: true</span></pre></td></tr></table></figure>
<h3 id="開啟網站底部用戶訪問量"><a href="#開啟網站底部用戶訪問量" class="headerlink" title="開啟網站底部用戶訪問量"></a>開啟網站底部用戶訪問量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  enable: true</span></pre></td></tr></table></figure>
<p>接著調整<code>themes/next/layout/_third-party/statistics/busuanzi-counter.swig</code>中這兩行程式碼，可以在 i 標籤插入中文描述。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;i class&#x3D;&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;&quot;&gt;&lt;&#x2F;i&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;i class&#x3D;&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;&quot;&gt;&lt;&#x2F;i&gt;</span></pre></td></tr></table></figure>
<h3 id="調整文章末尾-tag-樣式"><a href="#調整文章末尾-tag-樣式" class="headerlink" title="調整文章末尾 tag 樣式"></a>調整文章末尾 tag 樣式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tag_icon: true</span></pre></td></tr></table></figure>
<h3 id="增加本地搜索功能"><a href="#增加本地搜索功能" class="headerlink" title="增加本地搜索功能"></a>增加本地搜索功能</h3><p>安裝插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add hexo-generator-search hexo-generator-searchdb</span></pre></td></tr></table></figure>
<p>調整設定為 true</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  enable: true</span></pre></td></tr></table></figure>
<h2 id="關於作者"><a href="#關於作者" class="headerlink" title="關於作者"></a>關於作者</h2><h3 id="新增大頭貼"><a href="#新增大頭貼" class="headerlink" title="新增大頭貼"></a>新增大頭貼</h3><p>step 1 建立存放圖片用的資料夾</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir source&#x2F;images</span></pre></td></tr></table></figure>
<p>step 2 將大頭貼的照片丟入資料夾<code>source/images</code>，接著在主題設定<code>themes/next/_config.yml</code>中，設定大頭貼路徑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avatar:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  url: &#x2F;images&#x2F;avatar.jpeg</span></pre></td></tr></table></figure>
<h3 id="調整大頭貼樣式"><a href="#調整大頭貼樣式" class="headerlink" title="調整大頭貼樣式"></a>調整大頭貼樣式</h3><p>邊框改為圓形，設為 true</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rounded: false &#x3D;&gt; rounded: true</span></pre></td></tr></table></figure>
<p>hover 時，添加旋轉特效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rotated: false &#x3D;&gt; rotated: true</span></pre></td></tr></table></figure>
<h2 id="上方添加-Github-Fork-圖片"><a href="#上方添加-Github-Fork-圖片" class="headerlink" title="上方添加 Github Fork 圖片"></a>上方添加 Github Fork 圖片</h2><p>step 1 首先到<a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">GitHub Corners</a>或是<a href="https://github.blog/2008-12-19-github-ribbons/" target="_blank" rel="noopener">GitHub Ribbons</a>尋找自己喜歡的樣式，並 copy code<br>step 2 打開<code>themes/next/layout/_layout.swig</code>，在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>下面<br>step 3 將<code>href</code>後面的網址，替換成個人<code>GitHub</code>主頁。<br>重新啟動服務<code>hexo s</code>。</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Next Theme</tag>
      </tags>
  </entry>
  <entry>
    <title>面試問題：Webpack</title>
    <url>/2019/06/09/interview/webpack/</url>
    <content><![CDATA[<p>Webpack 是目前近兩年最熱門的打包工具，功能強大與客製化程度高，與之相對的，在設定上有很多眉角。另一方面，因為工作上使用 Vue cli 已經預設好相當多功能，反而對 Webpack 的認識不足。之後，需要練習使用純 webpack 來搭建環境而不使用框架。</p>
<a id="more"></a>
<h3 id="webpack-中-babel-如何設定？"><a href="#webpack-中-babel-如何設定？" class="headerlink" title="webpack 中 babel 如何設定？"></a>webpack 中 babel 如何設定？</h3><ul>
<li><p>plugins install –dev</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@babel&#x2F;cli</span></pre></td></tr><tr><td class="code"><pre><span class="line">@babel&#x2F;core</span></pre></td></tr><tr><td class="code"><pre><span class="line">@babel&#x2F;preset-env</span></pre></td></tr></table></figure>
<p>基本設定寫在 .babelrc 的檔案中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &quot;presets&quot;: [</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &quot;@babel&#x2F;preset-env&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &quot;plugins&quot;: []</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>@babel/preset-env，通常會用來放一些常用的語法解析，預設 babel 官方已經有提供 ES6 語法解析。babel 本身主要專注在解析語法，但新的 API 會被忽略，因此需要 polyfill 來輔助。</p>
</li>
<li><p>babel-polyfill</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@babel&#x2F;polyfill</span></pre></td></tr></table></figure>
<p>babel-polyfill 就是延伸早期的 polyfill 方案，再結合 core-js 和 regenerator 形成強大的集合，幫助開發者將所有的新的語法打上補丁，讓他們可以在低版本的瀏覽器正常運作。但 babel 官方 7.4 版本後，建議直接使用 core-js 和 regenerator。但因為 babel-polyfill 本身體積蠻大的，畢竟是集合解析所有語法，所以需要在 .babelrc 調整設定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &quot;presets&quot;: [</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &quot;@babel&#x2F;preset-env&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;useBuiltIns&quot;: &quot;usage&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;corejs&quot;: 3</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &quot;plugins&quot;: []</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>usage 即可以只引入專案中有用到的語法，3 則是當前 core-js 版本號。</p>
</li>
<li><p>babel-runtime</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@babel&#x2F;runtime</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">@babel&#x2F;plugin-transform-runtime</span></pre></td></tr></table></figure>
<p>babel-polyfill 本身會有污染全域的問題，所以需要透過 babel-runtime 來處理，安裝完插件後，設定如下(直接照官方預設設定)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &quot;presets&quot;: [</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &quot;@babel&#x2F;preset-env&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;useBuiltIns&quot;: &quot;usage&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;corejs&quot;: 3</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &quot;plugins&quot;: [</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &quot;@babel&#x2F;plugin-transform-runtime&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;absoluteRuntime: false,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;corejs&quot;: 3,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;helpers&quot;: true,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;regenerator&quot;: true,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;useESModules&quot;: false</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>Webpack</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>面試問題：Vue.js - II</title>
    <url>/2019/06/08/interview/vue-II/</url>
    <content><![CDATA[<p>Vue.js 相關面試問題彙整 II。</p>
<a id="more"></a>
<h3 id="聊一下，你所知道的-Vue-組件通訊方式中，較少見的做法。"><a href="#聊一下，你所知道的-Vue-組件通訊方式中，較少見的做法。" class="headerlink" title="聊一下，你所知道的 Vue 組件通訊方式中，較少見的做法。"></a>聊一下，你所知道的 Vue 組件通訊方式中，較少見的做法。</h3><p>Vue 的父子組件中，還有一種不特別推薦的通訊方式，父組件通過 $children 可以改變子組件的 data，相反的，子組件可以透過 $parent 來改變父組件的 data。但官方建議少用這種方式，應該是要避免數據流動被搞混。</p>
]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>面試問題：Vue.js - I</title>
    <url>/2019/06/08/interview/vue-I/</url>
    <content><![CDATA[<p>Vue.js 相關面試問題彙整 I。</p>
<a id="more"></a>
<h3 id="如何理解-MVC-和-MVVM-差異？"><a href="#如何理解-MVC-和-MVVM-差異？" class="headerlink" title="如何理解 MVC 和 MVVM 差異？"></a>如何理解 MVC 和 MVVM 差異？</h3><ul>
<li><p>MVC</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">view &#x3D;&gt; 前端(切版、套入動畫效果)</span></pre></td></tr><tr><td class="code"><pre><span class="line">controller &#x3D;&gt; 後端(控制 router)</span></pre></td></tr><tr><td class="code"><pre><span class="line">model &#x3D;&gt; 後端(database)</span></pre></td></tr></table></figure>
<p>MVC 開始流行的原因，是為了解決早期程式碼混在一起的困境(義大利麵code)，前後端的程式碼都混在一起。因此 MVC 開始進行職責分工，view 負責畫面顯示，控管 router 和網站行為則由 controller，查詢資料庫的資料，則是 model，在這個時代前端工程師這個職缺才開始浮現出來(負責 view)。也因為 router 交由後端控制，因此這時期的網頁仍是多頁面式的網頁，切換頁面時是真的在切換不同頁面，會有明顯的 loading 時間。</p>
</li>
<li><p>MVVM</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">view &#x3D;&gt; 依然是前端(控制使用者看到的渲染頁面)</span></pre></td></tr><tr><td class="code"><pre><span class="line">model &#x3D;&gt; 後端</span></pre></td></tr><tr><td class="code"><pre><span class="line">viewModel &#x3D;&gt; 前端(改由前端控制 router)</span></pre></td></tr></table></figure>
<p>進入 MVVM 時代，將原生 JS 操作 DOM 這件事交給框架處理，我們負責改變框架中的資料，驅動資料去改變頁面重新渲染。而對前端來說，處理的是 view 和 viewModel，而 model 則是後端在處理。這個時候已經轉型為 SPA(單頁式應用)，網站頁面切換時，看似切換不同頁面，但本質只是切換同一頁的不同區塊，因此這時網頁的流暢性與使用性會更加流暢。</p>
</li>
</ul>
<h3 id="Vue-的雙向綁定原理是如何實現的？"><a href="#Vue-的雙向綁定原理是如何實現的？" class="headerlink" title="Vue 的雙向綁定原理是如何實現的？"></a>Vue 的雙向綁定原理是如何實現的？</h3><p>因為這涉及 Vue 的底層原理，所以我的解釋上，可能會比較制式化，主要拆解為四個步驟：</p>
<ol>
<li>首先 vue 會先通過 <code>document.createDocumentFragment()</code> 的方法來建立虛擬 DOM。</li>
<li>隨著 vue 所監聽的數據出現改變時，會再透過 <code>Object.defineProperty</code> 來進行數據攔截。</li>
<li>根據數據的變化，再透過訂閱-發布者模式，來觸發 watch，進而改變虛擬 DOM。</li>
<li>最後，再根據已經改變的虛擬 DOM，重新渲染頁面的 DOM 結構，達到雙向綁定的目的。</li>
</ol>
<h3 id="試說明-Vue-的生命週期"><a href="#試說明-Vue-的生命週期" class="headerlink" title="試說明 Vue 的生命週期"></a>試說明 Vue 的生命週期</h3><ul>
<li><p>beforeCreate &amp; created</p>
<ul>
<li>beforeCreated：init 整個 vue 的生命週期，目前個人經驗上，還沒有在這個階段處理過資料。</li>
<li>created：這個階段，會先進行 init data，這個時候 data 內的初始化資料已經可以調用了，同時也可以進行 call api。</li>
<li>再進入 mounted 階段前，其實 Vue 會有一個觀察動作，確認 template 上的 el 是否有正確設置好，但因為目前開發都是基於 vue-cli 的基底，所以這部分不太需要擔心。</li>
</ul>
</li>
<li><p>beforeMount &amp; mounted</p>
<ul>
<li>beforeMount：這個階段很少用，我個人也沒使用過，位於資料渲染前。</li>
<li>mounted：頁面已經渲染完成，同時 $el 已經掛載上去了。</li>
</ul>
</li>
<li><p>beforeUpdate &amp; updated<br>簡單說就是更新 data 的資料，促使頁面重新渲染 DOM，譬如透過 @click 事件去執行函式來改變 true 或 false，進而影響 v-bind 綁定的 class 增加或移除，達到樣式改變的目的。</p>
</li>
<li><p>beforeDestroy &amp; destroyed<br>vue 生命週期的尾聲，準備要銷毀節點，常見於 v-if。舉例來說，當我們執行 methods 的函式時，可能會將某些初始資料進行狀態改變，當資料在 true 或 false 間轉換時，同時 template 上的 DOM 也會隨之出現或消失，但和 v-show 不同，v-show 的消失，僅是元素採用  css 的 display: none 來隱藏，而 v-if 則是將該元素整個移除，所以被稱為銷毀。不過一般來說，我們不會直接使用 destroyed，官方也不建議我們使用。</p>
</li>
</ul>
<!-- - 前職中，call api 時，基本是 -->

<h3 id="created-和-mounted-的差異？"><a href="#created-和-mounted-的差異？" class="headerlink" title="created 和 mounted 的差異？"></a>created 和 mounted 的差異？</h3><p>兩者的最大的差異，還是在於掛載的順序，以及在各階段資料的狀態。</p>
<ul>
<li>beforeCreate：在這個階段 $el 和 $data 都尚未掛載 =&gt; undefined</li>
<li>created：$data 初始資料已載入，$el 尚未掛載成功 =&gt; undefined</li>
<li>beforeMount：$el 依然為空 =&gt; undefined</li>
<li>mounted：$el 掛載完成，渲染出現資料</li>
</ul>
<h3 id="為什麼說-vue-是單向數據流？"><a href="#為什麼說-vue-是單向數據流？" class="headerlink" title="為什麼說 vue 是單向數據流？"></a>為什麼說 vue 是單向數據流？</h3><p>因為 vue 的父子組件傳值中，父組件可以送資料給子組件，但子組件只能接收不能傳資料給父組件，不過子組件可以透過 @emit 方法，促使父組件執行函式來改變狀態。</p>
<p>舉例來說，彈窗效果(modal)我們通常會封裝到 component 內，每個頁面需要顯示彈窗內容都會有差異，譬如 title 可能就有落差，那 title 的資料就得透過父組件傳過去。但是如果我們想要關閉彈窗，代表我們想改變狀態，這時候 modal 就可以透過 <code>@emit=&quot;boxSwitch&quot;</code> 往上傳，父組件拿到後就會執行 methods 來改變當前的狀態，達到關閉彈窗的效果。</p>
<h3 id="簡單聊一下-Vue-Router"><a href="#簡單聊一下-Vue-Router" class="headerlink" title="簡單聊一下 Vue-Router"></a>簡單聊一下 Vue-Router</h3><p>主要兩種 mode，hash(default 加 #)，history(基於 HTML5 的 History 模式)。不過 history mode 需要和後端溝通，在對應的語言下，設定 rewrite，具體內容會直接參考官方文件。此外，為了避免無法找到錯誤頁面，同時也為了阻止客戶亂打url，最底層需加一組 path: ‘*’ 來進行轉址，至於轉址到哪一頁，則看需求方。</p>
<p>基本配置就是 path 設定要前往的路徑，component 載入要進入的頁面，通常還會加上 name，方便 router-link 的 to 可以直接調用。動態路由則使用冒號做開頭，通常可以在結尾加上?，方便如果沒有找到頁面時，會直接動態路由的上一層，例如：<code>list/:id?</code>。</p>
<h3 id="Vue-Router-如何達到-SPA-效果？"><a href="#Vue-Router-如何達到-SPA-效果？" class="headerlink" title="Vue Router 如何達到 SPA 效果？"></a>Vue Router 如何達到 SPA 效果？</h3><p>SPA 的重點就在於由前端來模擬路由，讓使用者看似在切換頁面，實際上只是切換組件。而 Vue Router 就是透過 router-view 的方法來包裝顯示組件，再透過 router-link 或是 router.push() 等方法來進出頁面。看起來雖然像是從 A 頁面進入 B 頁面，但實際上卻是將 A 組件改為顯示 B 組件。</p>
<h3 id="Vue-路由的跳轉方式？"><a href="#Vue-路由的跳轉方式？" class="headerlink" title="Vue 路由的跳轉方式？"></a>Vue 路由的跳轉方式？</h3><p>主要有兩種：</p>
<ul>
<li>router-link，本質上就是 a 標籤，在 template 中使用這個方式。</li>
<li>router.push，主要透過 methods 來執行跳轉到對應頁面，同時也可以在其中的 query 埋下參數，方便跳轉後的頁面直接調用。</li>
</ul>
<h3 id="簡單解釋一下-Vuex-的原理"><a href="#簡單解釋一下-Vuex-的原理" class="headerlink" title="簡單解釋一下 Vuex 的原理"></a>簡單解釋一下 Vuex 的原理</h3><p>在 Vuex 當中，state 會存放初始化的資料，當 component 呼叫 Vuex 中寫好的函式，首先會到 actions 找對應的函式，這時會去呼叫 api 的資料，當然如果 component 呼叫時有傳入參數，那這個參數就透過 payload 傳入函式。當 api 的資料取得後，除了回傳給 component，也透過 commit 的方式來改變 mutations 內的函式，而 mutations 這時就會將傳來的資料賦值給 state，進而改變狀態。</p>
<h3 id="什麼情境下，需使用-Vuex？"><a href="#什麼情境下，需使用-Vuex？" class="headerlink" title="什麼情境下，需使用 Vuex？"></a>什麼情境下，需使用 Vuex？</h3><p>Vue 的專案中，通常會有多個 component 組成，尤其專案越大組成結構就越複雜，有些資料會是多個頁面需要共用，這個時候不可能仰賴父子組件傳值，萬一組件和組件之間隔了好幾層，那效益就太差了，這時通常就會抽離到 Vuex 進行狀態管理。</p>
<p>舉例來說，常見的使用者帳號資料 userInfo，在 login 和 logout 兩種狀態下，頁面需要顯示的內容會有所差異，不可能在每一個需要使用 userInfo 的 component 都寫一遍呼叫 api 的函式，所以無論是初始的資料或是呼叫 api 的函式，這時候就會統一寫在 Vuex，方便直接 commit 更新 state，需要使用的 component 再透過 mapState 去載入。</p>
<h3 id="Vuex-適合存放怎樣的資料？"><a href="#Vuex-適合存放怎樣的資料？" class="headerlink" title="Vuex 適合存放怎樣的資料？"></a>Vuex 適合存放怎樣的資料？</h3><p>平台商可能接入多種遊戲商，每家遊戲商的做法不同，有些可能有開放試玩，有些可能沒有，因此在使用者帳號資訊中，就會存在三種狀態情境，登入、未登入、試玩，無論是遊戲商頁面、會員首頁的錢包顯示，這些頁面都要判斷登入顯示什麼，未登入顯示什麼。</p>
<p>如果每頁都呼叫一次使用者資訊的 API，那就顯得太過缺乏效率，所以我們會把使用者帳號的資料狀態存放在 Vuex，當用戶進行註冊登入時，則更新 Vuex 的狀態，這樣全域有調用該狀態的 component 也就自動隨之更新。</p>
<h3 id="keep-alive-的用法"><a href="#keep-alive-的用法" class="headerlink" title="keep-alive 的用法"></a>keep-alive 的用法</h3><p>可以理解為一種暫存資料的方式，假設後台有一些表單需要填寫時，可能使用者會需要來回切換不同區塊，這時候會導致原先填寫到一半的資料消失，透過 keep-alive 去包裹，可以暫時存放資料，優化使用體驗。</p>
<h3 id="簡單說一下-slot-是什麼？"><a href="#簡單說一下-slot-是什麼？" class="headerlink" title="簡單說一下 slot 是什麼？"></a>簡單說一下 slot 是什麼？</h3><p>基本操作和 component 雷同，載入需要插入的 component，再透過父子組件傳值，差別在於，接受傳值的子組件需要在 template 上使用 slot 標籤，這個標籤內的內容，則會渲染父組件傳過來的子內容或子節點，內容在父組件會使用雙花括號包裹。當然如果父組件沒有傳值，也可以直接使用子組件的資料來顯示。</p>
<h3 id="如果在-v-for-中不設-key-會發生什麼問題？"><a href="#如果在-v-for-中不設-key-會發生什麼問題？" class="headerlink" title="如果在 v-for 中不設 key 會發生什麼問題？"></a>如果在 v-for 中不設 key 會發生什麼問題？</h3><p>因為對於程式來說，它們的思考是很死板的，如果沒有設定唯一值的 Key，當我們對陣列進行操作時，就會造成實際結果和預期結果完全不同。譬如說：A array 中有三種水果，依序為蘋果、西瓜、葡萄，我刪除了西瓜的位置，index 上固然是 1、3，但對 vue 來說，在遍歷中它只會認為是目錄2被改成3，同時元素又因為沒有被刪除，在就地複用的原則下，就變成 1: 蘋果、3: 西瓜。所以透過唯一值的 Key，讓 v-for 在遍歷中，若要進行操作可以正常執行。</p>
<p>另外，key 作為唯一值時，對 vue 的底層虛擬 DOM 渲染也有幫助(涉及 diff 演算法)，當擁有唯一值時，即便陣列或物件中加入新的資料，vue 可以避免重複渲染的問題，對效能提升有幫助。</p>
<h3 id="component-之間有哪些傳遞資料的方式？"><a href="#component-之間有哪些傳遞資料的方式？" class="headerlink" title="component 之間有哪些傳遞資料的方式？"></a>component 之間有哪些傳遞資料的方式？</h3><p>狹義來說主要是父子組件傳值、同層級傳值、全域管理：</p>
<ul>
<li>父子組件，通過 props 接收父組件傳下來的資料，同時也能透過 @emit 來呼叫父組件執行函式。</li>
<li>兄弟組件，同層級組件可以透過 EventBus 傳遞資料。</li>
<li>Vuex 是常見的專案狀態管理，如果有多個組件需要複用的狀態或是函式，可以統一由 Vuex 來管理。</li>
</ul>
<p>廣義來說，我會認為還有兩種狀況也算是傳遞資料的方式：</p>
<ul>
<li>localStorage 或是 sessionStorage 存放的資料，組件間也是能調用。</li>
<li>router.push 中例如 query 或是 params 也是可以帶入參數，等同是傳遞資料給進入的下一個組件。</li>
</ul>
<h3 id="什麼是-Vue-use"><a href="#什麼是-Vue-use" class="headerlink" title="什麼是 Vue.use()?"></a>什麼是 Vue.use()?</h3><p>如果我們有安裝依賴在 Vue 的套件，可以透過 Vue.use() 的方法，把套件註冊到全域環境，讓其他 component 可以直接使用，而不需要每頁都 import 該插件。</p>
<h3 id="Vue-amp-jQuery-兩者間的差異性？"><a href="#Vue-amp-jQuery-兩者間的差異性？" class="headerlink" title="Vue &amp; jQuery 兩者間的差異性？"></a>Vue &amp; jQuery 兩者間的差異性？</h3><ul>
<li><p>DOM 操作：</p>
<ul>
<li>jQuery：在 jquery 的時代，雖然已經簡化了對 DOM 操作的寫法，但依然需要頻繁操作 DOM 來改變頁面狀態。</li>
<li>Vue：但對 Vue 來說，一方面過往的 DOM 操作已改由框架來處理，另一方面結合模板語法，data 和 template 可以分離的很乾淨，當我透過 methods 改變 data 內的資料時，template 也就隨之重新渲染，再配合語法糖綁上 v-bind，當狀態改變時，也可以隨之改動 css 樣式。更重要的是，寫法上有固定的格式，依循官方的規則，這樣對團隊來說，更容易維護與上手。</li>
</ul>
</li>
<li><p>歷史沉澱：但這並不代表，jQuery 沒有優點，畢竟它本身有漫長的歷史積累，所以如果是撰寫 Landing Page 之類的宣傳頁面，需要使用各種特效或動畫時，jQuery 有非常多成熟的解決方案，這是 Vue 現階段無法比得上的，再加上 SEO 的考慮因素下，這一類型宣傳頁面反而不適合使用 Vue。</p>
</li>
</ul>
<h3 id="Angular-vs-React-vs-Vue-差異性？"><a href="#Angular-vs-React-vs-Vue-差異性？" class="headerlink" title="Angular vs React vs Vue 差異性？"></a>Angular vs React vs Vue 差異性？</h3><ul>
<li><p>結構：雖然三者都被稱為框架，但從嚴謹角度來看，Angular 可以被稱為框架，google 的團隊提供了各種內置 API，包含表單驗證、狀態管理、路由等等功能，而另外兩者更接近為 Library，React 早期幾乎是什麼都沒有提供，後來 React Router、Redux 都是社群貢獻的，Vue 則是提供一部分，包括狀態管理、路由。</p>
</li>
<li><p>語法：Angular 除了有自己的指令外，加上使用 TypeScript，目前查到開發經驗，似乎寫起來很繁瑣(我自己本身沒寫過)。React 有一大特色使用 JSX 語法，我自己下班時間練手有寫過一段時間，坦白說非常不適應，因為揉合了 HTML、CSS、JS，讓程式碼的縮排與括號變成非常大串，這對已經習慣 pug + template 分離的我來說，非常需要適應。相對於 React 對 ES6 掌握要很熟練，Vue 的開發允許 ES5 混合 ES6，再加上 Vue 的官方提供了相當數量的指令，很多時候更像是用 Vue 在做功能而非 JS。</p>
</li>
<li><p>學習成本：Vue 是遠勝過後兩者，React 固然最自由，但幾乎多數功能都要求開發者自行處理，因此非常考驗開發者功力，而 angular 則是受限於自身體積龐大，需要相當的時間來掌握使用。</p>
</li>
</ul>
<h3 id="如何實作-Vue-Router-切換頁面時加入-Loading-效果？"><a href="#如何實作-Vue-Router-切換頁面時加入-Loading-效果？" class="headerlink" title="如何實作 Vue Router 切換頁面時加入 Loading 效果？"></a>如何實作 Vue Router 切換頁面時加入 Loading 效果？</h3><p>先準備 v-loading 的 component，接著在 Vuex 存放 Loading 預設初始值(false)，回到 vue-router 在 beforeEach 和 afterEach 都對 vuex 的 mutations 進行 commit，並透過 payload 先後傳 true 和 false(可以設一點延遲時間)，最後回到 app.vue 將 component 掛上去。</p>
<h3 id="曾經-Vue-遇到的難點以及如何解決？"><a href="#曾經-Vue-遇到的難點以及如何解決？" class="headerlink" title="曾經 Vue 遇到的難點以及如何解決？"></a>曾經 Vue 遇到的難點以及如何解決？</h3><p>需求為顯示用戶的金流進出明細，是一個三層嵌套的下拉選單，第三方套件已經找到，但是後端只願意給一個物件，裡面包了所有金流明細的數字代碼。</p>
<p>第一階段，因為開發時間不足，所以採用最笨的方法，一個個抽出來，再重新 push 進對應的陣列。<br>第二階段，進行重構，先透過 for in 的方式遍歷 object 轉為 array，再透過 map() 方法，重組並建立好第二層陣列的結構，接著在其中重組並建立好第三層陣列，再回到第二層處理陣列，並把整理好的第三層陣列放入第二層的 children 中，最後回到第一層，把第二層陣列放到第一層的 children。</p>
]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>面試問題：程式碼實作</title>
    <url>/2019/06/07/interview/code/</url>
    <content><![CDATA[<p>程式碼實作考題，基本上是躲不了，但有些情境可能在考試當下，會出現大腦當機的狀況，所以就只能多練習相關題型，才能順利解題。不過 LeetCode 這一塊我還太弱，只能慢慢補。</p>
<a id="more"></a>
<h3 id="foo-的值是什麼？"><a href="#foo-的值是什麼？" class="headerlink" title="foo 的值是什麼？"></a>foo 的值是什麼？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; 10 + &#39;20&#39;;</span></pre></td></tr></table></figure>
<p>答案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1020</span></pre></td></tr></table></figure>
<p>解法：<br>number + string =&gt; string 呈現，若兩者都是 number，則進行計算。</p>
<h3 id="實作符合下面的函式"><a href="#實作符合下面的函式" class="headerlink" title="實作符合下面的函式"></a>實作符合下面的函式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plus(2, 5); &#x2F;&#x2F; 7</span></pre></td></tr><tr><td class="code"><pre><span class="line">add(2)(5); &#x2F;&#x2F; 7</span></pre></td></tr></table></figure>
<p>第一題是一般函式的計算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function plus (val, val2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return val + val2</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(plus(2, 5))</span></pre></td></tr></table></figure>
<p>第二題不是一般的寫法，解法需使用到閉包的部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add (val) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return function (subVal) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return val + subVal</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(add(2)(5))</span></pre></td></tr></table></figure>

<h3 id="下面的-statement-陳述式-會回傳什麼？"><a href="#下面的-statement-陳述式-會回傳什麼？" class="headerlink" title="下面的 statement(陳述式) 會回傳什麼？"></a>下面的 statement(陳述式) 會回傳什麼？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Hello World!&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;);</span></pre></td></tr></table></figure>
<p>答案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;!dlroW olleH&quot;</span></pre></td></tr></table></figure>
<p>解法：<br>split() 會將 string 進行分割，若有給定參數，則會根據該參數進行拆分並重組成陣列，譬如空格或是逗號，但因為這邊沒有，所以會根據每個字元拆，得到拆完的結果後，透過 reverse() 將陣列中的資料進行反轉，最後再透過 join() 將陣列中所有元素加入一個 string。</p>
<h3 id="window-foo-的值是什麼？"><a href="#window-foo-的值是什麼？" class="headerlink" title="window.foo 的值是什麼？"></a>window.foo 的值是什麼？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">( window.foo || ( window.foo &#x3D; &quot;bar&quot; ) );</span></pre></td></tr></table></figure>
<p>答案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bar</span></pre></td></tr></table></figure>
<p>解法：<br>window.foo 在邏輯運算中，僅有一側被賦值，自然使用 bar，除非兩側都賦值，|| 判斷才會使用第一組。</p>
<h3 id="下面-foo-length-的值是什麼？"><a href="#下面-foo-length-的值是什麼？" class="headerlink" title="下面 foo.length 的值是什麼？"></a>下面 foo.length 的值是什麼？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; [];</span></pre></td></tr><tr><td class="code"><pre><span class="line">foo.push(1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">foo.push(2);</span></pre></td></tr></table></figure>
<p>答案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span></pre></td></tr></table></figure>
<p>解法：<br>宣告空陣列，依序透過 push() 塞值，array 中會拿到兩個元素，長度為2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(foo)        &#x2F;&#x2F; [1, 2]</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(foo.length) &#x2F;&#x2F; 2</span></pre></td></tr></table></figure>

<h3 id="下面這段會印出什麼？"><a href="#下面這段會印出什麼？" class="headerlink" title="下面這段會印出什麼？"></a>下面這段會印出什麼？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;one&#39;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">setTimeout(function() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(&#39;two&#39;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;, 0);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(&#39;three&#39;);</span></pre></td></tr></table></figure>
<p>答案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">one</span></pre></td></tr><tr><td class="code"><pre><span class="line">three</span></pre></td></tr><tr><td class="code"><pre><span class="line">two</span></pre></td></tr></table></figure>
<p>解法：<br>JS 本身為單執行緒，遇到同步工作時會依序執行，但非同步工作則會先丟到 task queue(任務等待序列)中，直到瀏覽器所有工作執行完，才會回頭來檢視 task queue。</p>
<h3 id="下面的兩個-alert-的結果會是什麼？"><a href="#下面的兩個-alert-的結果會是什麼？" class="headerlink" title="下面的兩個 alert 的結果會是什麼？"></a>下面的兩個 alert 的結果會是什麼？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; &quot;Hello&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">(function() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  var bar &#x3D; &quot; World&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  alert(foo + bar);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(foo + bar);</span></pre></td></tr></table></figure>
<p>答案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello World &#x2F;&#x2F; 第一個 alert</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">bar is not defined &#x2F;&#x2F; 第二個 alert</span></pre></td></tr></table></figure>
<p>解法：<br>第一個 alert 的結果正常，因為 foo 可以找到全域變數，而 bar 則使用函式作用域內的變數。<br>第二個 alert 時，foo 全域變數仍然存在，但是 bar 在函式內的變數已被銷毀，所以會變成 bar is not defined。</p>
]]></content>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>面試問題：網際網路協議</title>
    <url>/2019/06/06/interview/https/</url>
    <content><![CDATA[<p>網際網路協議相關的問題，其實會比較偏向計算機原理，雖然表面上看前端開發沒有直接關係，但實際上網站的運作與效能，都脫離不了網路協議，所以自然也躲不掉相關的考題。</p>
<a id="more"></a>
<h3 id="從輸入網址列到渲染畫面，過程經歷了什麼事？"><a href="#從輸入網址列到渲染畫面，過程經歷了什麼事？" class="headerlink" title="從輸入網址列到渲染畫面，過程經歷了什麼事？"></a>從輸入網址列到渲染畫面，過程經歷了什麼事？</h3><ul>
<li><p>第一階段：確認 IP 地址是否存在<br>我們透過瀏覽器輸入一段網址，瀏覽器會根據這一串網址去呼叫 DNS Server，讓 DNS 去確認這串網址對應的 IP 位置，如果沒找到就 gg，但為了後面的內容，所以這邊是一定要找到的。DNS 找到 IP 後會回傳給瀏覽器，瀏覽器開始連線到這個網址，接著進入第二階段</p>
</li>
<li><p>第二階段：網路請求資料<br>這個階段基本可以理解為前端(Client)向後端(Server)拿資料。這個流程挺複雜的，我的理解拆為以下三階段：</p>
<ul>
<li>打招呼：俗稱三次握手，Client 向 Server 詢問是否存在，Server 回應我在，接著 Client 宣告我準備要執行傳資料的動作囉。</li>
<li>傳送資料(req &amp; res)：前端透過某個 method 向後端拿資料，這邊用 get，後端送封包過去後，再傳一組成功的狀態碼(200)給前端。</li>
<li>結束關閉：Client 向 Server 通知準備關閉，Server 向 Client 說 ok 我也要關閉了，並進行關閉，接著 Client 也進行關閉，這階段俗稱四次揮手。</li>
</ul>
</li>
<li><p>第三階段：取得資料，開始進行頁面渲染<br>首先 HTML 和 CSS 會優先執行，前者開始搭建整個頁面 DOM Tree，後者則是提前準備好所有樣式，接著來到 style 階段，將樣式指到對應的元素，Layout 開始排列頁面位置，最終完成頁面渲染。至於 JS，為了確保使用者最低限度要能看到靜態頁面，所以依慣例我們會將 JS 的執行順序放至 body 底部，確保它最後執行。</p>
</li>
<li><p><a href="https://w3c.hexschool.com/blog/8d691e4f" target="_blank" rel="noopener">詳細圖解</a></p>
</li>
</ul>
<h3 id="什麼是瀏覽器的同源策略？另外跨域問題，如何解決？"><a href="#什麼是瀏覽器的同源策略？另外跨域問題，如何解決？" class="headerlink" title="什麼是瀏覽器的同源策略？另外跨域問題，如何解決？"></a>什麼是瀏覽器的同源策略？另外跨域問題，如何解決？</h3><p>當 ajax 發出請求時，瀏覽器會要求當前網頁與 server，基於安全性必須同源，也就是協議(http、https)、域名(abc.com)、端口(8080)，三者皆必須一致，只要任一者不同，就是不同源，倘若三者相同則為同源(符合同源策略)，同源策略僅限瀏覽器，後端(server)無此限制。當然，如果是 cdn 引入 js 的框架，或是 css 引入圖片網址，可以無視這個規則。<br>當非同源時，前端發出請求時，需要進行跨域，而任何跨域行為，理當經過 server 端允許，若未經允許即可實現跨域，代表網站本身已存在重大漏洞。解決方案，主要有三種，JSONP 和 CORS 以及代理，JSONP 透過 script 導入目前比較少使用，CORS 則是由後端處理，前端直接使用，代理則需要特定設置(vue =&gt; vue.config.js)。<br>當然，如果是 cdn 引入 js 的框架，或是 css 引入圖片網址，可以無視這個規則。任何跨域行為，都應該經過 server 端允許，若未經允許即可實現跨域，代表網站本身已存在重大漏洞。</p>
<h3 id="CORS-是什麼，它解決了什麼問題？"><a href="#CORS-是什麼，它解決了什麼問題？" class="headerlink" title="CORS 是什麼，它解決了什麼問題？"></a>CORS 是什麼，它解決了什麼問題？</h3><p>前端的一種跨域方式，由 server 端設置(通常是由後端設置在 http header)，前端可以直接使用，也可以只允許特定網址使用。</p>
<h3 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy 代理"></a>Proxy 代理</h3><p>得通過 nginx server 的設定來達成，以 Vue 為例，在 vue.config.js 進行設定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  devServer: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    host: &#39;localhost&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    port: 8080,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 當網址攔截到 &#x2F;api</span></pre></td></tr><tr><td class="code"><pre><span class="line">    proxy: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#39;&#x2F;api&#39;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 目標要指向哪個網址</span></pre></td></tr><tr><td class="code"><pre><span class="line">        target: &#39;https:&#x2F;&#x2F;www.xxx.com&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        changeOrigin: true,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;*</span></pre></td></tr><tr><td class="code"><pre><span class="line">          實務上，會遇到n個api，每一隻api路徑皆有所差別</span></pre></td></tr><tr><td class="code"><pre><span class="line">          為了統一攔截，因此虛擬化了一個路徑 &#x2F;api</span></pre></td></tr><tr><td class="code"><pre><span class="line">          但當轉發路徑時，才將這個虛擬化的路徑轉為空</span></pre></td></tr><tr><td class="code"><pre><span class="line">        *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pathRewrite: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#39;api&#x2F;&#39;: &#39;&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>代理的安全性較高，可以隱藏後端 server 的來源，同時前後端需要設定的東西也較少。</p>
<h3 id="描述-cookies-localStorage-sessionStorage-的差別？"><a href="#描述-cookies-localStorage-sessionStorage-的差別？" class="headerlink" title="描述 cookies/localStorage/sessionStorage 的差別？"></a>描述 cookies/localStorage/sessionStorage 的差別？</h3><p>這三者都是前端在瀏覽器儲存的方式，cookie 是比較早期的做法，儲存的容量有限，只有 4KB，預設保存時效是瀏覽器關閉時就失效。一方面是本身儲存的容量小，另一方面因為會攜帶在 http 中，所以太多數據又會影響效能，所以大多不使用 cookie。</p>
<p>但我個人此前有一個使用場景，業務推廣產品網址會帶有一組推廣碼，營運方希望在客戶成功註冊前，保存這組推廣碼24小時，我的解法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">當客戶透過推廣網址進入時註冊頁面時，立刻觸發保存當前時間(new Date())</span></pre></td></tr><tr><td class="code"><pre><span class="line">接下來利用 getTime() 來取從紀元時間到當前時間的毫秒數，再往後加上 24 小時的毫秒數</span></pre></td></tr><tr><td class="code"><pre><span class="line">等於建立了一個時間戳記，再把它存到 document.cookie 的 expires，達到希望失效時間的目的。</span></pre></td></tr></table></figure>

<p>localStorage 和 sessionStorage 都是從 HTML5 開始提供的 API，儲存的容量大 5MB，也不會對效能產生問題，所以目前已用來取代 cookie，但因為兩者使用 API 相同，前者永久保存除非手動清除，後者則一樣是關閉瀏覽器即失效，因此多用前者居多。除了常見於用來保存 login 的 token，我個人還有用過一個情境在於，當網站透過 i18n 建立多語系功能時，客戶第一次進入網站時，前台會使用後台預設的語系，但當客戶切換語系後，會透過 localStorage 來保存客戶切換的語系，避免下次進入時失效，畢竟我們無法判斷客戶下次登入網站時間，所以這邊採用永久保存會是比較好的做法。</p>
<ul>
<li><a href="https://medium.com/@bebebobohaha/cookie-localstorage-sessionstorage-%E5%B7%AE%E7%95%B0-9e1d5df3dd7f" target="_blank" rel="noopener">詳細圖解</a></li>
</ul>
<h3 id="請簡單解釋-RESTful-API"><a href="#請簡單解釋-RESTful-API" class="headerlink" title="請簡單解釋 RESTful API"></a>請簡單解釋 RESTful API</h3><p>表現層狀態轉移…嗯，這種不是人話的東西，基本上是看不懂的。當然撰寫 RESTful API 是有固定的風格設計，譬如使用名詞而不盡量不使用動詞之類的。但對前端來說，應該可以拆成三部分來理解，查看後端提供的 API 文件：</p>
<ol>
<li>url =&gt; 告訴前端你請求的是什麼，全部的產品列表或是單一商品的細節</li>
<li>method =&gt; 使用哪一種方法，get(獲取)，post(送出增加)，delete(刪除)，put(更改)</li>
<li>status code =&gt; 拿到的 api 結果為何？成功或失敗，細部原因是什麼</li>
</ol>
<h3 id="請解釋一下-TCP-和-UDP"><a href="#請解釋一下-TCP-和-UDP" class="headerlink" title="請解釋一下 TCP 和 UDP"></a>請解釋一下 TCP 和 UDP</h3><p>本質上都是網路通訊協議，也都是通過封包來傳送資料。</p>
<ul>
<li><p>UDP：雖然本質雷同，但 UDP 可以理解為最低程度的傳送資料方式，它只管送資料，不在意接收方是否有接受到，所以也是一種不可靠傳輸，同時接收方也可能出現資料到達時間不一致的問題。如果是做直播類產品，可能會考慮採用 UDP，因為 UDP 傳送資料速度快，不需要和 TCP 一樣進行反覆確認的握手揮手機制，在低速弱網環境下，使用體驗更好，而且丟失的封包是可以承受的。另外就是，因為傳送快加上不需要握手，所以漏洞反而較少，DDOS 很難攻擊(但仍有攻擊手段 flood)。</p>
</li>
<li><p>TCP：最大宗的通用協議，他的運作機制嚴謹可靠且穩定，所以又被稱為可靠性傳輸，需要拆解成三階段來理解連線、傳輸、斷線。</p>
<ul>
<li><p>一、打招呼階段(三次握手)：</p>
<ol>
<li>前端先向 server 端 say hello，確定 server 端是否存在</li>
<li>server 端回應存在</li>
<li>前端接著會通知說準備傳送資料</li>
</ol>
</li>
<li><p>二、傳送資料階段：前端會透過某個 method 來送出請求，例如 get。server 端接收到請求後，不管成功與否，會回傳一段資料和狀態碼(status code)給前端，這時前端就能判斷請求有沒有成功。</p>
</li>
<li><p>三、說再見階段(四次分手)：</p>
<ol>
<li>前端會先通知 server 端準備分手</li>
<li>server 端收到通知後，會先回傳可以理解的訊息</li>
<li>接著 server 端會再通知一個執行分手動作的訊息</li>
<li>前端回傳 ok(此處 server 正式分手斷線)，而前端大約 4 分鐘後才會釋出資源正式斷線</li>
</ol>
</li>
</ul>
<p>這麼嚴謹的機制帶來的就是速度慢，效率不佳，消耗的資源也多，尤其三次握手階段，容易出現漏洞被攻擊。</p>
</li>
</ul>
<h3 id="簡單說幾個常見的-http-狀態碼？"><a href="#簡單說幾個常見的-http-狀態碼？" class="headerlink" title="簡單說幾個常見的 http 狀態碼？"></a>簡單說幾個常見的 http 狀態碼？</h3><ul>
<li><p>1XX =&gt; server 端已收到請求，需要請求者繼續執行操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100 &#x2F;&#x2F; 臨時性的狀態碼，client 仍在繼續發送請求</span></pre></td></tr><tr><td class="code"><pre><span class="line">101 &#x2F;&#x2F; server 端依據 client 端的請求切換協議(只能向上切換)</span></pre></td></tr></table></figure>
</li>
<li><p>2XX =&gt; 請求已成功，server 端成功接收並執行處理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">200 &#x2F;&#x2F; server 端回傳成功 status code</span></pre></td></tr></table></figure>
</li>
<li><p>3XX =&gt; 請求重定向網址，需要進一步的操作來完成請求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">301 &#x2F;&#x2F; 請求的網頁或資源已被移到新的 URL，之後的請求都必須使用新的 URL</span></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>4XX =&gt; client 端出現錯誤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400 &#x2F;&#x2F; 前端直接送錯請求，server 端無法解析處理</span></pre></td></tr><tr><td class="code"><pre><span class="line">401 &#x2F;&#x2F; 缺少 Token 或是認證失敗，需要登入的頁面，常會進行這個狀態阻擋</span></pre></td></tr><tr><td class="code"><pre><span class="line">403 &#x2F;&#x2F; 認證已完成，但權限不足被擋住</span></pre></td></tr><tr><td class="code"><pre><span class="line">404 &#x2F;&#x2F; server 端找不到請求的網頁，或者是找不到資源</span></pre></td></tr></table></figure>
</li>
<li><p>5XX =&gt; server 端出現錯誤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">500 &#x2F;&#x2F; server 端遇到錯誤(通常是掛了)</span></pre></td></tr><tr><td class="code"><pre><span class="line">502 &#x2F;&#x2F; 網關或代理錯誤，通常是某個服務或功能爆了</span></pre></td></tr><tr><td class="code"><pre><span class="line">503 &#x2F;&#x2F; server 暫時無法使用(常用於停機維修)</span></pre></td></tr><tr><td class="code"><pre><span class="line">504 &#x2F;&#x2F; 一直沒收到請求，也就是所謂的 api 請求超時</span></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="http-狀態碼-401-和-403-兩者有什麼區別？"><a href="#http-狀態碼-401-和-403-兩者有什麼區別？" class="headerlink" title="http 狀態碼 401 和 403 兩者有什麼區別？"></a>http 狀態碼 401 和 403 兩者有什麼區別？</h3><ul>
<li><p>401：<br>代表認證錯誤，可能缺少 Token 或是認證失敗，如果確定程式碼正確，那有時候可能是偶發性的臨時狀況，通常這時候會請用戶直接重整頁面。</p>
</li>
<li><p>403：<br>則是認證本身已經成功，只是目前這個用戶沒有權限去訪問想進入的頁面，所以通常會看到頁面通知說，請聯繫管理員或客服之類的訊息。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Interview</tag>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>面試問題：ES6</title>
    <url>/2019/06/05/interview/es6/</url>
    <content><![CDATA[<p>ES6 的面試問題，更多會是原生 JS 問題延伸過來，所以在回答問題上，可以更靈活結合兩者來答覆，譬如說，當問到 this 的指向問題時，先回答 ES5 的情境，再延伸論述 ES6 加上的 arrow function 的狀況，可以讓答案更為完整。但目前 ES6 的問題整理較少，有空我就會盡量補充。</p>
<a id="more"></a>
<h3 id="定義-var、let、const"><a href="#定義-var、let、const" class="headerlink" title="定義 var、let、const"></a>定義 var、let、const</h3><p>在 ES6 中，新增了兩種變數宣告方式 let、const，傳統的 var 容易污染到全域變數，因此在 ES6 調整了變數應用在作用域的範圍，通常是以 function 為分界，使用 let 在 function 內宣告變數後，可以避免離開 function 仍被污染，另一方面也可以再次賦值。const 定義為常數，不能重複賦值，而且也要求一定要賦值。</p>
<h3 id="僅宣告-const-a-會出現什麼狀況？"><a href="#僅宣告-const-a-會出現什麼狀況？" class="headerlink" title="僅宣告 const a 會出現什麼狀況？"></a>僅宣告 const a 會出現什麼狀況？</h3><p>const 作為一種常數宣告，不允許未賦值的情況，會跳出以下錯誤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Uncaught SyntaxError: Missing initializer in const declaration</span></pre></td></tr></table></figure>
<p>但是 var、let 可以接受未賦值時，預設值為 undefined</p>
<h3 id="請簡單說明-arrow-function？"><a href="#請簡單說明-arrow-function？" class="headerlink" title="請簡單說明 arrow function？"></a>請簡單說明 arrow function？</h3><p>最簡單的說法，更簡短的函式宣告方式，省略了 function 改用 =&gt; 取代，但除了這點外，語法特性上，若參數僅有一個的情況下可以省略()，另外若 return 只有一行的狀況下可以省略 {}，但這邊是看團隊的 coding style，我個人不習慣太省略的寫法。</p>
<p>另外需要注意，在 ES6 中使用 arrow function 的狀況下，this 會被全部指向全域變數(window)。</p>
<h3 id="ES5-和-ES6-的差異？"><a href="#ES5-和-ES6-的差異？" class="headerlink" title="ES5 和 ES6 的差異？"></a>ES5 和 ES6 的差異？</h3><ul>
<li><p>作用域的區分更為嚴謹，新增了兩種宣告變量的方式，避免污染問題。</p>
</li>
<li><p>arrow function：讓函式的寫法變得更為簡短，雖然極短可以在只有一行回傳時，可以縮減大括號({})，但我不考慮這樣寫，維護和閱讀都很不容易。另外也讓 this 的指向問題變得更為單純，全部指向全域變數(window)。</p>
</li>
<li><p>字符串模板，讓程式碼更為簡潔，避免過往的頻繁 ‘’ + ‘’。</p>
</li>
<li><p>非同步操作：提供 Promise 方法來改善過往的 callback 的問題，但會建議和 async/await 一起搭配，否則也是會容易出現 .then() 串下去的窘境。</p>
</li>
<li><p>解構賦值讓變數交換簡化，同時書寫起來更為方便。</p>
</li>
<li><p>class 會是比較重要的概念，雖然嚴格來說還不能稱為物件導向，但應該算是近似了。透過 class 的方式搭配 constructor 建立物件(這個物件就是原型)。當我 new 一個新的物件時，同時會傳屬性進去，再透過 constructor 內進行賦值，接著就可以執行我想要執行的函式。而且當原型建立後，我可以在外面宣告數個 new 物件，分別傳不同屬性進去。</p>
</li>
<li><p>模組化規劃寫法，import 導入，export 導出。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Interview</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>面試問題：JavaScript</title>
    <url>/2019/06/04/interview/js/</url>
    <content><![CDATA[<p>關於原生 JavaScript 的一些面試問題彙整，當然網路上可以找到一海票問題，但目前就是依序整理出答案才會列出來(雖然有些答案依然不夠完善)。後續大概每 20 題就整理一個 page，方便自己日後查看。</p>
<a id="more"></a>
<h3 id="什麼是-DOM"><a href="#什麼是-DOM" class="headerlink" title="什麼是 DOM ?"></a>什麼是 DOM ?</h3><p>我們所撰寫的 HTML 文件，瀏覽器會解析成樹狀結構，父層包覆子層形成一個 document 文件，每一個元素都可以理解為物件，DOM 操作就是透過 JS 去操作這些物件去執行行為。同時為了避免操作過程中，污染相同屬性的元素，譬如兩個 p 標籤，所以我們會透過 id 或 class 來指定操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.getElementById(id)</span></pre></td></tr><tr><td class="code"><pre><span class="line">document.querySelector(.className)</span></pre></td></tr></table></figure>

<h3 id="為什麼我們要將-JS-檔案放在-body-尾端？"><a href="#為什麼我們要將-JS-檔案放在-body-尾端？" class="headerlink" title="為什麼我們要將 JS 檔案放在 body 尾端？"></a>為什麼我們要將 JS 檔案放在 body 尾端？</h3><p>瀏覽器在解析 HTML 文件時，如果遇到 script 標籤，會先將 JS 檔案執行完畢才繼續執行解析 HTML。如果 JS 內容龐大，那對頁面來說載入時間就相對拉長，這是很不利於使用體驗的，更糟的是，如果 JS 執行過程中出錯，有很大機率會卡住呈現空白頁面。</p>
<p>因此基於瀏覽者的使用體驗，我們必須先確保最低的使用體驗，優先讓靜態 HTML 結構搭建完成，再執行動態的 JS。</p>
<h3 id="請問什麼是-this？"><a href="#請問什麼是-this？" class="headerlink" title="請問什麼是 this？"></a>請問什麼是 this？</h3><p>this 雖然簡單來說就是函式內的執行情境(function context)，但需要拆成 ES5 和 ES6 兩種狀況來解釋。 </p>
<p>在 ES5 的時候，是根據 function 內的動作來決定 this 指向的對象，如果 function 沒有做其他處理，那就會自動往外尋找全域變數。e.g.：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">var myName &#x3D; function () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(this.name) &#x2F;&#x2F; 這邊的 this 向函式外尋找變數</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">myName() &#x2F;&#x2F; 印出 Pitt</span></pre></td></tr></table></figure>
<p>但如果 function 被賦值給物件，那就會向物件內尋找變數。e.g：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">var myName &#x3D; function () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(this.name)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">var newName &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  name: &#39;Nini&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">newName.myName &#x3D; myName</span></pre></td></tr><tr><td class="code"><pre><span class="line">newName.myName() &#x2F;&#x2F; 印出 Nini</span></pre></td></tr></table></figure>
<p>但如果 function 的執行被綁在 DOM 元素上，譬如 click 事件，那麼 this 就會被指向 DOM 上面相同名稱的變數。</p>
<p>但到了 ES6 的環境下，this 的指向不再這麼複雜，透過 arrow function 的自動綁定的特性，this 一律指向全域變數(window)。</p>
<h3 id="簡單說明立即函式-IIFE-。"><a href="#簡單說明立即函式-IIFE-。" class="headerlink" title="簡單說明立即函式(IIFE)。"></a>簡單說明立即函式(IIFE)。</h3><p>寫法格式如下，用小括號包裹，並在最後額外加上一個 ()。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 兩種寫法都可以</span></pre></td></tr><tr><td class="code"><pre><span class="line">(function () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;())</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">(function () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)()</span></pre></td></tr></table></figure>
<p>他有兩個特點，一是會被立即執行，二是不管對立即函式是否命名，它都無法在函式再次被執行。基於函式作用域會銷毀變數的特性，立即函式執行完畢後，也不會保留其作用域內的變數，因此常用於限制變數的作用域。立即函式可以透過結尾 () 傳參，再加上其也是表達式的特性，因此也可以透過變數，接受它 return 的結果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var test &#x3D; (function (val) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return val</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)(&#39;params&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(test) &#x2F;&#x2F; 印出 params</span></pre></td></tr></table></figure>
<p>另外，因為立即函式的特性，連續兩個立即函式，會造成 ASI(自動補全分號)的規則沒有運作。因此在連續兩組立即函式的狀況下，需要自己補上分號。立即函式在一般開發比較少見，以我個人開發經驗是完全沒用過，但在框架的底層程式碼中，立即函式是有被使用的，通常用於保證變數有被正常掛載到全域變數上。</p>
<h3 id="請簡單說明-JS-的原型。"><a href="#請簡單說明-JS-的原型。" class="headerlink" title="請簡單說明 JS 的原型。"></a>請簡單說明 JS 的原型。</h3><p>我們使用原型的目的，在於建立一個樣板或者說藍圖，透過這個樣板，我們放入屬性或方法，這樣可以快速建立 instance(實體)，e.g.：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person (name, type) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  this.name &#x3D; name</span></pre></td></tr><tr><td class="code"><pre><span class="line">  this.type &#x3D; type</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">var boy &#x3D; new Person(&#39;pitt&#39;, &#39;boy&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">var girl &#x3D; new Person(&#39;kumi&#39;, &#39;girl&#39;)</span></pre></td></tr></table></figure>
<p>另外，prototype 也可以優化 function 佔用的記憶體空間，e.g.：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person (name, type) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  this.name &#x3D; name</span></pre></td></tr><tr><td class="code"><pre><span class="line">  this.type &#x3D; type</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  this.say &#x3D; function () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(&#96;$&#123;this.name&#125; is a $&#123;this.type&#125; say Hi!&#96;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">var boy &#x3D; new Person(&#39;pitt&#39;, &#39;boy&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">var girl &#x3D; new Person(&#39;kumi&#39;, &#39;girl&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(boy.say &#x3D;&#x3D;&#x3D; girl.say) &#x2F;&#x2F; false</span></pre></td></tr></table></figure>
<p>雖然他們呼叫同一個函式，但卻各自佔用一個空間，在專案小的時候，可能差異不大，但大型專案或多或少會影響效能，因此可以透過 function prototype 來優化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person (name, type) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  this.name &#x3D; name</span></pre></td></tr><tr><td class="code"><pre><span class="line">  this.type &#x3D; type</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Person.prototype.say &#x3D; function () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(&#96;$&#123;this.name&#125; is a $&#123;this.type&#125; say Hi!&#96;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">var boy &#x3D; new Person(&#39;pitt&#39;, &#39;boy&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">var girl &#x3D; new Person(&#39;kumi&#39;, &#39;girl&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(boy.say &#x3D;&#x3D;&#x3D; girl.say) &#x2F;&#x2F; true</span></pre></td></tr></table></figure>

<h3 id="簡單聊一下繼承。"><a href="#簡單聊一下繼承。" class="headerlink" title="簡單聊一下繼承。"></a>簡單聊一下繼承。</h3><ul>
<li>ES5 的寫法，使用 Object.create() e.g.：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person (name, type) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  this.name &#x3D; name</span></pre></td></tr><tr><td class="code"><pre><span class="line">  this.type &#x3D; type</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">var boy &#x3D; new Person(&#39;pitt&#39;, &#39;boy&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">var girl &#x3D; new Person(&#39;kumi&#39;, &#39;girl&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">var man &#x3D; Object.create(boy)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(man)</span></pre></td></tr></table></figure>
對 man 這個變數來說，它繼承到的原型 Person 只是一個空物件，但因為原型練的特性，他會向上找 <code>__proto__</code> 的內容，這時候就會找到屬性與方法，e.g.：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(man.name) &#x2F;&#x2F; pitt</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(man.type) &#x2F;&#x2F; boy</span></pre></td></tr></table></figure></li>
<li>在 ES6 中引入新的寫法 class，e.g.：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Player &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; 使用 function constructor (建構式)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  constructor (playerName, hp) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    this.playerName &#x3D; playerName</span></pre></td></tr><tr><td class="code"><pre><span class="line">    this.hp &#x3D; hp</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  playerStatus () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(&#96;玩家名稱：$&#123;this.playerName&#125;，玩家血量：$&#123;this.hp&#125;&#96;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">var Pitt &#x3D; new Player(&#39;Pitt&#39;, 200)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Pitt.playerStatus()</span></pre></td></tr></table></figure></li>
<li>子類別也可以透過 extends &amp;&amp; super 去繼承父類別的方法與屬性，e.g.：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; father</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Player &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; 使用 function constructor (建構式)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  constructor (playerName, hp) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    this.playerName &#x3D; playerName</span></pre></td></tr><tr><td class="code"><pre><span class="line">    this.hp &#x3D; hp</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  playerStatus () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(&#96;玩家名稱：$&#123;this.playerName&#125;，玩家血量：$&#123;this.hp&#125;&#96;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">var Pitt &#x3D; new Player(&#39;Pitt&#39;, 200)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Pitt.playerStatus()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; son</span></pre></td></tr><tr><td class="code"><pre><span class="line">class BeginnerPlayer extends Player &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  constructor (playerName, hp, job) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    super(playerName, hp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    this.job &#x3D; job</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  playerJob () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(&#96;玩家：$&#123;this.playerName&#125;，血量：$&#123;this.hp&#125;，初始職業為$&#123;this.job&#125;&#96;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">var Lisa &#x3D; new BeginnerPlayer(&#39;Lisa&#39;, 300, &#39;初心者&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Lisa.playerJob()</span></pre></td></tr></table></figure>
但我在前職中幾乎沒有使用過。不過在 React 這個寫法是極其普遍的：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Board extends React.Components &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  constructor (props) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    super(props)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="請說明什麼是閉包？"><a href="#請說明什麼是閉包？" class="headerlink" title="請說明什麼是閉包？"></a>請說明什麼是閉包？</h3><p>簡單說，就是當 JS 的 function 因為GC(垃圾回收)機制觸發，導致函式執行完後，內部作用域內容會被銷毀。這時可以透過子函式來保存我們需要的變數或內容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function deposit () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  var cash &#x3D; 100</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return function (coin) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cash &#x3D; cash + coin</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return cash</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>因為子函式沒有被銷毀，加上範圍鍊的原則，子函式調用外面父函式的變數 cash，因此父函式作用域在閉包的狀況下被保存下來，同時後續宣告不同變數時，也可以獨立調用這一組函式而不用擔心互相污染。另外，變數宣告在父函式時，又可以避免變數宣告在全域的污染問題。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function deposit () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  var cash &#x3D; 100</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return function (coin) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cash &#x3D; cash + coin</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return cash</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">var PittPay &#x3D; deposit()</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(PittPay(100)) &#x2F;&#x2F; 200</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(PittPay(100)) &#x2F;&#x2F; 300</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(PittPay(100)) &#x2F;&#x2F; 400</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">var KimiPay &#x3D; deposit()</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(KimiPay(200)) &#x2F;&#x2F; 300</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(KimiPay(200)) &#x2F;&#x2F; 500</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(KimiPay(200)) &#x2F;&#x2F; 700</span></pre></td></tr></table></figure>

<h3 id="濫用閉包會造成的問題？"><a href="#濫用閉包會造成的問題？" class="headerlink" title="濫用閉包會造成的問題？"></a>濫用閉包會造成的問題？</h3><p>原本 JS 提供的垃圾回收機制，就是希望函式結束後銷毀變數，釋放出記憶體資源，但因為閉包的特性，會使變數被保存下來，自然記憶體也就一直存著變數，記憶體消耗變大，網頁效能也就越來越差。</p>
<h3 id="簡單說明-Hoisting-變量提升-。"><a href="#簡單說明-Hoisting-變量提升-。" class="headerlink" title="簡單說明 Hoisting(變量提升)。"></a>簡單說明 Hoisting(變量提升)。</h3><p>JS 的運行可以拆解為兩階段，分別是創造與執行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(name) &#x2F;&#x2F; 印出 Pitt</span></pre></td></tr></table></figure>
<p>在變數中，上面這段 code 在實際運作上，需要理解為</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 創造</span></pre></td></tr><tr><td class="code"><pre><span class="line">var name</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 執行</span></pre></td></tr><tr><td class="code"><pre><span class="line">name &#x3D; &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(name)</span></pre></td></tr></table></figure>
<p>而函式又和變數不同，在創造階段就會指給記憶體，陳述式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getName()</span></pre></td></tr><tr><td class="code"><pre><span class="line">function getName () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(&#39;string&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>上面這段之所以能正常運行印出 console.log，而不會報錯，在於以下邏輯</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 創造</span></pre></td></tr><tr><td class="code"><pre><span class="line">function getName () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(&#39;string&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 執行</span></pre></td></tr><tr><td class="code"><pre><span class="line">getName()</span></pre></td></tr></table></figure>
<p>但需要注意的是，這種 JS 提升的性質，在表達式時需要注意撰寫順序問題<br>創造階段 =&gt; 函式優先，其次才是變數</p>
<ul>
<li>success<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name &#x3D; &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(name) &#x2F;&#x2F; 印出 Pitt</span></pre></td></tr><tr><td class="code"><pre><span class="line">var name</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">相等於</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 創造</span></pre></td></tr><tr><td class="code"><pre><span class="line">var name</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 執行</span></pre></td></tr><tr><td class="code"><pre><span class="line">name &#x3D; &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(name) &#x2F;&#x2F; 印出 Pitt</span></pre></td></tr></table></figure></li>
<li>error<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(name) &#x2F;&#x2F; 印出 undefined</span></pre></td></tr><tr><td class="code"><pre><span class="line">var name &#x3D; &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">相等於</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 創造</span></pre></td></tr><tr><td class="code"><pre><span class="line">var name</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 執行</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(name) &#x2F;&#x2F; 印出 undefined，還未拿到賦值，只拿到預設的 undefined</span></pre></td></tr><tr><td class="code"><pre><span class="line">name &#x3D; &#39;Pitt&#39;</span></pre></td></tr></table></figure></li>
<li>e.g.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whoseName()</span></pre></td></tr><tr><td class="code"><pre><span class="line">function whoseName () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  if (name) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name &#x3D; &#39;Nini&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">var name &#x3D; &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(name)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">相等於</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 創造</span></pre></td></tr><tr><td class="code"><pre><span class="line">function whoseName () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(1, name) &#x2F;&#x2F; &#x3D;&gt; 拿到預設的 undefined，因此不往下走判斷</span></pre></td></tr><tr><td class="code"><pre><span class="line">  if (name) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name &#x3D; &#39;Nini&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">var name</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 執行</span></pre></td></tr><tr><td class="code"><pre><span class="line">whoseName()</span></pre></td></tr><tr><td class="code"><pre><span class="line">name &#x3D; &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(name) &#x2F;&#x2F; 印出 Pitt</span></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="簡單說明-JavaScript-為何需要非同步？簡單聊一下對-call-stack-跟-event-loop-的理解。"><a href="#簡單說明-JavaScript-為何需要非同步？簡單聊一下對-call-stack-跟-event-loop-的理解。" class="headerlink" title="簡單說明 JavaScript 為何需要非同步？簡單聊一下對 call stack 跟 event loop 的理解。"></a>簡單說明 JavaScript 為何需要非同步？簡單聊一下對 call stack 跟 event loop 的理解。</h3><p>JS 的本質是單線程的語言，因為它的工作之一就是修改瀏覽器的 DOM 結構，如果多線程但同時修改同一個節點，會讓整體情況變得相當複雜，所以為了避免複雜的狀況發生，因此才會採用單線程。而非同步就是因應單線程的背景，假設某個動作需要等待 2 秒，瀏覽器當然不可能等在原地 2 秒，因此會先執行所有同步性的工作，而所有非同步性的工作則先放到 task queue(任務等待序列)。瀏覽器先執行同步性工作的環境，可以理解為包在 call stack 區間，瀏覽器先依序把 call stack 內的工作執行完畢，當它檢查到 call stack 為空時，接著前往 task queue 中將等待序列的工作丟到 call stack 依序執行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">瀏覽器檢查 call stack 是否為空</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x3D;&gt; 否 &#x3D;&gt; 回到 call stack 繼續執行</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x3D;&gt; 是 &#x3D;&gt; 進入 task queue 開始將非同步工作丟到 call stack 執行</span></pre></td></tr></table></figure>
<p>這樣不斷循環的過程就是 event loop。e.g.：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">setTimeout(function() &#123; &#x2F;&#x2F; &#x3D;&gt; 這種非同步的函式就是 callback</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;, 0);</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 依序印出 1 3 2</span></pre></td></tr></table></figure>

<h3 id="如何用-JS-原生方法實作回上頁的功能？"><a href="#如何用-JS-原生方法實作回上頁的功能？" class="headerlink" title="如何用 JS 原生方法實作回上頁的功能？"></a>如何用 JS 原生方法實作回上頁的功能？</h3><p>可以使用下述這兩種方法：</p>
<ul>
<li><p>回到上一頁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.history.back</span></pre></td></tr></table></figure>
</li>
<li><p>指定回到上一頁，若傳入參數為 -2，則指定回到上二頁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.history.go(-1)</span></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="簡單聊一下-JS-的事件傳遞機制。"><a href="#簡單聊一下-JS-的事件傳遞機制。" class="headerlink" title="簡單聊一下 JS 的事件傳遞機制。"></a>簡單聊一下 JS 的事件傳遞機制。</h3><p>經典名言</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先捕獲，再冒泡</span></pre></td></tr></table></figure>
<p>當我們點擊目標時，會先從 window 往下依序捕獲，直到到達 target，等到到達目標後，在逆向冒泡回去。這樣一個捕獲和冒泡，就是所謂的事件傳播。但需要注意，當到達目標時，沒有區分捕獲和冒泡，會根據程式碼撰寫的順序執行，直到脫離目標，再恢復回冒泡。</p>
<p>取消事件傳遞機制 e.stopPropagation，而這整個循環機制就是一個事件委託。</p>
]]></content>
      <tags>
        <tag>Interview</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>面試問題：CSS</title>
    <url>/2019/06/03/interview/css/</url>
    <content><![CDATA[<p>CSS 面試問題彙整。</p>
<a id="more"></a>
<h3 id="簡單聊聊-box-model"><a href="#簡單聊聊-box-model" class="headerlink" title="簡單聊聊 box-model"></a>簡單聊聊 box-model</h3><p>box-model 可以理解為前端工程師製作網頁的一種工具，透過它可以定義網頁上元素的位置，進而達到排版的目的。從內到外，環繞它身邊有三個語法，padding、border、margin。其中前兩者預設會影響到元素，因此在 box-sizing 會採用另一個模式 border-box，來避免不必要的計算。</p>
<h3 id="請解釋-box-sizing-border-box-，並且說明使用它的好處？"><a href="#請解釋-box-sizing-border-box-，並且說明使用它的好處？" class="headerlink" title="請解釋 * { box-sizing: border-box; }，並且說明使用它的好處？"></a>請解釋 * { box-sizing: border-box; }，並且說明使用它的好處？</h3><p><img src="/images/box-sizing.png" alt=""><br>box-sizing =&gt; 意指，當元素計算寬度和高度時，border &amp; padding 會內含還是外加。<br>content-box =&gt; 預設的屬性，會使 border &amp; padding 添加額外的寬高(外加)。</p>
<p>但前述這個設計，會使前端開發時被迫需要一直計算寬高，為了改善這個開發體驗，所以改用以下模式：<br>border-box =&gt; 將 border &amp; padding 塞進元素本身(內含)。<br>因此我們通常建議在初始化樣式時，加入到 <code>*</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  box-sizing: border-box;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<ul>
<li><a href="https://zh-tw.learnlayout.com/box-sizing.html" target="_blank" rel="noopener">圖片詳解</a></li>
</ul>
<h3 id="如何處理水平垂直置中？"><a href="#如何處理水平垂直置中？" class="headerlink" title="如何處理水平垂直置中？"></a>如何處理水平垂直置中？</h3><p>在 flexbox 語法中，處理這個需求並不困難：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  display: flex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  justify-content: center;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  align-items: center;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>但如果不使用 flexbox 就會比較麻煩，首先水平置中，常用兩種方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  margin: 0 auto;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">div &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  text-align: center;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>至於垂直置中的方法有數種，但我這邊只記錄兩種(後續待補充)：</p>
<ol>
<li>line-height</li>
<li>vertical-align: middle;</li>
</ol>
<p>但基本我個人現在只用 flexbox 語法來處理，未來會再加上 grid。</p>
<h3 id="倘若有不同的樣式表-stylesheets-，該如何整併到網站？"><a href="#倘若有不同的樣式表-stylesheets-，該如何整併到網站？" class="headerlink" title="倘若有不同的樣式表 (stylesheets)，該如何整併到網站？"></a>倘若有不同的樣式表 (stylesheets)，該如何整併到網站？</h3><p>以 Vue 專案結構為例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- assets</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - scss</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - color.scss</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - mixin.scss</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - share.scss</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - style.scss</span></pre></td></tr></table></figure>
<p>將共用顏色(color)和共用函式(breakpoint、position)進行拆分，兩者都 @import 到 share.scss，各 component 的 style.scss 直接 @import share.scss。同時再將 share.scss @import 到 style.scss，在 assets/scss/style.scss，被視為權重最高的樣式表，除了進行樣式初始化，也是用來處理特定需求(譬如覆蓋套件的樣式)，並將其註冊到 main.js。</p>
<h3 id="如何處理專案-RWD"><a href="#如何處理專案-RWD" class="headerlink" title="如何處理專案 RWD"></a>如何處理專案 RWD</h3><ul>
<li><p>共用參數<br>假設 UI/UX 為首次合作，因此會先討論網站的色系與主要的共用間距(當然如果是經驗豐富的 UI/UX，這一步可以忽略)，因為斷點、三輔一主的色系、常用間距，需先準備在 scss 作為共用參數。至於斷點，現在市面上，320px 尺寸的手機(iPhone5)，雖然市佔率已經相當低，但目前開發上仍會考慮保留，因此預期我的斷點會設計：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">360 &#x3D;&gt; 兼容小尺寸 android &amp; iPhone5</span></pre></td></tr><tr><td class="code"><pre><span class="line">480 &#x3D;&gt; 主流手機</span></pre></td></tr><tr><td class="code"><pre><span class="line">768 &#x3D;&gt; pad</span></pre></td></tr><tr><td class="code"><pre><span class="line">pc &#x3D;&gt; 這個沒有固定，視討論而定，通常1024(但其實也可以用 padPro來命名)</span></pre></td></tr></table></figure>
</li>
<li><p>UI Framework<br>主要分為兩種狀況，手刻或者用框架：</p>
<ul>
<li>手刻：目前主流是用 flexbox(目前兼容性已經極高了，哪怕是大陸冷門瀏覽器 QQ、UC)，至於 grid 目前來說，對移動裝置的支援還有疑慮，稍微舊一點的版本或是冷門瀏覽器都是不支援居多，還需要一點時間讓瀏覽器廠商跑步前進。<ul>
<li><a href="https://hackmd.io/tlJAS8MqQ0qqJ0wh3sggsw" target="_blank" rel="noopener">瀏覽器市佔率</a></li>
</ul>
</li>
<li>框架：這就看團隊的技術選型，根據團隊採用不同的前端框架，相應的框架也會有差異，以 Vue 來說，目前海外社群投票最大宗是 Vuetify，其次是 element-ui(但不支援 RWD，主要用於 CMS)，Tailwind CSS 正在追趕，Bootstrap 這我不太確定，需等 v5 之後的版本觀察。<ul>
<li><a href="https://hackmd.io/mmVT15NkT8KZJTR5octHlA" target="_blank" rel="noopener">Tailwind CSS</a></li>
</ul>
</li>
</ul>
<p>至於更細節的開發，就視實際的設計稿而定，這邊不再贅述了。</p>
</li>
</ul>
<h3 id="比較-CSS1、CSS2、CSS3-的區別？"><a href="#比較-CSS1、CSS2、CSS3-的區別？" class="headerlink" title="比較 CSS1、CSS2、CSS3 的區別？"></a>比較 CSS1、CSS2、CSS3 的區別？</h3><ul>
<li><p>規範：<br>CSS1 年代比較偏向是為了更好維護 HTML 結構，將樣式抽離 tag，並賦予一些基礎屬性可以改變，譬如文字、文章內容、字體、顏色等等。<br>CSS2 改變了樣式表的概念，不在單純使用 table td 等元素，開始使用 div 或是 ul li 之類的 tag 來建立結構後，再透過 CSS 改變樣式。<br>CSS3 除了導入新的特性，也開始要求模組化的機制。</p>
</li>
<li><p>選擇器方面：<br>CSS1 屬於簡單選擇器，也就是 id、class 之類的。</p>
<p>CSS2 開始添加偽元素(before、after)。</p>
<p>CSS3 開始組合選擇器，後代與子選擇器，可以指定某個元素下的所有元素，或是同層級所有元素(使用 +)，又或者是通用兄弟選擇器(使用 ~)，另外新增屬性選擇器。</p>
</li>
<li><p>字體：<br>在 1、2 的時候，多半只能使用安全字體，也就是通用型字體，但到了 3 開始可以引用一些特殊字體。</p>
</li>
<li><p>文章內容：<br>到了 3 開始提供自動斷行功能，讓文章中的文字可以自行換行。</p>
</li>
<li><p>網頁設計：<br>border-radius 之類圓角設計，開始在 3 的時代出現，另外也開始加入動畫特效。</p>
</li>
</ul>
<h3 id="若不使用-flexbox，float-如何置中？"><a href="#若不使用-flexbox，float-如何置中？" class="headerlink" title="若不使用 flexbox，float 如何置中？"></a>若不使用 flexbox，float 如何置中？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; pug</span></pre></td></tr><tr><td class="code"><pre><span class="line">.wrap</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .main</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ul</span></pre></td></tr><tr><td class="code"><pre><span class="line">      li.box.blue</span></pre></td></tr><tr><td class="code"><pre><span class="line">      li.box.green</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; css</span></pre></td></tr><tr><td class="code"><pre><span class="line">.wrap &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  float: left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  position: relative;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  left: 50%;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">.main &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  float: left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  position: relative;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  left: -50%;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="元素設定-flex-屬性後，float-會發生什麼情況？"><a href="#元素設定-flex-屬性後，float-會發生什麼情況？" class="headerlink" title="元素設定 flex 屬性後，float 會發生什麼情況？"></a>元素設定 flex 屬性後，float 會發生什麼情況？</h3><p>在 CSS 規範中，父元素設定 flex 屬性後，子元素的 float 即會失效，另一方面，兩者也不應該共用。</p>
]]></content>
      <tags>
        <tag>Interview</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>面試問題：HTML</title>
    <url>/2019/06/02/interview/html/</url>
    <content><![CDATA[<p>其實 HTML 相關問題考的是比較少的，所以現階段整理的內容也不多，只能等後續有看到就補充進去。</p>
<a id="more"></a>
<h3 id="doctype-做什麼用的？"><a href="#doctype-做什麼用的？" class="headerlink" title="doctype 做什麼用的？"></a><code>doctype</code> 做什麼用的？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用來定義網頁編寫的 HTML 採用什麼版本。</span></pre></td></tr></table></figure>

<h3 id="有用過-HTML-樣板語言（template-languages）嗎？"><a href="#有用過-HTML-樣板語言（template-languages）嗎？" class="headerlink" title="有用過 HTML 樣板語言（template languages）嗎？"></a>有用過 HTML 樣板語言（template languages）嗎？</h3><p>目前使用 <code>pug</code>，除了減少閉合標籤，也能讓 template 更為簡潔。</p>
<h3 id="簡單說明-HTML5-的特色"><a href="#簡單說明-HTML5-的特色" class="headerlink" title="簡單說明 HTML5 的特色"></a>簡單說明 HTML5 的特色</h3><ul>
<li>語意化：諸如 header、main、section 之類的語意化標籤，善用這些標籤能對網站 SEO 能更加友善。</li>
<li>多媒體：隨著 HTML5 開始支援播放影片音樂，成為壓垮 flash 的主因之一。Canvas 除了讓網頁直接繪出圖形，也讓許多遊戲產業獲得更好的發展。</li>
<li>API：增加許多 API 方法，諸如支援移動裝置的 touch 事件、地理資訊紀錄(Geolocation)以及雙向溝通的 websocket(但存有安全性疑慮)。</li>
</ul>
<h3 id="可以簡單列舉常用的-HTML5-語意標籤嗎？"><a href="#可以簡單列舉常用的-HTML5-語意標籤嗎？" class="headerlink" title="可以簡單列舉常用的 HTML5 語意標籤嗎？"></a>可以簡單列舉常用的 HTML5 語意標籤嗎？</h3><ol>
<li>header  =&gt; 網頁的標題，通常放置網站的 logo 或 navbar</li>
<li>nav     =&gt; 網站的選單與導覽列</li>
<li>main    =&gt; 網頁的主要內容</li>
<li>aside   =&gt; 側邊欄或是一些附加內容</li>
<li>section =&gt; 自定義的區塊內容</li>
<li>article =&gt; 一篇文章的內容</li>
<li>footer  =&gt; 網頁的底部，版權宣告或聯絡方式</li>
<li>mark    =&gt; 特殊強調</li>
<li>time    =&gt; 顯示日期時間</li>
</ol>
<h3 id="簡單說明一下-HTML5-的-data-attribute"><a href="#簡單說明一下-HTML5-的-data-attribute" class="headerlink" title="簡單說明一下 HTML5 的 data-attribute"></a>簡單說明一下 HTML5 的 data-attribute</h3><p>相對於過往的 src 或是 type，data-attribute 就是 HTML 的自定義屬性，書寫規範上，不可以使用大寫。建立好的自定義屬性，可以透過 CSS 的偽元素來獲取：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; pug</span></pre></td></tr><tr><td class="code"><pre><span class="line">span(data-value&#x3D;&quot;Hello&quot;) &#x3D;&gt; 可以透過 API 取得的資料先擺上去</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; scss</span></pre></td></tr><tr><td class="code"><pre><span class="line">span &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &amp;::before&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    content: attr(data-value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>也可以建立通用樣式，方便全域調用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p[data-size&#x3D;&quot;lg&quot;] &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  width: 1024px</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>JS 可以透過 dataset 的方法來獲取指定元素的資料</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; pug</span></pre></td></tr><tr><td class="code"><pre><span class="line">div#value(data-value&#x3D;&quot;show&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js</span></pre></td></tr><tr><td class="code"><pre><span class="line">let dataValue &#x3D; document.getElementById(&#39;value&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(dataValue.dataset.value)  &#x2F;&#x2F; 印出 show</span></pre></td></tr></table></figure>
<p>但在瀏覽器的兼容性上，我抱有一定疑慮，透過 can i use 查詢，舊版本的瀏覽器似乎並沒有實作，如果面向的客戶對象為大陸，則多數冷門瀏覽器不兼容。</p>
<h3 id="input-tag-在-HTML-5-中新增的屬性？"><a href="#input-tag-在-HTML-5-中新增的屬性？" class="headerlink" title="input tag 在 HTML 5 中新增的屬性？"></a>input tag 在 HTML 5 中新增的屬性？</h3><ul>
<li><p>時間相關：month(月)、week(週)、time(時、分、秒)</p>
<ul>
<li>date：可以選擇年、月、日</li>
<li>month：選擇年、月</li>
<li>week：選擇週、年</li>
<li>time：選擇時間(時、分)</li>
<li>datetime：選擇時間、日期、月、年(UTC 時間)</li>
<li>datetime-local：選擇時間、日期、月、年(本地時間)</li>
</ul>
</li>
<li><p>email、tel、url、search、number(限制只能輸入數字)、color(顏色選擇器)、range(slide bar)</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Interview</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>面試問題：通用</title>
    <url>/2019/06/01/interview/general/</url>
    <content><![CDATA[<p>這邊主要整理偏向通用性問題，或者比較難區分類別性的面試考題，答案的部分會偏向我個人的經驗處理，可以視你的需求進行調整。</p>
<a id="more"></a>
<h3 id="近期學習了什麼？"><a href="#近期學習了什麼？" class="headerlink" title="近期學習了什麼？"></a>近期學習了什麼？</h3><p>主要在摸索 Nuxt 開發，以及一些架站與 CICD 相關的知識，考慮到未來工作，必須認真看待(前職沒有這個需求) SEO 的需求，SSR 這一塊無可避免會碰觸到，因此抽出一些時間來加以了解。另一方面，查看台北的職缺需求中，對 Nuxt 的要求似乎也相對普遍了(2020年)，因此實務上還是得要求自己盡可能掌握這個框架。</p>
<h3 id="如果今年你能精通一項技術，那會是什麼？-2020"><a href="#如果今年你能精通一項技術，那會是什麼？-2020" class="headerlink" title="如果今年你能精通一項技術，那會是什麼？(2020)"></a>如果今年你能精通一項技術，那會是什麼？(2020)</h3><p>主要希望能將 Nuxt 掌握到熟稔程度，能順利上手開發，但因爲 Nuxt 又是以 Node 為基底，所以 Node 的基礎知識與運用也必須補上。</p>
<h3 id="喜好的開發環境-作業系統-編輯器或-IDE-瀏覽器-開發工具-…-之類-。"><a href="#喜好的開發環境-作業系統-編輯器或-IDE-瀏覽器-開發工具-…-之類-。" class="headerlink" title="喜好的開發環境 (作業系統, 編輯器或 IDE, 瀏覽器, 開發工具 … 之類)。"></a>喜好的開發環境 (作業系統, 編輯器或 IDE, 瀏覽器, 開發工具 … 之類)。</h3><p>前端開發目前主要使用 mac os 系統，一方面是生態系完整，如果遇到問題，相對容易透過網路資訊排除。早期有使用過一陣子 sublime 和 ATOM，後來因為 vscode 急起直追和插件生態日益豐富完整，最後投入 vscode 懷抱。瀏覽器就是以 Chrome 為開發，畢竟習慣了 Chrome 的開發者工作，偶爾還是會回去摸摸 Firefox，但除錯方面，除了是特定瀏覽器破版問題，否則仍以 Chrome 為主。</p>
<h3 id="最熟悉哪一套版本控制系統？"><a href="#最熟悉哪一套版本控制系統？" class="headerlink" title="最熟悉哪一套版本控制系統？"></a>最熟悉哪一套版本控制系統？</h3><p>Git，前職的團隊，主要使用 GUI 工具(SourceTree)，方便查看節點，但目前也持續筆記 git 指令，方便未來自己在終端機直接操作。</p>
<h3 id="可以描述前一份工作在開發一個網站時的流程是？"><a href="#可以描述前一份工作在開發一個網站時的流程是？" class="headerlink" title="可以描述前一份工作在開發一個網站時的流程是？"></a>可以描述前一份工作在開發一個網站時的流程是？</h3><p>依循 4 階段規劃進行開發：分析 =&gt; 規劃 =&gt; 實作 =&gt; 驗證</p>
<ul>
<li>分析：需求營運方+UI/UX+前後端+QA進行開會，明確釐清專案訴求為何？</li>
<li>規劃：專案可能會面臨時程問題，或是技術上目前是否可行，先列出優先度最重要的功能，確保功能面且權重最重者，可以優先上線，後續再針對次要功能與樣式進行優化。</li>
<li>實作：依據現有技術進行實作開發，倘若開發面臨困難，則提前反饋給主管。反之，若實際開發可行，但程式碼不如預期優雅，則以先不報錯為原則，試寫出第一版，後續再進行重構。</li>
<li>驗證：因為目前還未掌握自動化測試，目前驗證手法仍以手動驗證為主，大多採用由其他組員進行手動測試，並撰寫測試文件，當測試通過才發PR給主管。另外，若是QA驗證出現錯誤或是上線後發現錯誤，則統一發佈到issues，再依優先度解決。</li>
</ul>
<h3 id="如果加入了一個專案，但是他們的程式碼用-tabs，但是你習慣用spaces-空白鍵-，你會怎麼做？"><a href="#如果加入了一個專案，但是他們的程式碼用-tabs，但是你習慣用spaces-空白鍵-，你會怎麼做？" class="headerlink" title="如果加入了一個專案，但是他們的程式碼用 tabs，但是你習慣用spaces (空白鍵)，你會怎麼做？"></a>如果加入了一個專案，但是他們的程式碼用 tabs，但是你習慣用spaces (空白鍵)，你會怎麼做？</h3><p>通常若是維護舊專案，會配合既有專案的風格進行開發，但若是新專案，則會討論 coding style 如何處理，不過我個人也是採用 tab。</p>
<h3 id="描述漸進增強-progressive-enhancement-和優美退化-graceful-degradation-間的差異？"><a href="#描述漸進增強-progressive-enhancement-和優美退化-graceful-degradation-間的差異？" class="headerlink" title="描述漸進增強 (progressive enhancement) 和優美退化 (graceful degradation) 間的差異？"></a>描述漸進增強 (progressive enhancement) 和優美退化 (graceful degradation) 間的差異？</h3><ul>
<li><p>漸進漸強：從基本功能開始開發，保證系統在各種瀏覽器環境都可以執行，再逐步增加功能及提升使用者體驗。</p>
</li>
<li><p>優美退化：開發系統時，就針對最新最完善的環境來設計，而對於較舊的平台僅提供基本功能，而非完整功能。</p>
</li>
</ul>
<p>但目前實務上，專案只碰過漸進增強的理念，因為通常專案時程規劃，大都蠻不友善的XD，在有限的時間內，通常是優先讓功能面先上線，後續再逐步優化。</p>
<h3 id="前端效能優化可以怎麼做？"><a href="#前端效能優化可以怎麼做？" class="headerlink" title="前端效能優化可以怎麼做？"></a>前端效能優化可以怎麼做？</h3><p>(這題我目前都回答得不好，後續會再調整答案的部分)<br>受限於現代網站載入的資源體積越來越大，因此若要著手優化網站的效能，大概要先從載入資源大小、畫面渲染兩方面來著手。</p>
<ol>
<li><p>載入資源</p>
<ul>
<li>壓縮並醜化檔案，無論是 css 的 minify，或是 JS 的 uglify，都可以大幅縮減檔案體積，不過目前處理這些工作，大都丟給 webpack 一並處理。</li>
<li>壓縮圖片檔案大小，此前是使用 tinypng 工具。</li>
</ul>
</li>
<li><p>畫面渲染</p>
<ul>
<li>盡可能將 css 抽離出來，不要和 JS 混在一起。在 webpack 中使用 extract-text-webpack-plugin。這麼做的目的，當然是為了利用瀏覽器本身的緩存的特性，因此能用 css 處理的地方就不使用 JS，這樣可以節省開啟頁面的時間。</li>
</ul>
</li>
</ol>
<h3 id="什麼是-Deadlock-死鎖-？"><a href="#什麼是-Deadlock-死鎖-？" class="headerlink" title="什麼是 Deadlock(死鎖)？"></a>什麼是 Deadlock(死鎖)？</h3><p>這邊是指進程死鎖，後端語言具有多線程特性，可以同時執行多個任務，通常會出現某個進程正在等待其中一個資源，結果好死不死，那個資源正在被其他進程使用。當這種狀況出現好幾組時，就很有可能會互相卡住，結果導致無限期僵持，最終陷入死鎖。</p>
<p>造成這種原因的可能因素有兩種，要嘛是資源有限，要不嘛就是進程推進順序不正確。但對 JS 這種單線程語言來說，應該只會出現無限循環而不會出現死鎖。</p>
<!-- ### 優化網頁讀取速度的方法 (感覺上的速度或是真正的讀取時間)。 -->

]]></content>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>重新拾筆</title>
    <url>/2019/05/16/firstPost/</url>
    <content><![CDATA[<p>信手寫一些雜談想法，就當做一篇簡單的隨筆。</p>
<a id="more"></a>
<h2 id="框架選擇"><a href="#框架選擇" class="headerlink" title="框架選擇"></a>框架選擇</h2><p><code>Hexo</code>從2018年開始接觸，期間雖然嘗試寫了幾篇筆記，但終究因為懶，時常無疾而終。雖然後面斷斷續續摸了幾種靜態站點框架，譬如<code>Hugo</code>、<code>Gatsby.js</code>、<code>Gridsome</code>，但始終沒有很順手。</p>
<p>但不否認，我個人蠻看好<code>Gatsby.js</code>的發展性，不過我目前還是走<code>Vue</code>的路線，對於<code>React</code>仍算陌生，<code>Gatsby.js</code>駕馭起來相當吃力，只能暫時放棄，重新運用<code>Hexo</code>作為Blog支撐，不過也不排除未來會遷移過去，就看後續的學習狀況吧。</p>
<h2 id="種一棵樹最好的時間是十年前，其次則是現在"><a href="#種一棵樹最好的時間是十年前，其次則是現在" class="headerlink" title="種一棵樹最好的時間是十年前，其次則是現在"></a>種一棵樹最好的時間是十年前，其次則是現在</h2><p>這句話，出自非洲經濟學家 Dambisa Moyo 的《dead aid》，作為書中的結尾言，非常簡短卻發人省思。從當下時間的角度來看，種下理想最好的決心固然是十年前，畢竟現在就能收穫。但既然這已成了往事，那考慮到未來的時間，<code>現在</code>就是未來的十年前。</p>
<p>勉勵自己，從現在開始認真寫blog吧！</p>
]]></content>
      <tags>
        <tag>隨想</tag>
      </tags>
  </entry>
</search>
