<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Express 框架運用與理解</title>
    <url>/2020/02/16/node-Express/</url>
    <content><![CDATA[<p>Express 算是比較老牌的輕量級 Node.js Web 框架，透過學習使用 Express 來加深自己對 Node 的理解，同時提高對後端的認知。</p>
<a id="more"></a>
<h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始專案</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn init</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn add express</span></pre></td></tr></table></figure>
<h2 id="Open-Web-Server"><a href="#Open-Web-Server" class="headerlink" title="Open Web Server"></a>Open Web Server</h2><p>載入並調用 <code>Express</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">const app &#x3D; express()</span></pre></td></tr></table></figure>
<p>使用 <code>get()</code> 方法，來檢查資料有無傳送到對應頁面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.send(&#39;Hello Express!&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; watch port</span></pre></td></tr><tr><td class="code"><pre><span class="line">let port &#x3D; 3000</span></pre></td></tr><tr><td class="code"><pre><span class="line">app.listen(port)</span></pre></td></tr></table></figure>
<h3 id="監聽端口的正式站環境寫法"><a href="#監聽端口的正式站環境寫法" class="headerlink" title="監聽端口的正式站環境寫法"></a>監聽端口的正式站環境寫法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; process.env &#x3D;&gt; 意指環境變數，當完成部署後，端口由 server 提供</span></pre></td></tr><tr><td class="code"><pre><span class="line">const port &#x3D; process.env.PORT || 3000</span></pre></td></tr><tr><td class="code"><pre><span class="line">app.listen(port)</span></pre></td></tr></table></figure>
<h2 id="params-amp-query"><a href="#params-amp-query" class="headerlink" title="params &amp; query"></a>params &amp; query</h2><p>這兩者概略來說，就是向後端發出請求時所帶的參數，差別在於，url 上所呈現格式不同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 按照之前的開發合作的經驗</span></pre></td></tr><tr><td class="code"><pre><span class="line">params &#x3D;&gt; 通常為必填值</span></pre></td></tr><tr><td class="code"><pre><span class="line">query &#x3D;&gt; 選填值</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">app.get(&#39;&#x2F;user&#x2F;:name&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let userName &#x3D; req.params.name</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let limit &#x3D; req.query.limit</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.send(&#39;&lt;html&gt;&lt;head&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;&#39;+userName+&#39;&lt;&#x2F;h1&gt;&lt;h2&gt;&#39;+limit+&#39;&lt;&#x2F;h2&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h2 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h2><p>意指中介層，等於替資料庫做一層防護，當用戶發出請求進入對應頁面，檢查對方是否符合請求邏輯，譬如登入頁可能會檢查一些帳號資訊等等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 調用 use() 方法做檢查</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">app.use((req, res, next) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(&#39;login&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  next()  &#x2F;&#x2F; next() 方法是為了當邏輯驗證正確後，能繼續執行下一步驟</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h3 id="驗證檢查"><a href="#驗證檢查" class="headerlink" title="驗證檢查"></a>驗證檢查</h3><p>為了避免用戶刻意透過 router 進入頁面，前後端都會進行驗證檢查。此外不存在的資料或是 server 掛了，為了用戶體驗也必須給予對應的狀態提示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 當用戶隨意亂打參數，使用 use() 方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使其進入我們希望他進入的頁面提示，避免直接回傳 cannot get 訊息</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">app.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.send(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#39;&lt;html&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;head&gt;&lt;&#x2F;head&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;body&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;h1&gt;123&lt;&#x2F;h1&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;&#x2F;body&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;html&gt;&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">app.use((req, res, next) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.status(404).send(&#39;404 is not found&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<p><code>use()</code> 方法，除了提示找不到頁面，若是程式碼本身有錯，也可以提醒，通常狀態碼為 500。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 這邊使用了一個未定義的函數，除了出現 not defined 的 error</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 也會回傳 500 的狀態碼</span></pre></td></tr><tr><td class="code"><pre><span class="line">app.use((req, res, next) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  test()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  next()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">app.use((err, req, res, next) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.status(500).send(&#39;sorry try again&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h3 id="增加靜態檔案路徑"><a href="#增加靜態檔案路徑" class="headerlink" title="增加靜態檔案路徑"></a>增加靜態檔案路徑</h3><p>使用 express 提供的原生方法 <code>static()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 建立名為 public 的資料夾作為靜態檔案存放</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 順序上必須放在最前面，方便後面的 router 能正常引用</span></pre></td></tr><tr><td class="code"><pre><span class="line">app.use(express.static(&#39;public&#39;))</span></pre></td></tr></table></figure>
<h2 id="Template-EJS"><a href="#Template-EJS" class="headerlink" title="Template - EJS"></a>Template - EJS</h2><h3 id="Install-1"><a href="#Install-1" class="headerlink" title="Install"></a>Install</h3>]]></content>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 生命週期簡單理解</title>
    <url>/2020/02/13/vue-life-cycle/</url>
    <content><![CDATA[<p>整理 Vue 的生命週期和用法理解。</p>
<a id="more"></a>
<h2 id="數據變化與更新"><a href="#數據變化與更新" class="headerlink" title="數據變化與更新"></a>數據變化與更新</h2><h3 id="beforeUpdate-amp-updated"><a href="#beforeUpdate-amp-updated" class="headerlink" title="beforeUpdate &amp; updated"></a>beforeUpdate &amp; updated</h3><p>透過 @click 事件來達到數據更新的功能。<br>一開始頁面渲染 data 的初始資料，當點擊時觸發函數執行資料更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; template</span></pre></td></tr><tr><td class="code"><pre><span class="line">p &#123;&#123; msg &#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">button(@click&#x3D;&quot;update()&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; data 存放資料的初始值</span></pre></td></tr><tr><td class="code"><pre><span class="line">data () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    msg: &#39;Hello Vue!&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; methods 存放執行的函數，透過點擊執行函數來更新資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">methods: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  update () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    this.msg &#x3D; &#39;Hello Pitt!&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="銷毀"><a href="#銷毀" class="headerlink" title="銷毀"></a>銷毀</h2><h3 id="beforeDestroy-amp-destroyed"><a href="#beforeDestroy-amp-destroyed" class="headerlink" title="beforeDestroy &amp; destroyed"></a>beforeDestroy &amp; destroyed</h3><p>理解銷毀的概念，可以透過 v-if 來理解。當判斷為 false 時，本質上就等於銷毀該 Dom 節點。若預設 data 為 true，一開始頁面渲染時會出現，此時不會觸發 beforeDestroy &amp; destroyed。但當點擊動作觸發轉為 false 時，則會觸發 beforeDestroy &amp; destroyed，這時頁面上被綁定的對象也會消失，即可是為銷毀。</p>
<h2 id="掛載順序"><a href="#掛載順序" class="headerlink" title="掛載順序"></a>掛載順序</h2><p>在 Vue.js 的生命週期中，當頁面渲染時，透過 console.log，可以看到依序為：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. beforeCreate &#x2F;&#x2F; 在這個階段 $el 和 $data 都尚未掛載 &#x3D;&gt; undefined</span></pre></td></tr><tr><td class="code"><pre><span class="line">2. created &#x2F;&#x2F; $data 初始資料已載入，$el 尚未 &#x3D;&gt; undefined</span></pre></td></tr><tr><td class="code"><pre><span class="line">3. beforeMount &#x2F;&#x2F; $el 依然為空 &#x3D;&gt; undefined</span></pre></td></tr><tr><td class="code"><pre><span class="line">4. mounted &#x2F;&#x2F; $el 完成渲染出現資料</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Firebase 操作記錄筆記</title>
    <url>/2020/02/12/firebase-note/</url>
    <content><![CDATA[<p>記錄自己操作 Firebase 的流程，以及問題解法。</p>
<a id="more"></a>
<h2 id="新版-SDK-異動"><a href="#新版-SDK-異動" class="headerlink" title="新版 SDK 異動"></a>新版 SDK 異動</h2><p>除了引入的 firebase-app.js 是主要核心，其他功能則被拆分到各子項目。<br>若要調用 <code>firebase.database()</code> 需再引入以下 script：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;www.gstatic.com&#x2F;firebasejs&#x2F;7.8.2&#x2F;firebase-database.js&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;script&gt;</span></pre></td></tr></table></figure>
<h3 id="檢查是否載入-Firebase-成功"><a href="#檢查是否載入-Firebase-成功" class="headerlink" title="檢查是否載入 Firebase 成功"></a>檢查是否載入 Firebase 成功</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const database &#x3D; firebase.database()</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(database)</span></pre></td></tr></table></figure>
<h2 id="操作資料庫"><a href="#操作資料庫" class="headerlink" title="操作資料庫"></a>操作資料庫</h2><p><code>ref()</code> =&gt; 尋找資料庫路徑<br><code>set()</code> =&gt; 新增資料</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 目前練習使用 Realtime Database</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 若沒有目錄的狀況，預設會寫入到根目錄</span></pre></td></tr><tr><td class="code"><pre><span class="line">firebase.database().ref().set(&#39;Hello Firebase!&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 除了字串，也可以寫入物件</span></pre></td></tr><tr><td class="code"><pre><span class="line">firebase.database().ref().set(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  name: &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h3 id="修改資料"><a href="#修改資料" class="headerlink" title="修改資料"></a>修改資料</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 原始資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">firebase.database().ref(&#39;firstArray&#39;).set([</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: &#39;Pitt&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hasMac: true</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: &#39;NiNi&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hasMac: true</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">])</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 尋找對應路徑後修改資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">firebase.database().ref(&#39;firstArray&#x2F;0&#x2F;hasMac&#39;).set(false)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 陣列中的第一組變數 hasMac 即會修改為 false</span></pre></td></tr></table></figure>
<h3 id="顯示資料至頁面"><a href="#顯示資料至頁面" class="headerlink" title="顯示資料至頁面"></a>顯示資料至頁面</h3><p><code>once()</code> =&gt; 讀取一次資料庫的資料<br>snapshot =&gt; 意指快照，其中 <code>snapshot.val()</code> 是 Firebase 的讀取語法，snapshot 本身是變數命名，可用其他名稱取代。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firebase.database().ref(&#39;userName&#39;).set(&#39;PittWu&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">let userName &#x3D; firebase.database().ref(&#39;userName&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">userName.once(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let item &#x3D; snapshot.val()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(item)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  document.getElementById(&#39;title&#39;).textContent &#x3D; item</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h3 id="隨時監聽資料"><a href="#隨時監聽資料" class="headerlink" title="隨時監聽資料"></a>隨時監聽資料</h3><p><code>on()</code> =&gt; 監聽</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用 on 語法時，當資料變更時，頁面也隨之渲染變化</span></pre></td></tr><tr><td class="code"><pre><span class="line">firebase.database().ref(&#39;userName&#39;).set(&#39;Pitt&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">let userName &#x3D; firebase.database().ref(&#39;userName&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">userName.on(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let item &#x3D; snapshot.val()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  document.getElementById(&#39;title&#39;).textContent &#x3D; item</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h2 id="Firebase-非同步"><a href="#Firebase-非同步" class="headerlink" title="Firebase 非同步"></a>Firebase 非同步</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firebase.database().ref(&#39;userName&#39;).set(&#39;Pitt&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">let userName &#x3D; firebase.database().ref(&#39;userName&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">userName.on(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let item &#x3D; snapshot.val()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  console.log(&#39;test1&#39;, item)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  document.getElementById(&#39;title&#39;).textContent &#x3D; item</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(&#39;test2&#39;)</span></pre></td></tr></table></figure>
<p>在前述程式碼中，正常資料庫回傳應該會需要等待時間，所以應該是先執行 <code>test2</code>，但在本地測試時，可能資料量太小，導致即使使用 Slow 3G，<code>test1</code> 依然先跑完，後續資料多的時候要再觀察非同步狀況。 </p>
<h2 id="新增資料"><a href="#新增資料" class="headerlink" title="新增資料"></a>新增資料</h2><p>透過 push 語法，添加資料至 Firebase，同時因為資料庫本身有協助建立 key 值，不需擔心資料衝突的問題。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const todoList &#x3D; firebase.database().ref(&#39;todoList&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">todoList.push(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  content: &#39;shopping&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 會拿到如下格式的資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">-M00rdx2RilLDFK9lmSg &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  content: &quot;shopping&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="刪除資料"><a href="#刪除資料" class="headerlink" title="刪除資料"></a>刪除資料</h2><p>child =&gt; 子路徑<br>可以透過 <code>ref()</code> 找到根目錄，也可以透過 <code>child()</code> 找到子目錄，下面兩種做法功能相同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let todoList &#x3D; firebase.database().ref(&#39;todoList&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">let todoList2 &#x3D; firebase.database().ref().child(&#39;todoList&#39;)</span></pre></td></tr></table></figure>
<p>remove =&gt; 刪除資料<br>最笨的刪除方法，直接根據 key 值進行刪除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">todoList.child(&#39;-M00rdx2RilLDFK9lmSg&#39;).remove()</span></pre></td></tr></table></figure>
<h2 id="網頁即時查看-Firebase-資料變動"><a href="#網頁即時查看-Firebase-資料變動" class="headerlink" title="網頁即時查看 Firebase 資料變動"></a>網頁即時查看 Firebase 資料變動</h2><p>先透過 <code>on()</code> 語法監聽資料庫，將快照取得的資料渲染到頁面，同時為了方便查看，再使用 <code>JSON.stringify</code> 格式化，<code>null, 2</code>則是縮排便於查看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const allData &#x3D; firebase.database().ref()</span></pre></td></tr><tr><td class="code"><pre><span class="line">allData.on(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let path &#x3D; document.getElementById(&#39;content&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  path.textContent &#x3D; JSON.stringify(snapshot.val(), null, 2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>透過 <code>orderByChild()</code> 選擇資料中排序的基準屬性，再透過 <code>forEach()</code> 依序撈出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firebase.database().ref(&#39;practice&#39;).set(people)</span></pre></td></tr><tr><td class="code"><pre><span class="line">let peopleRef &#x3D; firebase.database().ref(&#39;practice&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 先取得路徑 &#x3D;&gt; 是否需要排序(&#39;屬性&#39;) &#x3D;&gt; 讀取資料 &#x3D;&gt; 使用 forEach 依序撈出</span></pre></td></tr><tr><td class="code"><pre><span class="line">peopleRef.orderByChild(&#39;height&#39;).once(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  snapshot.forEach((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(node.val())</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h3 id="排序規則"><a href="#排序規則" class="headerlink" title="排序規則"></a>排序規則</h3><p>Firebase 的 <code>orderByChild()</code> 排序規則，需參考<a href="https://firebase.google.com/docs/database/admin/retrieve-data?hl=zh-cn#orderbychild" target="_blank" rel="noopener">官網文件</a></p>
<h2 id="搜尋區間"><a href="#搜尋區間" class="headerlink" title="搜尋區間"></a>搜尋區間</h2><p><code>startAt()</code> =&gt; 多少以上<br><code>endAt()</code> =&gt; 多少以下<br><code>equalTo()</code> =&gt; 等於</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e.g. 體重3000以上</span></pre></td></tr><tr><td class="code"><pre><span class="line">peopleRef.orderByChild(&#39;weight&#39;).startAt(3000).once(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  snapshot.forEach((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(node.val())</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 也可以透過 startAt() 和 endAt() 交叉運用來設定範圍</span></pre></td></tr><tr><td class="code"><pre><span class="line">peopleRef.orderByChild(&#39;weight&#39;).startAt(3000).endAt(5000).once(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  snapshot.forEach((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(node.val())</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 相等於</span></pre></td></tr><tr><td class="code"><pre><span class="line">peopleRef.orderByChild(&#39;weight&#39;).equalTo(3000).once(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  snapshot.forEach((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(node.val())</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h2 id="限制筆數"><a href="#限制筆數" class="headerlink" title="限制筆數"></a>限制筆數</h2><p><code>limitToFirst()</code> =&gt; 撈取從第一筆資料開始的資料，()內的條件設定預撈取的比數<br><code>limitToLast()</code> =&gt; 反之，從最後一筆開始撈資料</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">peopleRef.orderByChild(&#39;weight&#39;).startAt(2000).limitToLast(2).once(&#39;value&#39;, (snapshot) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  snapshot.forEach((node) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(node.val())</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h2 id="時間"><a href="#時間" class="headerlink" title="時間"></a>時間</h2><p>先透過 <code>JS</code> 原生語法檢查時間：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let time &#x3D; new Date()</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time.getFullYear())</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在 JS 中，0 &#x3D; 1月</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time.getMonth())</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 週日(禮拜7) &#x3D; 0、週一(禮拜一) &#x3D; 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time.getDay())</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time.getHours())</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time.getMinutes())</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time.getSeconds())</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1000毫秒 &#x3D; 1秒</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(time.getMilliseconds())</span></pre></td></tr></table></figure>
<h3 id="UNIX-時間"><a href="#UNIX-時間" class="headerlink" title="UNIX 時間"></a>UNIX 時間</h3><p>從協調世界時1970年1月1日0時0分0秒起算至今</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let time &#x3D; new Date()</span></pre></td></tr><tr><td class="code"><pre><span class="line">time.getTime()  &#x2F;&#x2F; 拿到總秒數</span></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Firebase</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli 初始化專案操作記錄</title>
    <url>/2020/02/12/vue-init-step/</url>
    <content><![CDATA[<p>前端框架版本迭代太快，更新過程中安裝的版本又容易出現錯誤，單靠記憶不可行，只好記錄自己的操作步驟，隨時更新方便檢查。</p>
<a id="more"></a>
<h2 id="全域環境調整-vue-cli-4-0-以上版本"><a href="#全域環境調整-vue-cli-4-0-以上版本" class="headerlink" title="全域環境調整(vue-cli 4.0 以上版本)"></a>全域環境調整(vue-cli 4.0 以上版本)</h2><h3 id="remove-old-version"><a href="#remove-old-version" class="headerlink" title="remove old version"></a>remove old version</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall vue-cli -g</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># or</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn global remove vue-cli</span></pre></td></tr></table></figure>
<h3 id="install-new-version"><a href="#install-new-version" class="headerlink" title="install new version"></a>install new version</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g @vue&#x2F;cli</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># or</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn global add @vue&#x2F;cli</span></pre></td></tr></table></figure>
<h3 id="check-version"><a href="#check-version" class="headerlink" title="check version"></a>check version</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue --version</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># or</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">vue -V</span></pre></td></tr></table></figure>
<h2 id="fixed-yarn"><a href="#fixed-yarn" class="headerlink" title="fixed yarn"></a>fixed yarn</h2><h3 id="clean-yarn-cache"><a href="#clean-yarn-cache" class="headerlink" title="clean yarn cache"></a>clean yarn cache</h3><p>yarn 更新至 v1.19.0 後，一度在終端機一直跳提醒，google 到的解法是清除 cache。<br>但目前已是 v1.22.0 已無目前問題。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn update v1.19.0 後，需清除一次 cache，指令如下：</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn cache clean</span></pre></td></tr></table></figure>
<h2 id="build-project"><a href="#build-project" class="headerlink" title="build project"></a>build project</h2><h3 id="version-not-match-error"><a href="#version-not-match-error" class="headerlink" title="version not match error"></a>version not match error</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">若出現vue的版本為 2.6.9，但套件採用 2.6.10 的 error</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">需升級vue的版本，指令如下：</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn global add vue@2.6.11</span></pre></td></tr></table></figure>
<h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue create project-name</span></pre></td></tr></table></figure>
<h3 id="選擇需要的項目"><a href="#選擇需要的項目" class="headerlink" title="選擇需要的項目"></a>選擇需要的項目</h3><p>官方預設提供的 css 預處理器，存在一些配置上的錯誤，這邊不做使用<br>僅選擇 Router &amp; Vuex(單元測試和 PWA 尚未掌握)<br>Router 採用 History Mode</p>
<h3 id="進入項目並啟動"><a href="#進入項目並啟動" class="headerlink" title="進入項目並啟動"></a>進入項目並啟動</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd project</span></pre></td></tr><tr><td class="code"><pre><span class="line">yarn server</span></pre></td></tr></table></figure>
<h2 id="install-Plugins"><a href="#install-Plugins" class="headerlink" title="install Plugins"></a>install Plugins</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">axios</span></pre></td></tr><tr><td class="code"><pre><span class="line">vue-axios</span></pre></td></tr></table></figure>
<p>–dev</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue-cli-plugin-pug</span></pre></td></tr><tr><td class="code"><pre><span class="line">sass</span></pre></td></tr><tr><td class="code"><pre><span class="line">sass-loader</span></pre></td></tr></table></figure>
<h2 id="專案結構"><a href="#專案結構" class="headerlink" title="專案結構"></a>專案結構</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assets</span></pre></td></tr><tr><td class="code"><pre><span class="line">components</span></pre></td></tr><tr><td class="code"><pre><span class="line">pages</span></pre></td></tr></table></figure>
<h3 id="router"><a href="#router" class="headerlink" title="router"></a>router</h3><p>拆分為 index.js 和 map.js<br>當頁面數過多時，將 routes 抽離至 map.js，再載入到 index.js</p>
<h3 id="webpack-設定"><a href="#webpack-設定" class="headerlink" title="webpack 設定"></a>webpack 設定</h3><p>建立 vue.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">function resolve (dir) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return path.join(__dirname, dir)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  publicPath: &#39;&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; 調整本地端口</span></pre></td></tr><tr><td class="code"><pre><span class="line">  devServer: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    host: &#39;localhost&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    port: 8081,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 設置代理 &#x3D;&gt; 解決跨域問題(調用後端API接口時通常不是同一個域名)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    proxy: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#39;&#x2F;api&#39;: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        target: &#39;http:&#x2F;&#x2F;localhost:8081&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; websocket 縮寫 &#x3D;&gt; ws</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ws: false,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 避免在訪問網址時，自動將原點移除</span></pre></td></tr><tr><td class="code"><pre><span class="line">        changeOrigin: false</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  chainWebpack: (config) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    config.resolve.alias</span></pre></td></tr><tr><td class="code"><pre><span class="line">      .set(&#39;@&#39;, resolve(&#39;src&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6：解構賦值</title>
    <url>/2020/02/09/es6-destructuring/</url>
    <content><![CDATA[<p>解構賦值簡單來說，就是輕便且快速地取出元素。</p>
<a id="more"></a>
<h2 id="陣列解構"><a href="#陣列解構" class="headerlink" title="陣列解構"></a>陣列解構</h2><p>若有一個陣列如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numArray &#x3D; [2, 4, 6]</span></pre></td></tr></table></figure>
<p>可以透過下面兩種方法進行解構</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法一</span></pre></td></tr><tr><td class="code"><pre><span class="line">let [subNode, subItem] &#x3D; numArray</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法二</span></pre></td></tr><tr><td class="code"><pre><span class="line">let subNode</span></pre></td></tr><tr><td class="code"><pre><span class="line">let subItem</span></pre></td></tr><tr><td class="code"><pre><span class="line">[subNode, subItem] &#x3D; numArray</span></pre></td></tr></table></figure>
<p>這兩種方法，都會拿到相同結果。當陣列解構後，就可以進行一般運算或處理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let res &#x3D; subNode * subItem</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(res)  &#x2F;&#x2F; 印出8</span></pre></td></tr></table></figure>
<h2 id="預設值"><a href="#預設值" class="headerlink" title="預設值"></a>預設值</h2><p>如果無法預期拿到陣列內容為何？透過預設值，可以避免缺少值的問題。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numArray &#x3D; [2, 4]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">let [first, second, third] &#x3D; numArray</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">first + second + third  &#x2F;&#x2F; 這邊做計算的話，會產生 NaN</span></pre></td></tr></table></figure>
<p>但如果透過預設值為0，則能避免上面的問題</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let [first, second, third &#x3D; 0] &#x3D; numArray</span></pre></td></tr></table></figure>
<h2 id="忽略元素"><a href="#忽略元素" class="headerlink" title="忽略元素"></a>忽略元素</h2><p>意指，僅調用陣列中某一元素。可以透過前面的值為空，但逗號保留的方式來進行忽略元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numArray &#x3D; [2, 4, 8, 10]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">let [, , , item] &#x3D; numArray</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(item)</span></pre></td></tr></table></figure>
<h2 id="變數交換"><a href="#變數交換" class="headerlink" title="變數交換"></a>變數交換</h2><p>透過陣列的形式，進行陣列解構的變數交換</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; 2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">let b &#x3D; 4;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[a, b] &#x3D; [b, a]</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(a) &#x2F;&#x2F; 印出 4</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(b) &#x2F;&#x2F; 印出 2</span></pre></td></tr></table></figure>
<h2 id="剩餘部分重組"><a href="#剩餘部分重組" class="headerlink" title="剩餘部分重組"></a>剩餘部分重組</h2><p>去除原始陣列中部分元素，透過 <code>...</code> 的方式，將剩餘的元素重組成新陣列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numArray &#x3D; [1, 3, 5, 7, 9]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">let [first, ...node] &#x3D; numArray</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(node) &#x2F;&#x2F; 印出 [3, 5, 7, 9]</span></pre></td></tr></table></figure>
<h2 id="物件解構"><a href="#物件解構" class="headerlink" title="物件解構"></a>物件解構</h2><p>類似陣列解構，將變數快速賦值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let itemObj &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  a: 10,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  b: 20</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">let &#123;a, b&#125; &#x3D; itemObj</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(a) &#x2F;&#x2F; 印出 10</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(b) &#x2F;&#x2F; 印出 20</span></pre></td></tr></table></figure>
<p>物件解構，同樣可以給予預設值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123;a, b, c &#x3D; 0&#125; &#x3D; itemObj</span></pre></td></tr></table></figure>
<p>改變變數名稱，解構時，冒號左側的 <code>key</code> 值必須維持和物件中相同，但右側可以命名新的變數。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let itemObj &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  a: 10,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  b: 35</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">let &#123;a:x, b:y&#125; &#x3D; itemObj</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(y) &#x2F;&#x2F; 印出 35</span></pre></td></tr></table></figure>
<h2 id="解構函式"><a href="#解構函式" class="headerlink" title="解構函式"></a>解構函式</h2><p>透過解構傳進來的參數，精簡程式碼</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function distance(point) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  let &#123;x, y&#125; &#x3D; point</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return Math.sqrt(x*x + y*y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>但是解構函式，更進階的用法是，在參數內直接解構</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function distance(&#123;x, y&#125;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return Math.sqrt(x*x + y*y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>因此既能給予預設值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function distance(&#123;x &#x3D; 0, y&#125;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return Math.sqrt(x*x + y*y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>也能重新命名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function distance(&#123;x:a, y&#125;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return Math.sqrt(a*a + y*y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6：筆記整理</title>
    <url>/2020/02/09/es6-note/</url>
    <content><![CDATA[<p>整理散落各方的<code>ES6</code>筆記，方便自己日後查詢。</p>
<a id="more"></a>
<h2 id="變數宣告"><a href="#變數宣告" class="headerlink" title="變數宣告"></a>變數宣告</h2><p>傳統變數宣告採用 <code>var</code> 的方式，但容易存在污染環境的問題。因此在 ES6 的語法中，新增兩個變數宣告方式 <code>let、const</code>。</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>使用 const 定義常數，意味著這個變數不作變動，且要求一定要賦值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a &#x3D; 1</span></pre></td></tr></table></figure>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>和傳統的<code>var</code>相似，側重解決過往的 scope(執行環境)問題。使用<code>let</code>宣告變數時，僅會作用在當前區域，且可以選擇賦值或不賦值，通常以 function 本身為分界。</p>
<ul>
<li>var<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (true) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    var b &#x3D; 10</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(b) &#x2F;&#x2F; 印出 10</span></pre></td></tr></table></figure></li>
<li>let<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (true) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    let c &#x3D; 20</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(c) &#x2F;&#x2F; error，c is not defined</span></pre></td></tr></table></figure>
<h2 id="樣板字面值-模板字符串-Template-literals"><a href="#樣板字面值-模板字符串-Template-literals" class="headerlink" title="樣板字面值(模板字符串) Template literals"></a>樣板字面值(模板字符串) Template literals</h2>過往<code>ES5</code>寫法如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(&quot;My name is &quot; + name)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 印出 My name is Pitt</span></pre></td></tr></table></figure>
修改為<code>ES6</code>時，則需調整寫法如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let name &#x3D; &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(&#96;My name is $&#123;name&#125;&#96;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 同樣印出 My name is Pitt</span></pre></td></tr></table></figure>
最外圍使用倒鉤符號包裹，先用$符號聲明，再用{}包覆變數。<h3 id="多行字串"><a href="#多行字串" class="headerlink" title="多行字串"></a>多行字串</h3><code>ES5</code>寫法中，多行字串使用<code>\n</code>，但在<code>ES6</code>中，若使用倒鉤符號包裹後，自動換行即可，寫法如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let msg &#x3D;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#96;&lt;span&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Hello World!</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;span&gt;&#96;</span></pre></td></tr></table></figure>
<h2 id="展開與其餘運算符"><a href="#展開與其餘運算符" class="headerlink" title="展開與其餘運算符"></a>展開與其餘運算符</h2>用法為<code>...</code>，常用於陣列合併或是複製陣列。<br>合併用法如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; [1, 2, 3]</span></pre></td></tr><tr><td class="code"><pre><span class="line">let b &#x3D; [4, 5, 6]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">let c &#x3D; [...a, ...b]</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(c)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 印出 [1, 2, 3, 4, 5, 6]</span></pre></td></tr></table></figure>
複製陣列後修改其中的值：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let d &#x3D; [...c]</span></pre></td></tr><tr><td class="code"><pre><span class="line">d[2] &#x3D; 7</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(d)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 印出 [1, 2, 7, 4, 5, 6]，而此時的c陣列是不受影響的</span></pre></td></tr></table></figure>
<h2 id="import-module"><a href="#import-module" class="headerlink" title="import module"></a>import module</h2>在<code>ES6</code>語法中，JS開始原生支援模組系統，用法如下：<br>先建立一個引用的<code>HTML</code>檔案，同時引用js檔案時，需注意<code>type = module</code>，寫法如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;.&#x2F;index.js&quot; type&#x3D;&quot;module&quot;&gt;&lt;&#x2F;script&gt;</span></pre></td></tr></table></figure>
準備一個<code>index.js</code>檔案來載入導出的資料，再準備一個<code>module.js</code>來導出資料<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; index.js</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import &#123; data, userData &#125; from &#39;.&#x2F;module.js&#39;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(data)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(userData)</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; module.js</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">export const data &#x3D; [1, 2, 3]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">export const userData &#x3D; [&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#39;id&#39;: &#39;first&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#39;name&#39;: &#39;Pitt&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;]</span></pre></td></tr></table></figure>
如此便完成最基礎的<code>import</code>和<code>export</code>。</li>
</ul>
]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Node 基礎知識</title>
    <url>/2020/01/27/node-basic-knowledge/</url>
    <content><![CDATA[<p>記錄自己學習<code>node.js</code>基礎API用法。</p>
<a id="more"></a>
<h2 id="require、module-exports"><a href="#require、module-exports" class="headerlink" title="require、module exports"></a>require、module exports</h2><p><code>require</code>語法可以載入檔案，反之<code>module.exports</code>則能導出內容。寫法如下：<br>app.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let content &#x3D; require(&#39;.&#x2F;app2&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(content)</span></pre></td></tr></table></figure>
<p>app2.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let data &#x3D; &#39;node-test&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">module.exports &#x3D; data</span></pre></td></tr></table></figure>
<p>印出<code>&#39;node-test&#39;</code>字串。</p>
<p>除此之外也能放入物件格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  title: data,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  subTitle: &#39;title-test&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>印出對應的物件。</p>
<h3 id="相對冷門寫法"><a href="#相對冷門寫法" class="headerlink" title="相對冷門寫法"></a>相對冷門寫法</h3><p>一般導出寫法多採用<code>module.exports</code>，但單純使用<code>exports</code>也能導出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exports.subContent &#x3D; 123</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 這個寫法等於建立一個物件，如下：</span></pre></td></tr><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    subContent: 123</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;除了物件外，也能調用函數</span></pre></td></tr><tr><td class="code"><pre><span class="line">exports.call &#x3D; (() &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return &#39;call!&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<h2 id="http-API"><a href="#http-API" class="headerlink" title="http API"></a>http API</h2><h3 id="createServer"><a href="#createServer" class="headerlink" title="createServer"></a>createServer</h3><p>Node 原生 http API 用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const http &#x3D; require(&#39;http&#39;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; request 使用者發出請求，常縮寫為 req</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; response 回傳結果，常縮寫為 res</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">http.createServer((req, res) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; 表頭內容</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text&#x2F;plain&quot; &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; 回傳結果內容</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.write(&#39;Hello Node!&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; 結束</span></pre></td></tr><tr><td class="code"><pre><span class="line">  res.end()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;).listen(8081) &#x2F;&#x2F; 監聽 port</span></pre></td></tr></table></figure>
<h2 id="查詢路徑或檔案名稱"><a href="#查詢路徑或檔案名稱" class="headerlink" title="查詢路徑或檔案名稱"></a>查詢路徑或檔案名稱</h2><p><code>__dirname</code>語法，可以查詢到當前檔案所在的路徑。<br><code>__filename</code>語法，則能檢查當前檔案名稱。</p>
<h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>Node 原生 path API 用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 抓目錄路徑，回傳 &#x2F;Path&#x2F;subNode</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(path.dirname(&#39;&#x2F;Path&#x2F;subNode&#x2F;index.js&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 路徑合併</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(path.join(__dirname, &#39;&#x2F;Path&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 抓取檔案名稱，回傳 index.js</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(path.basename(&#39;&#x2F;Path&#x2F;subNode&#x2F;index.js&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 抓副檔名，回傳 .js</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(path.extname(&#39;&#x2F;Path&#x2F;subNode&#x2F;index.js&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 分析路徑</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(path.parse(&#39;&#x2F;Path&#x2F;subNode&#x2F;index.js&#39;))</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>NVM 常用指令</title>
    <url>/2019/12/09/nvm-instruction/</url>
    <content><![CDATA[<p>記錄常用 NVM 指令。</p>
<a id="more"></a>
<h4 id="查詢遠端可安裝的-node-版本"><a href="#查詢遠端可安裝的-node-版本" class="headerlink" title="查詢遠端可安裝的 node 版本"></a>查詢遠端可安裝的 node 版本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm ls-remote</span></pre></td></tr></table></figure>
<h4 id="安裝所需的版本號"><a href="#安裝所需的版本號" class="headerlink" title="安裝所需的版本號"></a>安裝所需的版本號</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm install v12.14.1</span></pre></td></tr></table></figure>
<h4 id="切換所需使用的-node-版本"><a href="#切換所需使用的-node-版本" class="headerlink" title="切換所需使用的 node 版本"></a>切換所需使用的 node 版本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm use v12.14.1</span></pre></td></tr></table></figure>
<h4 id="設定預設使用的-node-版本"><a href="#設定預設使用的-node-版本" class="headerlink" title="設定預設使用的 node 版本"></a>設定預設使用的 node 版本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm alias default v12.14.1</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>NVM</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6：類別與物件的基本觀念</title>
    <url>/2019/12/02/es6-object/</url>
    <content><![CDATA[<p>關於類別與物件的基本觀念。</p>
<a id="more"></a>
<h2 id="什麼是類別與物件"><a href="#什麼是類別與物件" class="headerlink" title="什麼是類別與物件"></a>什麼是類別與物件</h2><h3 id="舉例來說"><a href="#舉例來說" class="headerlink" title="舉例來說"></a>舉例來說</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">類別，可以理解為設計圖</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">物件，則是根據設計圖製造出來的實體</span></pre></td></tr></table></figure>
<h4 id="馬克杯"><a href="#馬克杯" class="headerlink" title="馬克杯"></a>馬克杯</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我們可以請設計師，繪出一個馬克杯的設計稿</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">接著，工廠可以根據設計圖，製造出無數的馬克杯</span></pre></td></tr></table></figure>
<h4 id="回到程式語言"><a href="#回到程式語言" class="headerlink" title="回到程式語言"></a>回到程式語言</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我們可以使用一個類別設計，產生無數個物件實體</span></pre></td></tr></table></figure>
<h4 id="關鍵字"><a href="#關鍵字" class="headerlink" title="關鍵字"></a>關鍵字</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在類別中，我們會使用到一些關鍵字</span></pre></td></tr><tr><td class="code"><pre><span class="line">class、constructor</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在物件中，則會使用到</span></pre></td></tr><tr><td class="code"><pre><span class="line">new</span></pre></td></tr></table></figure>
<h2 id="定義類別並產生物件"><a href="#定義類別並產生物件" class="headerlink" title="定義類別並產生物件"></a>定義類別並產生物件</h2><h3 id="寫法"><a href="#寫法" class="headerlink" title="寫法"></a>寫法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Car &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 利用已經定義好的類別，產生新的物件</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 再將 new Car() 產生的新物件，放入變數中</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car();</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car2 &#x3D; new Car();</span></pre></td></tr></table></figure>
<h3 id="定義建構式-constructor"><a href="#定義建構式-constructor" class="headerlink" title="定義建構式 (constructor)"></a>定義建構式 (constructor)</h3><ul>
<li>建構式：建立新物件時被呼叫的函式<h4 id="寫法-1"><a href="#寫法-1" class="headerlink" title="寫法"></a>寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Car &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 在類別中，定義建構式</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructor() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        console.log(&quot;呼叫建構式&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 利用已經定義好的類別，產生新的物件</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car();</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car2 &#x3D; new Car();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 上述流程</span></pre></td></tr><tr><td class="code"><pre><span class="line">定義類別 -&gt; 先呼叫建構式 -&gt; 執行完建構式內容 -&gt; 產生新物件 -&gt; 放入變數</span></pre></td></tr></table></figure>
<h3 id="定義與存取屬性-Attribute"><a href="#定義與存取屬性-Attribute" class="headerlink" title="定義與存取屬性 (Attribute)"></a>定義與存取屬性 (Attribute)</h3><h4 id="在建構式中建立屬性"><a href="#在建構式中建立屬性" class="headerlink" title="在建構式中建立屬性"></a>在建構式中建立屬性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor (參數) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    this.屬性名稱 &#x3D; 初始資料;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="寫法-2"><a href="#寫法-2" class="headerlink" title="寫法"></a>寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Car &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 在類別中，定義建構式</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructor() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.color &#x3D; &quot;blue&quot;; &#x2F;&#x2F; 建立新屬性 color，指定資料為&quot;blue&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 利用已經定義好的類別，產生新的物件</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car(); &#x2F;&#x2F; 新物件擁有 color 屬性，資料為&quot;blue&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car2 &#x3D; new Car(); &#x2F;&#x2F; 新物件擁有 color 屬性，資料為&quot;blue&quot;</span></pre></td></tr></table></figure>
<h4 id="透過參數，彈性建立新屬性，達到多個物件的差異"><a href="#透過參數，彈性建立新屬性，達到多個物件的差異" class="headerlink" title="透過參數，彈性建立新屬性，達到多個物件的差異"></a>透過參數，彈性建立新屬性，達到多個物件的差異</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Car &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 在類別中，定義建構式</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructor(color) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 透過新物件的參數，使屬性在賦值同時產生變化</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.color &#x3D; color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 利用已經定義好的類別，產生新的物件</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car(&quot;blue&quot;); &#x2F;&#x2F; 新物件擁有 color 屬性，資料為&quot;blue&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car2 &#x3D; new Car(&quot;red&quot;); &#x2F;&#x2F; 新物件擁有 color 屬性，資料為&quot;red&quot;</span></pre></td></tr></table></figure>
<h4 id="同一物件，更新屬性"><a href="#同一物件，更新屬性" class="headerlink" title="同一物件，更新屬性"></a>同一物件，更新屬性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Car &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 在類別中，定義建構式</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructor(color) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 透過新物件的參數，使屬性在賦值同時產生變化</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.color &#x3D; color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 利用已經定義好的類別，產生新的物件</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car(&quot;blue&quot;); &#x2F;&#x2F; 新物件擁有 color 屬性，資料為&quot;blue&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(car1.color); &#x2F;&#x2F; 取得屬性的資料，印出 blue</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">car1.color &#x3D; &quot;red&quot; &#x2F;&#x2F; 更新屬性資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(car1.color) &#x2F;&#x2F; 取得新的屬性資料，印出 red</span></pre></td></tr></table></figure>
<h3 id="定義、呼叫方法-Method"><a href="#定義、呼叫方法-Method" class="headerlink" title="定義、呼叫方法 (Method)"></a>定義、呼叫方法 (Method)</h3><h4 id="寫法-3"><a href="#寫法-3" class="headerlink" title="寫法"></a>寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Car &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 在類別中，定義建構式</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructor(color) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 透過新物件的參數，使屬性在賦值同時產生變化</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.color &#x3D; color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 定義一個 Run 方法，透過物件呼叫，並執行內部程式碼</span></pre></td></tr><tr><td class="code"><pre><span class="line">    run() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        console.log(&quot;Running&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 產生新物件，並且物件同時擁有 color 屬性和 run 方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car(&quot;blue&quot;);</span></pre></td></tr></table></figure>
<h4 id="call-method"><a href="#call-method" class="headerlink" title="call method"></a>call method</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Car &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 在類別中，定義建構式</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructor(color) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 透過新物件的參數，使屬性在賦值同時產生變化</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.color &#x3D; color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 定義一個 Run 方法，透過物件呼叫，並執行內部程式碼</span></pre></td></tr><tr><td class="code"><pre><span class="line">    run() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        console.log(&quot;Running&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car(&quot;blue&quot;); &#x2F;&#x2F; 產生新物件，並且物件同時擁有 color 屬性和 run 方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">car1.run(); &#x2F;&#x2F; call run method，並執行 run 內部的 code，印出 &quot;Running&quot;</span></pre></td></tr></table></figure>
<h4 id="綜合應用"><a href="#綜合應用" class="headerlink" title="綜合應用"></a>綜合應用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Car &#123; &#x2F;&#x2F; 定義一個類別 Car</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructor(color) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.color &#x3D; color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.speed &#x3D; 0; &#x2F;&#x2F; 初始化車子速度為 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    run(val) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.speed &#x3D; val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        console.log(this.color + &quot;Car Running at&quot; + this.speed + &quot;km&#x2F;hr&quot; );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    stop() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.speed &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        console.log(this.color + &quot;Car is stopped&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 產生一個新物件，擁有 color、speed 屬性和 run、stop 方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">let car1 &#x3D; new Car(&quot;red&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">car1.run(80);</span></pre></td></tr><tr><td class="code"><pre><span class="line">car1.stop();</span></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6：宣告變數與箭頭函數</title>
    <url>/2019/12/02/es6-const-arrow/</url>
    <content><![CDATA[<p>記錄自己學習 ES6 語法，對比 ES5 和 ES3 如何解決問題。</p>
<a id="more"></a>
<h2 id="var、let、const"><a href="#var、let、const" class="headerlink" title="var、let、const"></a>var、let、const</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">早期 javascript 只能用 var 宣告變數</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">在 ES6 版本後，添加 let、const 兩種方式</span></pre></td></tr></table></figure>
<h3 id="let、const"><a href="#let、const" class="headerlink" title="let、const"></a>let、const</h3><h4 id="let-用於宣告變數，可以選擇賦值或不賦值"><a href="#let-用於宣告變數，可以選擇賦值或不賦值" class="headerlink" title="let 用於宣告變數，可以選擇賦值或不賦值"></a>let 用於宣告變數，可以選擇賦值或不賦值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 賦值</span></pre></td></tr><tr><td class="code"><pre><span class="line">let a &#x3D; 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 不賦值</span></pre></td></tr><tr><td class="code"><pre><span class="line">let b;</span></pre></td></tr></table></figure>
<h4 id="const-用於宣告常數-不作變動-，一定要賦值"><a href="#const-用於宣告常數-不作變動-，一定要賦值" class="headerlink" title="const 用於宣告常數(不作變動)，一定要賦值"></a>const 用於宣告常數(不作變動)，一定要賦值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const c &#x3D; 10;</span></pre></td></tr></table></figure>
<h3 id="理解與應用"><a href="#理解與應用" class="headerlink" title="理解與應用"></a>理解與應用</h3><h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><p>傳統使用 var 宣告變數時，變數的 Scope(即影響範圍)，通常以 function 本身為分界</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (var i&#x3D;0;i&lt;3;i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	console.log(&quot;i:&quot;+i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(&quot;outside i:&quot;+i);</span></pre></td></tr></table></figure>
<h4 id="let-使用更嚴格的-Scope"><a href="#let-使用更嚴格的-Scope" class="headerlink" title="let (使用更嚴格的 Scope)"></a>let (使用更嚴格的 Scope)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (let i&#x3D;0;i&lt;3;i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	console.log(&quot;i:&quot;+i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(&quot;outside i:&quot;+i); &#x2F;&#x2F; error，i is not defined</span></pre></td></tr></table></figure>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a; &#x2F;&#x2F; 宣告變數，可以暫時不給資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">a &#x3D; 2; &#x2F;&#x2F; 變數中的資料可以變動</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">const b; &#x2F;&#x2F; error，常數宣告時，必須給定資料</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">const b &#x3D; 10; &#x2F;&#x2F; 正確，宣告常數同時給予資料</span></pre></td></tr><tr><td class="code"><pre><span class="line">b &#x3D; 20; &#x2F;&#x2F; error，不能更動常數中的資料</span></pre></td></tr></table></figure>
<h3 id="比對-ES5-和-ES6-寫法"><a href="#比對-ES5-和-ES6-寫法" class="headerlink" title="比對 ES5 和 ES6 寫法"></a>比對 ES5 和 ES6 寫法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ES5</span></pre></td></tr><tr><td class="code"><pre><span class="line">Object.defineProperty(window, &quot;a&quot;, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    value: 1,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    writable: false,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(window.a)</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ES6</span></pre></td></tr><tr><td class="code"><pre><span class="line">const a &#x3D; 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(a)</span></pre></td></tr></table></figure>
<p>除了精簡程式碼，也讓寫法變得更輕鬆。</p>
<h2 id="Arrow-Function-箭頭函數"><a href="#Arrow-Function-箭頭函數" class="headerlink" title="Arrow Function (箭頭函數)"></a>Arrow Function (箭頭函數)</h2><h3 id="第一種：-參數列表-gt-回傳值"><a href="#第一種：-參數列表-gt-回傳值" class="headerlink" title="第一種：(參數列表) =&gt; (回傳值)"></a>第一種：(參數列表) =&gt; (回傳值)</h3><h4 id="傳統函數寫法"><a href="#傳統函數寫法" class="headerlink" title="傳統函數寫法"></a>傳統函數寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let add &#x3D; function (n1, n2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return n1+n2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h4 id="箭頭函數寫法"><a href="#箭頭函數寫法" class="headerlink" title="箭頭函數寫法"></a>箭頭函數寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let add &#x3D; (n1, n2) &#x3D;&gt; (n1+n2)</span></pre></td></tr></table></figure>
<h3 id="第二種：-參數列表-gt-函數內部程式"><a href="#第二種：-參數列表-gt-函數內部程式" class="headerlink" title="第二種：(參數列表) =&gt; {函數內部程式}"></a>第二種：(參數列表) =&gt; {函數內部程式}</h3><h4 id="傳統函數寫法-1"><a href="#傳統函數寫法-1" class="headerlink" title="傳統函數寫法"></a>傳統函數寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let add &#x3D; function (n1, n2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return n1+n2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h4 id="箭頭函數寫法-1"><a href="#箭頭函數寫法-1" class="headerlink" title="箭頭函數寫法"></a>箭頭函數寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let add &#x3D; (n1, n2) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return n1+n2</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h3 id="額外範例"><a href="#額外範例" class="headerlink" title="額外範例"></a>額外範例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let f &#x3D; () &#x3D;&gt; (5);</span></pre></td></tr><tr><td class="code"><pre><span class="line">let result &#x3D; f();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">console.log(result);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 印出 5</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let f &#x3D; (message) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">f(&quot;Hello, Pitt&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 印出 Hello, Pitt</span></pre></td></tr></table></figure>
<h3 id="匿名函數"><a href="#匿名函數" class="headerlink" title="匿名函數"></a>匿名函數</h3><h4 id="傳統寫法"><a href="#傳統寫法" class="headerlink" title="傳統寫法"></a>傳統寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(function()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(&quot;過了5秒&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;, 5000);</span></pre></td></tr></table></figure>
<h4 id="箭頭函數寫法-2"><a href="#箭頭函數寫法-2" class="headerlink" title="箭頭函數寫法"></a>箭頭函數寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(&quot;過了5秒&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;, 5000);</span></pre></td></tr></table></figure>
<h3 id="參數預設值"><a href="#參數預設值" class="headerlink" title="參數預設值"></a>參數預設值</h3><h4 id="傳統寫法-1"><a href="#傳統寫法-1" class="headerlink" title="傳統寫法"></a>傳統寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function show(message) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (typeof message &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        message &#x3D; &quot;default&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    alert(message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">show(&quot;Pitt&quot;); &#x2F;&#x2F; 顯示 Pitt</span></pre></td></tr><tr><td class="code"><pre><span class="line">show(); &#x2F;&#x2F; 顯示 default</span></pre></td></tr></table></figure>
<h4 id="箭頭函數寫法-3"><a href="#箭頭函數寫法-3" class="headerlink" title="箭頭函數寫法"></a>箭頭函數寫法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 若未給定參數資料，則直接採用等號後的賦值</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">function show(message&#x3D;&quot;default&quot;)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    alert(message);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">show(&quot;Hello&quot;); &#x2F;&#x2F; 顯示 Hello</span></pre></td></tr><tr><td class="code"><pre><span class="line">show(); &#x2F;&#x2F; 顯示 default</span></pre></td></tr></table></figure>
<h4 id="額外範例-1"><a href="#額外範例-1" class="headerlink" title="額外範例"></a>額外範例</h4><h5 id="範例一：傳統寫法"><a href="#範例一：傳統寫法" class="headerlink" title="範例一：傳統寫法"></a>範例一：傳統寫法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function multiply(n1, n2&#x3D;2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return n1 + n2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">multiply(2, 3); &#x2F;&#x2F; 回傳 6</span></pre></td></tr><tr><td class="code"><pre><span class="line">multiply(); &#x2F;&#x2F; 回傳 4</span></pre></td></tr></table></figure>
<h5 id="範例一：箭頭函數寫法"><a href="#範例一：箭頭函數寫法" class="headerlink" title="範例一：箭頭函數寫法"></a>範例一：箭頭函數寫法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let multiply&#x3D;(n1, n2&#x3D;2) &#x3D;&gt; (n1+n2);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">multiply(2, 3); &#x2F;&#x2F; 回傳 6</span></pre></td></tr><tr><td class="code"><pre><span class="line">multiply(); &#x2F;&#x2F; 回傳 4</span></pre></td></tr></table></figure>
<h5 id="範例二"><a href="#範例二" class="headerlink" title="範例二"></a>範例二</h5><p>後方的參數可以使用前方的參數進行運算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function combine(first&#x3D;&quot;Pitt&quot;, last&#x3D;&quot;Wu&quot;, name&#x3D;first+&quot; &quot;+last) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">combine(&quot;Nini&quot;, &quot;Ya&quot;); &#x2F;&#x2F; 顯示 Nini Ya</span></pre></td></tr><tr><td class="code"><pre><span class="line">combine(&quot;Nini&quot;); &#x2F;&#x2F; 顯示 Nini Wu</span></pre></td></tr><tr><td class="code"><pre><span class="line">combine(); &#x2F;&#x2F; 顯示 Pitt Wu</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub + Netlify = Auto Deploy Hexo Post</title>
    <url>/2019/12/01/hexo-auto-deploy/</url>
    <content><![CDATA[<p>回歸 Hexo 寫技術筆記後，就一直懷念 Gatsby.js 可以透過 Netlify 自動推送部署，花了點時間 Google，終於也找到 Hexo 的自動部署方式，一整個對寫文章非常方便。</p>
<a id="more"></a>
<ul>
<li>step 1：<br>  先在 GitHub 建立遠端 repository</li>
<li>step 2：<br>  copy repository 的 url</li>
<li>step 3：<br>  回到 project 內，將本地和遠端進行關聯  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;your-githubname&#x2F;your-repository</span></pre></td></tr></table></figure></li>
<li>step 4：<br>  進行 commit  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .&#x2F;</span></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &#39;commit information&#39;</span></pre></td></tr></table></figure></li>
<li>step 5：<br>  推送到遠端  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin master</span></pre></td></tr></table></figure></li>
<li>step 6：<br>  打開最上層的<code>_config.yml</code>，修改設定  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  type: git # 部署方式</span></pre></td></tr><tr><td class="code"><pre><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;wuzhe0912&#x2F;pittwu-blog.git # 關聯 github</span></pre></td></tr><tr><td class="code"><pre><span class="line">  branch: run-page # 部署用 branch</span></pre></td></tr></table></figure>
  安裝 Hexo 部署插件  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add hexo-deployer-git</span></pre></td></tr></table></figure></li>
<li>step 7：<br>  執行指令  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  &#x2F;&#x2F; 清除舊的靜態文件</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo g      &#x2F;&#x2F; 生成新的靜態文件</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo d      &#x2F;&#x2F; 部署</span></pre></td></tr></table></figure>
  這時候本地的 Hexo 資料已推送到遠端的 Github repository</li>
<li>step 8：<br>  接著在<a href="https://www.netlify.com/" target="_blank" rel="noopener">Netlify</a>建立帳號，因為我們要關聯 GitHub，所以選擇第三方登入(使用 GitHub 帳號)</li>
<li>step 9：<br>  登入後，選擇右側的 New site from Git，再來選關聯 GitHub，授權完成後，選擇對應的 repository</li>
<li>step 10：<br>  Branch 需選擇剛剛<code>_config.yml</code>輸入的 branch name，下方 command 和 Publish 兩欄則清空，最後點選 Deploy site</li>
<li>step 11：<br>  很快就能在左上角看到 Netlify 幫我們生成的網址，但其中網址名的部分是亂數生成的，可以點選 Change site name 修改。</li>
<li>step 12：<br>  日後只要本地寫完文章，執行下面三道指令，即可完成自動部署。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo g</span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo d</span></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Netlify</tag>
        <tag>auto deploy</tag>
      </tags>
  </entry>
  <entry>
    <title>Node &amp; NPM Version Path Fixed</title>
    <url>/2019/12/01/node-version-fixed/</url>
    <content><![CDATA[<p>近期公司 MIS 調整硬體設備，造成環境有點跑掉，記錄一下自己在 Stack Overflow 上找到的解法。</p>
<a id="more"></a>
<p>打開 iTerm 會出現下述 error。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm is not compatible with the npm config “prefix” option: currently set to “&#x2F;Users&#x2F;xxx&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v8.12.0&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Run &#96;npm config delete prefix&#96; or &#96;nvm use --delete-prefix v8.12.0 --silent&#96; to unset it.</span></pre></td></tr></table></figure>
<p>從字面上來看，應該是 npm 和 nvm 管理的 node 版本沒有對上，按照終端機提供的訊息，敲入對應指令。再檢查 node 版本似乎是正常了，但事實上，若在 iTerm 上另開分頁，依然會跳相同的提示錯誤。雖然不影響操作，但看到總是不順眼，google 了一下解法，最終測試成功方案如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config delete prefix</span></pre></td></tr><tr><td class="code"><pre><span class="line">npm config set prefix $NVM_DIR&#x2F;versions&#x2F;node&#x2F;v8.12.0</span></pre></td></tr></table></figure>
<p>看起來應該是先刪除 npm 中設定的 prefix ，再重新設定當前 nvm 使用的版本。</p>
<p>最後附上 <a href="https://stackoverflow.com/questions/34718528/nvm-is-not-compatible-with-the-npm-config-prefix-option" target="_blank" rel="noopener">stackoverflow</a> 找到的解法。</p>
]]></content>
      <tags>
        <tag>Node.js</tag>
        <tag>NPM</tag>
        <tag>NVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Command Error Fixed</title>
    <url>/2019/12/01/git-command-error-fixed/</url>
    <content><![CDATA[<p>Git 雖然是基本知識，但有時操作上，還是不免出現一些 Error，記錄當中的解法，方便日後快速排查問題。</p>
<a id="more"></a>
<h2 id="初始化錯誤"><a href="#初始化錯誤" class="headerlink" title="初始化錯誤"></a>初始化錯誤</h2><p>由於之前習慣性從遠端 clone 下來，所以<code>.git</code>檔案同時會被準備完成，但這次因為嘗試自動部署<code>Hexo</code>，在推送時跳出下面這個錯誤。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: Not a git repository (or any of the parent directories): .git</span></pre></td></tr></table></figure>
<p>這個錯誤是說明，要推送的檔案不是一個<code>git</code>的<code>repository</code>，所以<code>git</code>在這個目錄底下會找不到<code>.git</code>檔案。解決方式是，執行指令<code>git init</code>，這樣就等於初始化一個<code>git repo</code>。</p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Next Theme Error Fixed</title>
    <url>/2019/11/29/next-theme-error-fixed/</url>
    <content><![CDATA[<p>雖然 Hexo 的學習曲線平滑，網路上也是隨手可得教學資料，但仍免不了，在使用過程中碰到一些難點，因此順手記錄這些難點的解法，方便自己日後回顧檢查。</p>
<a id="more"></a>
<h2 id="Next-主題背景動畫配置無效果"><a href="#Next-主題背景動畫配置無效果" class="headerlink" title="Next 主題背景動畫配置無效果"></a>Next 主題背景動畫配置無效果</h2><p><code>Next</code>在5.x版本時，設定背景動畫效果，僅需在<code>_config.yml</code>調整<code>true or false</code>即有效果。但在6.X版本，不知道因為何種原因，這種設置方式完全失效，因此改採用下述三個步驟設置動畫效果。</p>
<p>e.g. 選擇 canvas_nest 這個效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. cd themes&#x2F;next</span></pre></td></tr><tr><td class="code"><pre><span class="line">2. git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-canvas-nest source &#x2F; lib &#x2F; canvas-nest</span></pre></td></tr><tr><td class="code"><pre><span class="line">3. next&#x2F;_config.yml 設定 enable: true</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">其他三種動畫效果，同前述。</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Next Theme</tag>
      </tags>
  </entry>
  <entry>
    <title>Next Theme Install Note</title>
    <url>/2019/11/28/next-theme-install-note/</url>
    <content><![CDATA[<p>安裝 Hexo 的難度不高，但是調整 Hexo Theme 的配置是件不小的工程，記錄一下自己的調整流程。</p>
<a id="more"></a>

<h2 id="挑選主體"><a href="#挑選主體" class="headerlink" title="挑選主體"></a>挑選主體</h2><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">挑選 Hexo 主題網址</a>，這個 Blog 以<code>Next</code>為例。<br>step1. 安裝<code>theme</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd hexo-blog</span></pre></td></tr><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span></pre></td></tr></table></figure>
<p>step2. 修改設定<code>_config.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: landscape &#x3D;&gt; theme: next</span></pre></td></tr></table></figure>
<p>重新啟動<code>hexo s</code></p>
<h2 id="參數設定"><a href="#參數設定" class="headerlink" title="參數設定"></a>參數設定</h2><p>在<code>themes/next/_config.yml</code>中，可以透過調整參數，開啟非常多功能，以下條列其中。</p>
<h3 id="主題"><a href="#主題" class="headerlink" title="主題"></a>主題</h3><p>Next 有四種 Scheme 可以選擇，預設主題風格是 Muse，找到 scheme 設定，再將想選擇的註釋去除即可。<br>e.g.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Schemes</span></pre></td></tr><tr><td class="code"><pre><span class="line"># scheme: Muse</span></pre></td></tr><tr><td class="code"><pre><span class="line"># scheme: Mist</span></pre></td></tr><tr><td class="code"><pre><span class="line"># scheme: Pisces</span></pre></td></tr><tr><td class="code"><pre><span class="line">scheme: Gemini</span></pre></td></tr></table></figure>
<h3 id="開啟社群帳號連結"><a href="#開啟社群帳號連結" class="headerlink" title="開啟社群帳號連結"></a>開啟社群帳號連結</h3><p>打開或新增個人社群網站連結，僅須將註釋去除即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">social:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;wuzhe0912 || github</span></pre></td></tr><tr><td class="code"><pre><span class="line">  E-Mail: mailto:kgb00128@gmail.com || envelope</span></pre></td></tr></table></figure>
<h3 id="文章預覽"><a href="#文章預覽" class="headerlink" title="文章預覽"></a>文章預覽</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  enable: false</span></pre></td></tr><tr><td class="code"><pre><span class="line">  length: 150</span></pre></td></tr></table></figure>
<p>也可以透過<code>&lt;!--more--&gt;</code>來裁切，在<code>&lt;!--more--&gt;</code>以上的文字，會出現在預覽。</p>
<h3 id="啟用文章閱讀進度條"><a href="#啟用文章閱讀進度條" class="headerlink" title="啟用文章閱讀進度條"></a>啟用文章閱讀進度條</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reading_progress:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  enable: true</span></pre></td></tr></table></figure>
<h3 id="左側啟用文章閱讀-數"><a href="#左側啟用文章閱讀-數" class="headerlink" title="左側啟用文章閱讀%數"></a>左側啟用文章閱讀%數</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">back2top:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  enable: true</span></pre></td></tr><tr><td class="code"><pre><span class="line">  # Back to top in sidebar.</span></pre></td></tr><tr><td class="code"><pre><span class="line">  sidebar: true</span></pre></td></tr><tr><td class="code"><pre><span class="line">  # Scroll percent label in b2t button.</span></pre></td></tr><tr><td class="code"><pre><span class="line">  scrollpercent: true</span></pre></td></tr></table></figure>
<h3 id="開啟網站底部用戶訪問量"><a href="#開啟網站底部用戶訪問量" class="headerlink" title="開啟網站底部用戶訪問量"></a>開啟網站底部用戶訪問量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  enable: true</span></pre></td></tr></table></figure>
<p>接著調整<code>themes/next/layout/_third-party/statistics/busuanzi-counter.swig</code>中這兩行程式碼，可以在 i 標籤插入中文描述。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;i class&#x3D;&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;&quot;&gt;&lt;&#x2F;i&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;i class&#x3D;&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;&quot;&gt;&lt;&#x2F;i&gt;</span></pre></td></tr></table></figure>
<h3 id="調整文章末尾-tag-樣式"><a href="#調整文章末尾-tag-樣式" class="headerlink" title="調整文章末尾 tag 樣式"></a>調整文章末尾 tag 樣式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tag_icon: true</span></pre></td></tr></table></figure>
<h3 id="增加本地搜索功能"><a href="#增加本地搜索功能" class="headerlink" title="增加本地搜索功能"></a>增加本地搜索功能</h3><p>安裝插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add hexo-generator-search hexo-generator-searchdb</span></pre></td></tr></table></figure>
<p>調整設定為 true</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  enable: true</span></pre></td></tr></table></figure>
<h2 id="關於作者"><a href="#關於作者" class="headerlink" title="關於作者"></a>關於作者</h2><h3 id="新增大頭貼"><a href="#新增大頭貼" class="headerlink" title="新增大頭貼"></a>新增大頭貼</h3><p>step 1 建立存放圖片用的資料夾</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir source&#x2F;images</span></pre></td></tr></table></figure>
<p>step 2 將大頭貼的照片丟入資料夾<code>source/images</code>，接著在主題設定<code>themes/next/_config.yml</code>中，設定大頭貼路徑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avatar:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  url: &#x2F;images&#x2F;avatar.jpeg</span></pre></td></tr></table></figure>
<h3 id="調整大頭貼樣式"><a href="#調整大頭貼樣式" class="headerlink" title="調整大頭貼樣式"></a>調整大頭貼樣式</h3><p>邊框改為圓形，設為 true</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rounded: false &#x3D;&gt; rounded: true</span></pre></td></tr></table></figure>
<p>hover 時，添加旋轉特效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rotated: false &#x3D;&gt; rotated: true</span></pre></td></tr></table></figure>
<h2 id="上方添加-Github-Fork-圖片"><a href="#上方添加-Github-Fork-圖片" class="headerlink" title="上方添加 Github Fork 圖片"></a>上方添加 Github Fork 圖片</h2><p>step 1 首先到<a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">GitHub Corners</a>或是<a href="https://github.blog/2008-12-19-github-ribbons/" target="_blank" rel="noopener">GitHub Ribbons</a>尋找自己喜歡的樣式，並 copy code<br>step 2 打開<code>themes/next/layout/_layout.swig</code>，在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>下面<br>step 3 將<code>href</code>後面的網址，替換成個人<code>GitHub</code>主頁。<br>重新啟動服務<code>hexo s</code>。</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Next Theme</tag>
      </tags>
  </entry>
  <entry>
    <title>重新拾筆</title>
    <url>/2019/11/27/firstPost/</url>
    <content><![CDATA[<p>信手寫一些雜談想法，就當做一篇簡單的隨筆。</p>
<a id="more"></a>
<h2 id="框架選擇"><a href="#框架選擇" class="headerlink" title="框架選擇"></a>框架選擇</h2><p><code>Hexo</code>從2018年開始接觸，期間雖然嘗試寫了幾篇筆記，但終究因為懶，時常無疾而終。雖然後面斷斷續續摸了幾種靜態站點框架，譬如<code>Hugo</code>、<code>Gatsby.js</code>、<code>Gridsome</code>，但始終沒有很順手。</p>
<p>但不否認，我個人蠻看好<code>Gatsby.js</code>的發展性，不過我目前還是走<code>Vue</code>的路線，對於<code>React</code>仍算陌生，<code>Gatsby.js</code>駕馭起來相當吃力，只能暫時放棄，重新運用<code>Hexo</code>作為Blog支撐，不過也不排除未來會遷移過去，就看後續的學習狀況吧。</p>
<h2 id="種一棵樹最好的時間是十年前，其次則是現在"><a href="#種一棵樹最好的時間是十年前，其次則是現在" class="headerlink" title="種一棵樹最好的時間是十年前，其次則是現在"></a>種一棵樹最好的時間是十年前，其次則是現在</h2><p>這句話，出自非洲經濟學家 Dambisa Moyo 的《dead aid》，作為書中的結尾言，非常簡短卻發人省思。從當下時間的角度來看，種下理想最好的決心固然是十年前，畢竟現在就能收穫。但既然這已成了往事，那考慮到未來的時間，<code>現在</code>就是未來的十年前。</p>
<p>勉勵自己，從現在開始認真寫blog吧！</p>
]]></content>
      <tags>
        <tag>隨想</tag>
      </tags>
  </entry>
</search>
